!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_PROGRAM_AUTHOR	Darren Hiebert	/dhiebert@users.sourceforge.net/
!_TAG_PROGRAM_NAME	Exuberant Ctags	//
!_TAG_PROGRAM_URL	http://ctags.sourceforge.net	/official site/
!_TAG_PROGRAM_VERSION	5.9~svn20110310	//
ABORT	g_heap/dlmalloc.h.c	618;"	d	file:
ABORT_ON_ASSERT_FAILURE	g_heap/dlmalloc.h.c	621;"	d	file:
ACQUIRE_LOCK	g_heap/dlmalloc.h.c	1748;"	d	file:
ACQUIRE_LOCK	g_heap/dlmalloc.h.c	1849;"	d	file:
ACQUIRE_LOCK	g_heap/dlmalloc.h.c	1915;"	d	file:
ACQUIRE_LOCK	g_heap/dlmalloc.h.c	1947;"	d	file:
ACQUIRE_MALLOC_GLOBAL_LOCK	g_heap/dlmalloc.h.c	1999;"	d	file:
ACQUIRE_MALLOC_GLOBAL_LOCK	g_heap/dlmalloc.h.c	2005;"	d	file:
ANNULLED	ddr_mem.cpp	/^        enum State { IDLE, QUEUED, RUNNING, ANNULLED };$/;"	e	enum:SchedEvent::State	file:
ATTR_LINE_ALIGNED	null_core.h	/^} ATTR_LINE_ALIGNED; \/\/This needs to take up a whole cache line, or false sharing will be extremely frequent$/;"	v	typeref:class:NullCore
ATTR_LINE_ALIGNED	ooo_core.h	/^} ATTR_LINE_ALIGNED;  \/\/ Take up an int number of cache lines$/;"	v	typeref:class:OOOCore
ATTR_LINE_ALIGNED	pad.h	42;"	d
ATTR_LINE_ALIGNED	simple_core.h	/^}  ATTR_LINE_ALIGNED; \/\/This needs to take up a whole cache line, or false sharing will be extremely frequent$/;"	v	typeref:class:SimpleCore
ATTR_LINE_ALIGNED	timing_core.h	/^} ATTR_LINE_ALIGNED;$/;"	v	typeref:class:TimingCore
ATTR_LINE_ALIGNED	zsim.cpp	/^InstrFuncPtrs fPtrs[MAX_THREADS] ATTR_LINE_ALIGNED; \/\/minimize false sharing$/;"	v
AccTimes	repl_policies.h	/^        struct AccTimes {$/;"	s	class:ProfViolReplPolicy
AccessTimes	prefetcher.h	/^            struct AccessTimes {$/;"	s	struct:StreamPrefetcher::Entry
AccessType	memory_hierarchy.h	/^} AccessType;$/;"	t	typeref:enum:__anon8
AccessTypeName	memory_hierarchy.cpp	/^const char* AccessTypeName(AccessType t) {$/;"	f
ActWindow	ddr_mem.h	/^class ActWindow {$/;"	c
AdaptiveEvent	event_queue.h	/^        AdaptiveEvent(G _get, F _fire, uint64_t _start, uint64_t _target, uint64_t _maxRate) : Event(0), get(_get), fire(_fire), target(_target), maxRate(_maxRate) {$/;"	f	class:AdaptiveEvent
AdaptiveEvent	event_queue.h	/^class AdaptiveEvent : public Event {$/;"	c
AddrLoc	ddr_mem.h	/^        struct AddrLoc {$/;"	s	class:DDRMemory
Address	memory_hierarchy.h	/^typedef uint64_t Address;$/;"	t
AddressMap	detailed_mem.cpp	/^void MemChannelBase::AddressMap(Address addr, uint32_t& row, uint32_t& col, uint32_t& rank, uint32_t& bank) {$/;"	f	class:MemChannelBase
AfterForkInChild	zsim.cpp	/^VOID AfterForkInChild(THREADID tid, const CONTEXT* ctxt, VOID * arg) {$/;"	f
AfterForkInParent	zsim.cpp	/^VOID AfterForkInParent(THREADID tid, const CONTEXT* ctxt, VOID * arg) {$/;"	f
AggregateStat	stats.h	/^        explicit AggregateStat(bool isRegular = false) : Stat(), _isMutable(true), _isRegular(isRegular) {}$/;"	f	class:AggregateStat
AggregateStat	stats.h	/^class AggregateStat : public Stat {$/;"	c
BARRIER_H_	barrier.h	39;"	d
BILLION	locks.h	186;"	d
BINSIZE	ddr_mem.h	/^        static const uint32_t BINSIZE = 10, NUMBINS = 100;$/;"	m	class:DDRMemory
BITHACKS_H_	bithacks.h	27;"	d
BLOCKED	scheduler.h	/^            BLOCKED, \/\/inside a system call, no cid assigned, not in the barrier or the runqueue$/;"	e	enum:Scheduler::ThreadState
Bank	ddr_mem.h	/^        struct Bank {$/;"	s	class:DDRMemory
Barrier	barrier.h	/^        Barrier(uint32_t _parallelThreads, Callee* _sched) : parallelThreads(_parallelThreads), rnd(0xBA77137), sched(_sched) {$/;"	f	class:Barrier
Barrier	barrier.h	/^class Barrier : public GlobAlloc {$/;"	c
BaseCache	memory_hierarchy.h	/^class BaseCache : public MemObject {$/;"	c
BblAndRecordFunc	timing_core.cpp	/^void TimingCore::BblAndRecordFunc(THREADID tid, ADDRINT bblAddr, BblInfo* bblInfo) {$/;"	f	class:TimingCore
BblFunc	null_core.cpp	/^void NullCore::BblFunc(THREADID tid, ADDRINT bblAddr, BblInfo* bblInfo) {$/;"	f	class:NullCore
BblFunc	ooo_core.cpp	/^void OOOCore::BblFunc(THREADID tid, ADDRINT bblAddr, BblInfo* bblInfo) {$/;"	f	class:OOOCore
BblFunc	simple_core.cpp	/^void SimpleCore::BblFunc(THREADID tid, ADDRINT bblAddr, BblInfo* bblInfo) {$/;"	f	class:SimpleCore
BblInfo	core.h	/^struct BblInfo {$/;"	s
BeforeFork	zsim.cpp	/^VOID BeforeFork(THREADID tid, const CONTEXT* ctxt, VOID * arg) {$/;"	f
BitScanForward	g_heap/dlmalloc.h.c	1432;"	d	file:
BitScanReverse	g_heap/dlmalloc.h.c	1433;"	d	file:
BranchFunc	null_core.h	/^        static void BranchFunc(THREADID, ADDRINT, BOOL, ADDRINT, ADDRINT) {}$/;"	f	class:NullCore
BranchFunc	ooo_core.cpp	/^void OOOCore::BranchFunc(THREADID tid, ADDRINT pc, BOOL taken, ADDRINT takenNpc, ADDRINT notTakenNpc) {$/;"	f	class:OOOCore
BranchFunc	simple_core.h	/^        static void BranchFunc(THREADID, ADDRINT, BOOL, ADDRINT, ADDRINT) {}$/;"	f	class:SimpleCore
BranchFunc	timing_core.h	/^        static void BranchFunc(THREADID, ADDRINT, BOOL, ADDRINT, ADDRINT) {}$/;"	f	class:TimingCore
BranchPredictorPAg	ooo_core.h	/^        BranchPredictorPAg() {$/;"	f	class:BranchPredictorPAg
BranchPredictorPAg	ooo_core.h	/^class BranchPredictorPAg {$/;"	c
BuildCacheBank	init.cpp	/^BaseCache* BuildCacheBank(Config& config, const string& prefix, g_string& name, uint32_t bankSize, bool isTerminal, uint32_t domain) {$/;"	f
BuildCacheGroup	init.cpp	/^CacheGroup* BuildCacheGroup(Config& config, const string& name, bool isTerminal) {$/;"	f
BuildMemoryController	init.cpp	/^MemObject* BuildMemoryController(Config& config, uint32_t lineSize, uint32_t frequency, uint32_t domain, g_string& name) {$/;"	f
CACHE_ARRAYS_H_	cache_arrays.h	27;"	d
CACHE_H_	cache.h	27;"	d
CACHE_LINE_BYTES	pad.h	32;"	d
CALL_DIRECT_MMAP	g_heap/dlmalloc.h.c	1631;"	d	file:
CALL_DIRECT_MMAP	g_heap/dlmalloc.h.c	1633;"	d	file:
CALL_DIRECT_MMAP	g_heap/dlmalloc.h.c	1641;"	d	file:
CALL_MMAP	g_heap/dlmalloc.h.c	1621;"	d	file:
CALL_MMAP	g_heap/dlmalloc.h.c	1623;"	d	file:
CALL_MMAP	g_heap/dlmalloc.h.c	1642;"	d	file:
CALL_MORECORE	g_heap/dlmalloc.h.c	1606;"	d	file:
CALL_MORECORE	g_heap/dlmalloc.h.c	1608;"	d	file:
CALL_MORECORE	g_heap/dlmalloc.h.c	1611;"	d	file:
CALL_MREMAP	g_heap/dlmalloc.h.c	1651;"	d	file:
CALL_MREMAP	g_heap/dlmalloc.h.c	1653;"	d	file:
CALL_MREMAP	g_heap/dlmalloc.h.c	1656;"	d	file:
CALL_MUNMAP	g_heap/dlmalloc.h.c	1626;"	d	file:
CALL_MUNMAP	g_heap/dlmalloc.h.c	1628;"	d	file:
CALL_MUNMAP	g_heap/dlmalloc.h.c	1643;"	d	file:
CC	coherence_ctrls.h	/^class CC : public GlobAlloc {$/;"	c
CHUNK_ALIGN_MASK	g_heap/dlmalloc.h.c	1506;"	d	file:
CHUNK_OVERHEAD	g_heap/dlmalloc.h.c	2166;"	d	file:
CHUNK_OVERHEAD	g_heap/dlmalloc.h.c	2168;"	d	file:
CINUSE_BIT	g_heap/dlmalloc.h.c	2210;"	d	file:
CMFAIL	g_heap/dlmalloc.h.c	1527;"	d	file:
COHERENCE_CTRLS_H_	coherence_ctrls.h	27;"	d
CONFIG_H_	config.h	27;"	d
CONSTANTS_H_	constants.h	27;"	d
CONTENTION_SIM_H_	contention_sim.h	27;"	d
CORE_H_	core.h	27;"	d
CORE_RECORDER_H_	core_recorder.h	27;"	d
CORRUPTION_ERROR_ACTION	g_heap/dlmalloc.h.c	2723;"	d	file:
CORRUPTION_ERROR_ACTION	g_heap/dlmalloc.h.c	2729;"	d	file:
CPUENUM_H_	cpuenum.h	27;"	d
CPUID_H_	cpuid.h	27;"	d
CURRENT_THREAD	g_heap/dlmalloc.h.c	1745;"	d	file:
CURRENT_THREAD	g_heap/dlmalloc.h.c	1847;"	d	file:
CURRENT_THREAD	g_heap/dlmalloc.h.c	1913;"	d	file:
CURRENT_THREAD	g_heap/dlmalloc.h.c	1945;"	d	file:
Cache	cache.cpp	/^Cache::Cache(uint32_t _numLines, CC* _cc, CacheArray* _array, ReplPolicy* _rp, uint32_t _accLat, uint32_t _invLat, const g_string& _name)$/;"	f	class:Cache
Cache	cache.h	/^class Cache : public BaseCache {$/;"	c
CacheArray	cache_arrays.h	/^class CacheArray : public GlobAlloc {$/;"	c
CacheGroup	init.cpp	/^typedef vector<vector<BaseCache*>> CacheGroup;$/;"	t	file:
CalcActConst	detailed_mem.cpp	/^uint64_t MemChannelBase::CalcActConst(uint32_t rank, uint32_t bank, uint64_t issuableCycle) {$/;"	f	class:MemChannelBase
CalcDQTermAcc	detailed_mem.cpp	/^uint64_t MemControllerBase::CalcDQTermAcc(uint64_t acc_dq, uint64_t memCycle, uint64_t lastMemCycle) {$/;"	f	class:MemControllerBase
CalcDQTermCur	detailed_mem.cpp	/^uint64_t MemControllerBase::CalcDQTermCur(uint64_t acc_dq, uint64_t last_dq, uint64_t instCycle, uint64_t memCycle, uint64_t lastMemCycle) {$/;"	f	class:MemControllerBase
CalcInterIssueCycle	detailed_mem.cpp	/^uint64_t MemChannelBase::CalcInterIssueCycle(MemAccessType type, uint64_t arrivalCycle) {$/;"	f	class:MemChannelBase
CalcIntraIssueCycle	detailed_mem.cpp	/^uint64_t MemChannelBase::CalcIntraIssueCycle(bool rowHit, uint32_t rank, MemAccessType type, uint64_t arrivalCycle, uint32_t refreshNum) {$/;"	f	class:MemChannelBase
CalcPreConst	detailed_mem.cpp	/^uint64_t MemChannelBase::CalcPreConst(uint32_t rank, uint32_t bank, MemAccessType type, uint64_t issuableCycle) {$/;"	f	class:MemChannelBase
CalcRdWrConst	detailed_mem.cpp	/^uint64_t MemChannelBase::CalcRdWrConst(uint32_t rank, MemAccessType type, uint64_t issuableCycle) {$/;"	f	class:MemChannelBase
Callee	barrier.h	/^class Callee {$/;"	c
CheckContinuousAccess	detailed_mem.cpp	/^bool MemChannelBase::CheckContinuousAccess(uint64_t arrivalCycle, uint32_t rank, uint32_t bank, uint32_t row) {$/;"	f	class:MemChannelBase
CheckForMESIRace	coherence_ctrls.h	/^static inline bool CheckForMESIRace(AccessType& type, MESIState* state, MESIState initialState) {$/;"	f
CheckForTermination	zsim.cpp	/^VOID CheckForTermination() {$/;"	f
CheckSetEvent	detailed_mem.cpp	/^bool MemSchedulerDefault::CheckSetEvent(MemAccessEventBase* ev) {$/;"	f	class:MemSchedulerDefault
ClockDomainInfo	zsim.h	/^struct ClockDomainInfo {$/;"	s
ClockStat	profile_stats.h	/^        ClockStat() : ScalarStat(), startNs(0), totalNs(0) {}$/;"	f	class:ClockStat
ClockStat	profile_stats.h	/^class ClockStat : public ScalarStat {$/;"	c
CompareDomains	contention_sim.h	/^        struct CompareDomains : public std::binary_function<DomainData*, DomainData*, bool> {$/;"	s	class:ContentionSim
CompareEvents	contention_sim.h	/^        struct CompareEvents : public std::binary_function<TimingEvent*, TimingEvent*, bool> {$/;"	s	class:ContentionSim
CompareRespEvents	ooo_core_recorder.h	/^        struct CompareRespEvents : public std::binary_function<OOORespEvent*, OOORespEvent*, bool> {$/;"	s	class:OOOCoreRecorder
CompileTimeAsserts	memory_hierarchy.cpp	/^static inline void CompileTimeAsserts() {$/;"	f	file:
Config	config.cpp	/^Config::Config(const char* inFile) {$/;"	f	class:Config
Config	config.h	/^class Config {$/;"	c
ContentionSim	contention_sim.cpp	/^ContentionSim::ContentionSim(uint32_t _numDomains, uint32_t _numSimThreads) {$/;"	f	class:ContentionSim
ContentionSim	contention_sim.h	/^class ContentionSim : public GlobAlloc {$/;"	c
ContextChange	zsim.cpp	/^VOID ContextChange(THREADID tid, CONTEXT_CHANGE_REASON reason, const CONTEXT* from, CONTEXT* to, INT32 info, VOID* v) {$/;"	f
ContextInfo	scheduler.h	/^        struct ContextInfo : InListNode<ContextInfo> {$/;"	s	class:Scheduler
ContextState	scheduler.h	/^        enum ContextState {$/;"	g	class:Scheduler
Core	core.h	/^        explicit Core(g_string& _name) : lastUpdateCycles(0), lastUpdateInstrs(0), name(_name) {}$/;"	f	class:Core
Core	core.h	/^class Core : public GlobAlloc {$/;"	c
CorePartMapper	partition_mapper.h	/^        explicit CorePartMapper(uint32_t _numCores) : numCores(_numCores) {}$/;"	f	class:CorePartMapper
CorePartMapper	partition_mapper.h	/^class CorePartMapper : public PartMapper {$/;"	c
CoreRecorder	core_recorder.cpp	/^CoreRecorder::CoreRecorder(uint32_t _domain, g_string& _name)$/;"	f	class:CoreRecorder
CoreRecorder	core_recorder.h	/^class CoreRecorder {$/;"	c
CountActiveThreads	zsim.cpp	/^uint32_t CountActiveThreads() {$/;"	f
Counter	stats.h	/^        Counter() : Stat(), _count(0) {}$/;"	f	class:Counter
Counter	stats.h	/^class Counter : public Stat {$/;"	c
CpuIdRecord	cpuid.h	/^struct CpuIdRecord {$/;"	s
CreateProcessTree	process_tree.cpp	/^void CreateProcessTree(Config& config) {$/;"	f
CrossingEvent	timing_event.cpp	/^CrossingEvent::CrossingEvent(TimingEvent* parent, TimingEvent* child, uint64_t _minStartCycle, EventRecorder* _evRec)$/;"	f	class:CrossingEvent
CrossingEvent	timing_event.h	/^class CrossingEvent : public TimingEvent {$/;"	c
CrossingEventInfo	contention_sim.h	/^        struct CrossingEventInfo {$/;"	s	class:ContentionSim
CrossingSrcEvent	timing_event.h	/^                CrossingSrcEvent(CrossingEvent* _ce, uint32_t dom) : TimingEvent(0, 0, dom), ce(_ce) {$/;"	f	class:CrossingEvent::CrossingSrcEvent
CrossingSrcEvent	timing_event.h	/^        class CrossingSrcEvent : public TimingEvent {$/;"	c	class:CrossingEvent
CrossingStack	event_recorder.h	/^typedef g_vector<CrossingEvent*> CrossingStack;$/;"	t
CycleBreakdownStat	breakdown_stats.h	/^        CycleBreakdownStat() : VectorCounter() {}$/;"	f	class:CycleBreakdownStat
CycleBreakdownStat	breakdown_stats.h	/^class CycleBreakdownStat : public VectorCounter {$/;"	c
CycleQueue	ooo_core.h	/^        CycleQueue() {$/;"	f	class:CycleQueue
CycleQueue	ooo_core.h	/^class CycleQueue {$/;"	c
DBG	prefetcher.cpp	30;"	d	file:
DDRMemory	ddr_mem.cpp	/^DDRMemory::DDRMemory(uint32_t _lineSize, uint32_t _colSize, uint32_t _ranksPerChannel, uint32_t _banksPerRank,$/;"	f	class:DDRMemory
DDRMemory	ddr_mem.h	/^class DDRMemory : public MemObject {$/;"	c
DDRMemoryAccEvent	ddr_mem.cpp	/^        DDRMemoryAccEvent(DDRMemory* _mem, bool _isWrite, Address _addr, int32_t domain, uint32_t preDelay, uint32_t postDelay)$/;"	f	class:DDRMemoryAccEvent
DDRMemoryAccEvent	ddr_mem.cpp	/^class DDRMemoryAccEvent : public TimingEvent {$/;"	c	file:
DDR_MEM_H_	ddr_mem.h	27;"	d
DEBUG	ddr_mem.cpp	38;"	d	file:
DEBUG	g_heap/dlmalloc.h.c	1361;"	d	file:
DEBUG_BARRIER	barrier.h	58;"	d
DEBUG_FL	scheduler.cpp	45;"	d	file:
DEBUG_FUTEX	scheduler.cpp	48;"	d	file:
DEBUG_HARNESS_H_	debug_harness.h	27;"	d
DEBUG_H_	debug.h	27;"	d
DEBUG_MSG	core_recorder.cpp	30;"	d	file:
DEBUG_MSG	ooo_core.cpp	41;"	d	file:
DEBUG_MSG	ooo_core_recorder.cpp	31;"	d	file:
DEBUG_MSG	timing_core.cpp	30;"	d	file:
DEBUG_UMON	utility_monitor.cpp	29;"	d	file:
DEBUG_ZSIM_H_	debug_zsim.h	27;"	d
DECL_RANK_BINDING	repl_policies.h	64;"	d
DECL_RANK_BINDINGS	ideal_arrays.h	/^        DECL_RANK_BINDINGS;$/;"	m	class:IdealLRUPartReplPolicy
DECL_RANK_BINDINGS	repl_policies.h	/^        DECL_RANK_BINDINGS;$/;"	m	class:LRUReplPolicy
DECL_RANK_BINDINGS	repl_policies.h	/^        DECL_RANK_BINDINGS;$/;"	m	class:LegacyReplPolicy
DECL_RANK_BINDINGS	repl_policies.h	65;"	d
DECODER_H_	decoder.h	27;"	d
DECODE_STAGE	ooo_core.cpp	49;"	d	file:
DEFAULT_GRANULARITY	g_heap/dlmalloc.h.c	672;"	d	file:
DEFAULT_GRANULARITY	g_heap/dlmalloc.h.c	674;"	d	file:
DEFAULT_MMAP_THRESHOLD	g_heap/dlmalloc.h.c	686;"	d	file:
DEFAULT_MMAP_THRESHOLD	g_heap/dlmalloc.h.c	688;"	d	file:
DEFAULT_TRIM_THRESHOLD	g_heap/dlmalloc.h.c	679;"	d	file:
DEFAULT_TRIM_THRESHOLD	g_heap/dlmalloc.h.c	681;"	d	file:
DIRECT_MMAP	g_heap/dlmalloc.h.c	1640;"	d	file:
DIRECT_MMAP_DEFAULT	g_heap/dlmalloc.h.c	1553;"	d	file:
DIRECT_MMAP_DEFAULT	g_heap/dlmalloc.h.c	1590;"	d	file:
DISPATCH_STAGE	ooo_core.cpp	51;"	d	file:
DLMALLOC_VERSION	g_heap/dlmalloc.h.c	540;"	d	file:
DRAINING	core_recorder.h	/^            DRAINING \/\/Not scheduled, but events remain. join() --> RUNNING; all events done --> HALTED$/;"	e	enum:CoreRecorder::__anon12
DRAINING	ooo_core_recorder.h	/^            DRAINING \/\/Not scheduled, but events remain. join() --> RUNNING; all events done --> HALTED$/;"	e	enum:OOOCoreRecorder::__anon2
DRAMSIM_MEM_CTRL_H_	dramsim_mem_ctrl.h	27;"	d
DRAMSim	dramsim_mem_ctrl.h	/^namespace DRAMSim {$/;"	n
DRAMSimAccEvent	dramsim_mem_ctrl.cpp	/^        DRAMSimAccEvent(DRAMSimMemory* _dram, bool _write, Address _addr, int32_t domain) :  TimingEvent(0, 0, domain), dram(_dram), write(_write), addr(_addr) {}$/;"	f	class:DRAMSimAccEvent
DRAMSimAccEvent	dramsim_mem_ctrl.cpp	/^class DRAMSimAccEvent : public TimingEvent {$/;"	c	file:
DRAMSimMemory	dramsim_mem_ctrl.cpp	/^DRAMSimMemory::DRAMSimMemory(string& dramTechIni, string& dramSystemIni, string& outputDir, string& traceName,$/;"	f	class:DRAMSimMemory
DRAMSimMemory	dramsim_mem_ctrl.h	/^class DRAMSimMemory : public MemObject { \/\/one DRAMSim controller$/;"	c
DRAM_read_return_cb	dramsim_mem_ctrl.cpp	/^void DRAMSimMemory::DRAM_read_return_cb(uint32_t id, uint64_t addr, uint64_t memCycle) { panic("???"); }$/;"	f	class:DRAMSimMemory
DRAM_read_return_cb	dramsim_mem_ctrl.cpp	/^void DRAMSimMemory::DRAM_read_return_cb(uint32_t id, uint64_t addr, uint64_t memCycle) {$/;"	f	class:DRAMSimMemory
DRAM_write_return_cb	dramsim_mem_ctrl.cpp	/^void DRAMSimMemory::DRAM_write_return_cb(uint32_t id, uint64_t addr, uint64_t memCycle) { panic("???"); }$/;"	f	class:DRAMSimMemory
DRAM_write_return_cb	dramsim_mem_ctrl.cpp	/^void DRAMSimMemory::DRAM_write_return_cb(uint32_t id, uint64_t addr, uint64_t memCycle) {$/;"	f	class:DRAMSimMemory
Decoder	decoder.h	/^class Decoder {$/;"	c
DefaultMaskStr	process_tree.cpp	/^static string DefaultMaskStr() {$/;"	f	file:
DelayEvent	timing_event.h	/^        explicit DelayEvent(uint32_t delay) : TimingEvent(delay, 0) {}$/;"	f	class:DelayEvent
DelayEvent	timing_event.h	/^class DelayEvent : public TimingEvent {$/;"	c
DomainData	contention_sim.h	/^        struct DomainData : public GlobAlloc {$/;"	s	class:ContentionSim
DumpEventualStats	process_tree.cpp	/^static void DumpEventualStats(uint32_t procIdx, const char* reason) {$/;"	f	file:
DynBbl	decoder.h	/^struct DynBbl {$/;"	s
DynUop	decoder.h	/^struct DynUop {$/;"	s
DynUopVec	decoder.h	/^typedef std::vector<DynUop> DynUopVec;$/;"	t
E	memory_hierarchy.h	/^    E, \/\/ exclusive and clean$/;"	e	enum:__anon10
EVENT_QUEUE_H_	event_queue.h	27;"	d
EVENT_RECORDER_H_	event_recorder.h	27;"	d
EV_DONE	timing_event.h	/^enum EventState {EV_NONE, EV_QUEUED, EV_RUNNING, EV_HELD, EV_DONE};$/;"	e	enum:EventState
EV_HELD	timing_event.h	/^enum EventState {EV_NONE, EV_QUEUED, EV_RUNNING, EV_HELD, EV_DONE};$/;"	e	enum:EventState
EV_NONE	timing_event.h	/^enum EventState {EV_NONE, EV_QUEUED, EV_RUNNING, EV_HELD, EV_DONE};$/;"	e	enum:EventState
EV_QUEUED	timing_event.h	/^enum EventState {EV_NONE, EV_QUEUED, EV_RUNNING, EV_HELD, EV_DONE};$/;"	e	enum:EventState
EV_RUNNING	timing_event.h	/^enum EventState {EV_NONE, EV_QUEUED, EV_RUNNING, EV_HELD, EV_DONE};$/;"	e	enum:EventState
EXTERN_BIT	g_heap/dlmalloc.h.c	1663;"	d	file:
EndOfPhaseActions	zsim.cpp	/^VOID EndOfPhaseActions() {$/;"	f
EnterFastForward	zsim.cpp	/^void EnterFastForward() {$/;"	f
Entry	coherence_ctrls.h	/^        struct Entry {$/;"	s	class:MESITopCC
Entry	ideal_arrays.h	/^            Entry(uint32_t _id, uint32_t _p) : lineId(_id), p(_p), used(true) {}$/;"	f	struct:IdealLRUPartReplPolicy::Entry
Entry	ideal_arrays.h	/^            explicit Entry(uint32_t _lineId) : lineAddr(0), lineId(_lineId) {}$/;"	f	struct:IdealLRUArray::Entry
Entry	ideal_arrays.h	/^        struct Entry : InListNode<Entry> {$/;"	s	class:IdealLRUArray
Entry	ideal_arrays.h	/^        struct Entry : InListNode<Entry> {$/;"	s	class:IdealLRUPartReplPolicy
Entry	prefetcher.h	/^        struct Entry {$/;"	s	class:StreamPrefetcher
EstimateBandwidth	detailed_mem.cpp	/^void MemControllerBase::EstimateBandwidth(uint64_t realTime, uint64_t lastTime, bool finish) {$/;"	f	class:MemControllerBase
EstimatePowers	detailed_mem.cpp	/^void MemControllerBase::EstimatePowers(uint64_t sysCycle, bool finish) {$/;"	f	class:MemControllerBase
Event	event_queue.h	/^        explicit Event(uint64_t _period) : period(_period) {} \/\/period == 0 events are one-shot$/;"	f	class:Event
Event	event_queue.h	/^class Event : public GlobAlloc {$/;"	c
EventQueue	event_queue.h	/^        EventQueue() { futex_init(&qLock); }$/;"	f	class:EventQueue
EventQueue	event_queue.h	/^class EventQueue : public GlobAlloc {$/;"	c
EventRecorder	event_recorder.h	/^        EventRecorder() {}$/;"	f	class:EventRecorder
EventRecorder	event_recorder.h	/^class EventRecorder : public GlobAlloc {$/;"	c
EventState	timing_event.h	/^enum EventState {EV_NONE, EV_QUEUED, EV_RUNNING, EV_HELD, EV_DONE};$/;"	g
ExitFastForward	zsim.cpp	/^void ExitFastForward() {$/;"	f
FEMap	prio_queue.h	/^    typedef g_multimap<uint64_t, T*> FEMap; \/\/far element map$/;"	t	class:PrioQueue
FEMapIterator	prio_queue.h	/^    typedef typename FEMap::iterator FEMapIterator;$/;"	t	class:PrioQueue
FENCEPOST_HEAD	g_heap/dlmalloc.h.c	2216;"	d	file:
FETCH_BYTES_PER_CYCLE	ooo_core.cpp	54;"	d	file:
FETCH_STAGE	ooo_core.cpp	48;"	d	file:
FFBasicBlock	zsim.cpp	/^VOID FFBasicBlock(THREADID tid, ADDRINT bblAddr, BblInfo* bblInfo) {$/;"	f
FFIAdvance	zsim.cpp	/^VOID FFIAdvance() {$/;"	f
FFIBasicBlock	zsim.cpp	/^VOID FFIBasicBlock(THREADID tid, ADDRINT bblAddr, BblInfo* bblInfo) {$/;"	f
FFIEntryBasicBlock	zsim.cpp	/^VOID FFIEntryBasicBlock(THREADID tid, ADDRINT bblAddr, BblInfo* bblInfo) {$/;"	f
FFIInit	zsim.cpp	/^VOID FFIInit() {$/;"	f
FFITrackNFFInterval	zsim.cpp	/^VOID FFITrackNFFInterval() {$/;"	f
FFThread	zsim.cpp	/^VOID FFThread(VOID* arg) {$/;"	f
FILTER_CACHE_H_	filter_cache.h	27;"	d
FJA_NONE	scheduler.h	/^        enum FutexJoinAction {FJA_NONE, FJA_WAKE, FJA_WAIT};$/;"	e	enum:Scheduler::FutexJoinAction
FJA_WAIT	scheduler.h	/^        enum FutexJoinAction {FJA_NONE, FJA_WAKE, FJA_WAIT};$/;"	e	enum:Scheduler::FutexJoinAction
FJA_WAKE	scheduler.h	/^        enum FutexJoinAction {FJA_NONE, FJA_WAKE, FJA_WAIT};$/;"	e	enum:Scheduler::FutexJoinAction
FLAG4_BIT	g_heap/dlmalloc.h.c	2211;"	d	file:
FLAG_BITS	g_heap/dlmalloc.h.c	2213;"	d	file:
FOOTERS	g_heap/dlmalloc.h.c	615;"	d	file:
FORCEINLINE	g_heap/dlmalloc.h.c	780;"	d	file:
FORCEINLINE	g_heap/dlmalloc.h.c	782;"	d	file:
FORCEINLINE	g_heap/dlmalloc.h.c	798;"	d	file:
FORCEINLINE	g_heap/dlmalloc.h.c	802;"	d	file:
FOUR_SIZE_T_SIZES	g_heap/dlmalloc.h.c	1501;"	d	file:
FPTR_ANALYSIS	core.h	58;"	d
FPTR_JOIN	core.h	59;"	d
FPTR_NOP	core.h	60;"	d
FWD	memory_hierarchy.h	/^    FWD,  \/\/ don't invalidate, just send up the data (used by directories). Only valid on S lines.$/;"	e	enum:__anon9
FWD_ENTRIES	ooo_core.h	431;"	d
FakeCPUIDPost	zsim.cpp	/^VOID FakeCPUIDPost(THREADID tid, ADDRINT* eax, ADDRINT* ebx, ADDRINT* ecx, ADDRINT* edx) {$/;"	f
FakeCPUIDPre	zsim.cpp	/^VOID FakeCPUIDPre(THREADID tid, REG eax, REG ecx) {$/;"	f
FakeLeaveInfo	scheduler.h	/^            FakeLeaveInfo(uint64_t _pc, ThreadInfo* _th, int _syscallNumber, uint64_t _arg0, uint64_t _arg1) :$/;"	f	struct:Scheduler::FakeLeaveInfo
FakeLeaveInfo	scheduler.h	/^        struct FakeLeaveInfo : GlobAlloc, InListNode<FakeLeaveInfo> {$/;"	s	class:Scheduler
FakeRDTSCPost	zsim.cpp	/^VOID FakeRDTSCPost(THREADID tid, REG* eax, REG* edx) {$/;"	f
FilterCache	filter_cache.h	/^        FilterCache(uint32_t _numSets, uint32_t _numLines, CC* _cc, CacheArray* _array,$/;"	f	class:FilterCache
FilterCache	filter_cache.h	/^class FilterCache : public Cache {$/;"	c
FilterEntry	filter_cache.h	/^        struct FilterEntry {$/;"	s	class:FilterCache
FilterStats	stats_filter.cpp	/^AggregateStat* FilterStats(const AggregateStat* rootStat, const char* regexStr) {$/;"	f
FilterStatsLevel	stats_filter.cpp	/^AggregateStat* FilterStatsLevel(const AggregateStat* src, const regex& filter, const char* prefix) {$/;"	f
FindBestRequest	detailed_mem.cpp	/^bool MemSchedulerDefault::FindBestRequest(g_vector<MemSchedQueueElem> *queue, uint32_t& idx) {$/;"	f	class:MemSchedulerDefault
FindSection	zsim.cpp	/^static Section FindSection(const char* sec) {$/;"	f	file:
Fini	zsim.cpp	/^VOID Fini(int code, VOID * v) {$/;"	f
Flag	memory_hierarchy.h	/^    enum Flag {$/;"	g	struct:MemReq
FollowChild	zsim.cpp	/^BOOL FollowChild(CHILD_PROCESS childProcess, VOID * userData) {$/;"	f
FutexInfo	virt/timeout.cpp	/^struct FutexInfo {$/;"	s	file:
FutexJoinAction	scheduler.h	/^        enum FutexJoinAction {FJA_NONE, FJA_WAKE, FJA_WAIT};$/;"	g	class:Scheduler
FutexJoinInfo	scheduler.h	/^        struct FutexJoinInfo {$/;"	s	class:Scheduler
FwdEntry	ooo_core.h	/^        struct FwdEntry {$/;"	s	class:OOOCore
GALLOC_H_	galloc.h	27;"	d
GETS	memory_hierarchy.h	/^    GETS, \/\/ get line, exclusive permission not needed (triggered by a processor load)$/;"	e	enum:__anon8
GETX	memory_hierarchy.h	/^    GETX, \/\/ get line, exclusive permission needed (triggered by a processor store o atomic access)$/;"	e	enum:__anon8
GM	galloc.cpp	/^static gm_segment* GM = NULL;$/;"	v	file:
GM_BASE_ADDR	galloc.cpp	51;"	d	file:
GRACEFUL_TERMINATION	zsim_harness.cpp	/^    GRACEFUL_TERMINATION,$/;"	e	enum:__anon3	file:
G_LIST_H_	g_std/g_list.h	27;"	d
G_MULTIMAP_H_	g_std/g_multimap.h	27;"	d
G_STRING_H_	g_std/g_string.h	27;"	d
G_UNORDERED_MAP_H_	g_std/g_unordered_map.h	27;"	d
G_UNORDERED_SET_H_	g_std/g_unordered_set.h	27;"	d
G_VECTOR_H_	g_std/g_vector.h	27;"	d
GetAccessInRefresh	detailed_mem.h	/^        uint32_t GetAccessInRefresh(void) { return accessInRefresh; }$/;"	f	class:MemRankBase
GetActPreEnergy	detailed_mem.cpp	/^uint64_t MemChannelBase::GetActPreEnergy(void) {$/;"	f	class:MemChannelBase
GetActivateCount	detailed_mem.cpp	/^uint64_t MemChannelBase::GetActivateCount(void) {$/;"	f	class:MemChannelBase
GetActivateCount	detailed_mem.h	/^        uint64_t GetActivateCount(void) { return activateCount; }$/;"	f	class:MemRankBase
GetActiveBankCount	detailed_mem.cpp	/^uint32_t MemRankBase::GetActiveBankCount(void) {$/;"	f	class:MemRankBase
GetActvPowerDownCycle	detailed_mem.h	/^        uint64_t GetActvPowerDownCycle(void) { return actvPowerDownCycle; }$/;"	f	class:MemRankBase
GetBackGroundEnergy	detailed_mem.cpp	/^uint64_t MemChannelBase::GetBackGroundEnergy(uint64_t memCycle, uint64_t lastMemCycle, bool bInstant) {$/;"	f	class:MemChannelBase
GetBankCount	detailed_mem.h	/^        uint32_t GetBankCount(void) {return bankCount; }$/;"	f	class:MemRankBase
GetBankOpen	detailed_mem.h	/^        bool GetBankOpen(uint32_t bank) { return bankinfo[bank]; }$/;"	f	class:MemRankBase
GetBurstEnergy	detailed_mem.cpp	/^uint64_t MemChannelBase::GetBurstEnergy(void) {$/;"	f	class:MemChannelBase
GetDataDelay	detailed_mem_params.cpp	/^uint32_t MemParam::GetDataDelay(uint32_t type)$/;"	f	class:MemParam
GetDataLatency	detailed_mem_params.cpp	/^uint32_t MemParam::GetDataLatency(uint32_t type)$/;"	f	class:MemParam
GetDataSlot	detailed_mem_params.cpp	/^uint32_t MemParam::GetDataSlot(uint32_t type)$/;"	f	class:MemParam
GetEvent	detailed_mem.cpp	/^bool MemSchedulerDefault::GetEvent(MemAccessEventBase*& ev, Address& addr, MemAccessType& type) {$/;"	f	class:MemSchedulerDefault
GetFAWCycle	detailed_mem.h	/^        uint64_t GetFAWCycle(uint32_t bank) { return tFAWCycle[bank]; }$/;"	f	class:MemRankBase
GetFAWCycle	detailed_mem.h	/^        uint64_t GetFAWCycle(void) { return tFAWCycle[tFAWIndex]; }$/;"	f	class:MemRankBase
GetFFPtrs	zsim.cpp	/^static const InstrFuncPtrs& GetFFPtrs() {$/;"	f	file:
GetFuncPtrs	null_core.cpp	/^InstrFuncPtrs NullCore::GetFuncPtrs() {$/;"	f	class:NullCore
GetFuncPtrs	ooo_core.cpp	/^InstrFuncPtrs OOOCore::GetFuncPtrs() {return {LoadFunc, StoreFunc, BblFunc, BranchFunc, PredLoadFunc, PredStoreFunc, FPTR_ANALYSIS, {0}};}$/;"	f	class:OOOCore
GetFuncPtrs	simple_core.cpp	/^InstrFuncPtrs SimpleCore::GetFuncPtrs() {$/;"	f	class:SimpleCore
GetFuncPtrs	timing_core.cpp	/^InstrFuncPtrs TimingCore::GetFuncPtrs() {$/;"	f	class:TimingCore
GetIdlePowerDownCycle	detailed_mem.h	/^        uint64_t GetIdlePowerDownCycle(void) { return idlePowerDownCycle; }$/;"	f	class:MemRankBase
GetIdleStandbyCycle	detailed_mem.h	/^        uint64_t GetIdleStandbyCycle(void) { return idleStandbyCycle; }$/;"	f	class:MemRankBase
GetLastAccessCycle	detailed_mem.h	/^        uint64_t GetLastAccessCycle(void) { return lastAccessCycle; }$/;"	f	class:MemRankBase
GetLastActCycle	detailed_mem.h	/^        uint64_t GetLastActCycle(uint32_t bank) { return lastActCycle[bank]; }$/;"	f	class:MemRankBase
GetLastBank	detailed_mem.h	/^        uint32_t GetLastBank(void) { return lastBank; }$/;"	f	class:MemRankBase
GetLastPreCycle	detailed_mem.h	/^        uint64_t GetLastPreCycle(uint32_t bank) { return lastPreCycle[bank]; }$/;"	f	class:MemRankBase
GetLastRdWrCycle	detailed_mem.h	/^        uint64_t GetLastRdWrCycle(uint32_t bank) { return lastRdWrCycle[bank]; }$/;"	f	class:MemRankBase
GetLastRefreshCycle	detailed_mem.h	/^        uint64_t GetLastRefreshCycle(void) { return lastRefreshCycle; }$/;"	f	class:MemRankBase
GetLastRow	detailed_mem.h	/^        uint32_t GetLastRow(uint32_t bank) { return lastRow[bank]; }$/;"	f	class:MemRankBase
GetLastType	detailed_mem.h	/^        MemAccessType GetLastType(uint32_t bank) { return lastType[bank]; }$/;"	f	class:MemRankBase
GetPowerDownPenalty	detailed_mem.cpp	/^uint32_t MemChannelBase::GetPowerDownPenalty(uint32_t rank, uint64_t arrivalCycle) {$/;"	f	class:MemChannelBase
GetPreDelay	detailed_mem_params.cpp	/^uint32_t MemParam::GetPreDelay(uint32_t type)$/;"	f	class:MemParam
GetPrechargeCount	detailed_mem.cpp	/^uint64_t MemChannelBase::GetPrechargeCount(void) {$/;"	f	class:MemChannelBase
GetPrechargeCount	detailed_mem.h	/^        uint32_t GetPrechargeCount(void) { return prechargeCount; }$/;"	f	class:MemRankBase
GetPrevActvPowerDownCycle	detailed_mem.h	/^        uint64_t GetPrevActvPowerDownCycle(void) { return prevActvPowerDownCycle; }$/;"	f	class:MemRankBase
GetPrevIdlePowerDownCycle	detailed_mem.h	/^        uint64_t GetPrevIdlePowerDownCycle(void) { return prevIdlePowerDownCycle; }$/;"	f	class:MemRankBase
GetPrevIdleStandbyCycle	detailed_mem.h	/^        uint64_t GetPrevIdleStandbyCycle(void) { return prevIdleStandbyCycle; }$/;"	f	class:MemRankBase
GetRdWrDelay	detailed_mem_params.cpp	/^uint32_t MemParam::GetRdWrDelay(uint32_t type, uint32_t lastType)$/;"	f	class:MemParam
GetReadBurstCount	detailed_mem.h	/^        uint64_t GetReadBurstCount(void) { return readBurstCount; }$/;"	f	class:MemRankBase
GetRefreshCount	detailed_mem.cpp	/^uint64_t MemChannelBase::GetRefreshCount(void) {$/;"	f	class:MemChannelBase
GetRefreshCycle	detailed_mem_params.cpp	/^uint32_t MemParam::GetRefreshCycle(void)$/;"	f	class:MemParam
GetRefreshEnergy	detailed_mem.cpp	/^uint64_t MemChannelBase::GetRefreshEnergy(void) {$/;"	f	class:MemChannelBase
GetRefreshNum	detailed_mem.h	/^        uint32_t GetRefreshNum(void) { return refreshNum; }$/;"	f	class:MemRankBase
GetSockAddr	virt/ports.cpp	/^static struct sockaddr_in* GetSockAddr(ADDRINT guestAddr, size_t guestSize) {$/;"	f	file:
GetSyscallName	virt/syscall_name.cpp	/^const char* GetSyscallName(uint32_t syscall) {$/;"	f
GetWriteBurstCount	detailed_mem.h	/^        uint64_t GetWriteBurstCount(void) { return writeBurstCount; }$/;"	f	class:MemRankBase
GlobAlloc	galloc.h	/^class GlobAlloc {$/;"	c
GlobSimInfo	zsim.h	/^struct GlobSimInfo {$/;"	s
H3HashFamily	hash.cpp	/^H3HashFamily::H3HashFamily(uint32_t numFunctions, uint32_t outputBits, uint64_t randSeed) : numFuncs(numFunctions) {$/;"	f	class:H3HashFamily
H3HashFamily	hash.h	/^class H3HashFamily : public HashFamily {$/;"	c
HALF_MAX_SIZE_T	g_heap/dlmalloc.h.c	1503;"	d	file:
HALTED	core_recorder.h	/^            HALTED, \/\/Not scheduled, no events left. Initial state. join() --> RUNNING$/;"	e	enum:CoreRecorder::__anon12
HALTED	ooo_core_recorder.h	/^            HALTED, \/\/Not scheduled, no events left. Initial state. join() --> RUNNING$/;"	e	enum:OOOCoreRecorder::__anon2
HASH_H_	hash.h	27;"	d
HAVE_MMAP	g_heap/dlmalloc.h.c	37;"	d	file:
HAVE_MMAP	g_heap/dlmalloc.h.c	555;"	d	file:
HAVE_MMAP	g_heap/dlmalloc.h.c	578;"	d	file:
HAVE_MMAP	g_heap/dlmalloc.h.c	640;"	d	file:
HAVE_MORECORE	g_heap/dlmalloc.h.c	36;"	d	file:
HAVE_MORECORE	g_heap/dlmalloc.h.c	556;"	d	file:
HAVE_MORECORE	g_heap/dlmalloc.h.c	577;"	d	file:
HAVE_MORECORE	g_heap/dlmalloc.h.c	657;"	d	file:
HAVE_MORECORE	g_heap/dlmalloc.h.c	659;"	d	file:
HAVE_MREMAP	g_heap/dlmalloc.h.c	38;"	d	file:
HAVE_MREMAP	g_heap/dlmalloc.h.c	647;"	d	file:
HAVE_MREMAP	g_heap/dlmalloc.h.c	649;"	d	file:
HDF5Backend	hdf5_stats.cpp	/^HDF5Backend::HDF5Backend(const char* filename, AggregateStat* rootStat, size_t bytesPerWrite, bool skipVectors, bool sumRegularAggregates) {$/;"	f	class:HDF5Backend
HDF5Backend	stats.h	/^class HDF5Backend : public StatsBackend {$/;"	c
HDF5BackendImpl	hdf5_stats.cpp	/^        HDF5BackendImpl(const char* _filename, AggregateStat* _rootStat, size_t _bytesPerWrite, bool _skipVectors, bool _sumRegularAggregates) :$/;"	f	class:HDF5BackendImpl
HDF5BackendImpl	hdf5_stats.cpp	/^class HDF5BackendImpl : public GlobAlloc {$/;"	c	file:
HandleMagicOp	zsim.cpp	/^VOID HandleMagicOp(THREADID tid, ADDRINT op) {$/;"	f
HashFamily	hash.h	/^        HashFamily() {}$/;"	f	class:HashFamily
HashFamily	hash.h	/^class HashFamily : public GlobAlloc {$/;"	c
HitEvent	timing_cache.cpp	/^        HitEvent(TimingCache* _cache,  uint32_t postDelay, int32_t domain) : TimingEvent(0, postDelay, domain), cache(_cache) {}$/;"	f	class:HitEvent
HitEvent	timing_cache.cpp	/^class HitEvent : public TimingEvent {$/;"	c	file:
I	memory_hierarchy.h	/^    I, \/\/ invalid$/;"	e	enum:__anon10
IDD0	detailed_mem_params.h	/^            uint32_t IDD0;$/;"	m	struct:MemParam::IDDs
IDD2N	detailed_mem_params.h	/^            uint32_t IDD2N;$/;"	m	struct:MemParam::IDDs
IDD2P	detailed_mem_params.h	/^            uint32_t IDD2P;$/;"	m	struct:MemParam::IDDs
IDD3N	detailed_mem_params.h	/^            uint32_t IDD3N;$/;"	m	struct:MemParam::IDDs
IDD3P	detailed_mem_params.h	/^            uint32_t IDD3P;$/;"	m	struct:MemParam::IDDs
IDD4R	detailed_mem_params.h	/^            uint32_t IDD4R;$/;"	m	struct:MemParam::IDDs
IDD4W	detailed_mem_params.h	/^            uint32_t IDD4W;$/;"	m	struct:MemParam::IDDs
IDD5	detailed_mem_params.h	/^            uint32_t IDD5;$/;"	m	struct:MemParam::IDDs
IDD_VDD1	detailed_mem_params.h	/^        IDDs IDD_VDD1;$/;"	m	class:MemParam
IDDs	detailed_mem_params.h	/^        struct IDDs {$/;"	s	class:MemParam
IDEAL_ARRAYS_H_	ideal_arrays.h	27;"	d
IDLE	ddr_mem.cpp	/^        enum State { IDLE, QUEUED, RUNNING, ANNULLED };$/;"	e	enum:SchedEvent::State	file:
IDLE	scheduler.h	/^            IDLE,$/;"	e	enum:Scheduler::ContextState
IFETCH	memory_hierarchy.h	/^        IFETCH        = (1<<1), \/\/For instruction fetches. Purely informative for now, does not imply NOEXCL (but ifetches should be marked NOEXCL)$/;"	e	enum:MemReq::Flag
INITIAL_LOCK	g_heap/dlmalloc.h.c	1747;"	d	file:
INITIAL_LOCK	g_heap/dlmalloc.h.c	1848;"	d	file:
INITIAL_LOCK	g_heap/dlmalloc.h.c	1914;"	d	file:
INITIAL_LOCK	g_heap/dlmalloc.h.c	1946;"	d	file:
INITIAL_LOCK	g_heap/dlmalloc.h.c	1994;"	d	file:
INIT_H_	init.h	27;"	d
INSECURE	g_heap/dlmalloc.h.c	637;"	d	file:
INTRUSIVE_LIST_H_	intrusive_list.h	27;"	d
INUSE_BITS	g_heap/dlmalloc.h.c	2212;"	d	file:
INV	memory_hierarchy.h	/^    INV,  \/\/ fully invalidate this line$/;"	e	enum:__anon9
INVALID_CID	zsim.cpp	106;"	d	file:
INVX	memory_hierarchy.h	/^    INVX, \/\/ invalidate exclusive access to this line (lower level can still keep a non-exclusive copy)$/;"	e	enum:__anon9
ISSUES_PER_CYCLE	ooo_core.cpp	55;"	d	file:
ISSUE_STAGE	ooo_core.cpp	50;"	d	file:
IdHashFamily	hash.h	/^class IdHashFamily : public HashFamily {$/;"	c
IdPartInfo	ideal_arrays.h	/^        struct IdPartInfo : public PartInfo {$/;"	s	class:IdealLRUPartReplPolicy
IdealLRUArray	ideal_arrays.h	/^        explicit IdealLRUArray(uint32_t _numLines) : numLines(_numLines), cc(NULL) {$/;"	f	class:IdealLRUArray
IdealLRUArray	ideal_arrays.h	/^class IdealLRUArray : public CacheArray {$/;"	c
IdealLRUPartArray	ideal_arrays.h	/^        IdealLRUPartArray(uint32_t _numLines, IdealLRUPartReplPolicy* _rp) : rp(_rp), numLines(_numLines) {$/;"	f	class:IdealLRUPartArray
IdealLRUPartArray	ideal_arrays.h	/^class IdealLRUPartArray : public CacheArray {$/;"	c
IdealLRUPartReplPolicy	ideal_arrays.h	/^        IdealLRUPartReplPolicy(PartitionMonitor* _monitor, PartMapper* _mapper, uint32_t _numLines, uint32_t _numBuckets) : PartReplPolicy(_monitor, _mapper), numLines(_numLines), numBuckets(_numBuckets) {$/;"	f	class:IdealLRUPartReplPolicy
IdealLRUPartReplPolicy	ideal_arrays.h	/^class IdealLRUPartReplPolicy : public PartReplPolicy {$/;"	c
InList	intrusive_list.h	/^        InList() : head(NULL), tail(NULL), elems(0) {}$/;"	f	class:InList
InList	intrusive_list.h	/^class InList {$/;"	c
InListNode	intrusive_list.h	/^    InListNode() {$/;"	f	struct:InListNode
InListNode	intrusive_list.h	/^struct InListNode {$/;"	s
IncActivateCount	detailed_mem.h	/^        void IncActivateCount(void) { activateCount++; }$/;"	f	class:MemRankBase
IncPrechargeCount	detailed_mem.h	/^        void IncPrechargeCount(void) { prechargeCount++; }$/;"	f	class:MemRankBase
IncReadBurstCount	detailed_mem.h	/^        void IncReadBurstCount(void) { readBurstCount++; }$/;"	f	class:MemRankBase
IncWriteBurstCount	detailed_mem.h	/^        void IncWriteBurstCount(void) { writeBurstCount++; }$/;"	f	class:MemRankBase
IndirectBasicBlock	zsim.cpp	/^VOID PIN_FAST_ANALYSIS_CALL IndirectBasicBlock(THREADID tid, ADDRINT bblAddr, BblInfo* bblInfo) {$/;"	f
IndirectLoadSingle	zsim.cpp	/^VOID PIN_FAST_ANALYSIS_CALL IndirectLoadSingle(THREADID tid, ADDRINT addr) {$/;"	f
IndirectPredLoadSingle	zsim.cpp	/^VOID PIN_FAST_ANALYSIS_CALL IndirectPredLoadSingle(THREADID tid, ADDRINT addr, BOOL pred) {$/;"	f
IndirectPredStoreSingle	zsim.cpp	/^VOID PIN_FAST_ANALYSIS_CALL IndirectPredStoreSingle(THREADID tid, ADDRINT addr, BOOL pred) {$/;"	f
IndirectRecordBranch	zsim.cpp	/^VOID PIN_FAST_ANALYSIS_CALL IndirectRecordBranch(THREADID tid, ADDRINT branchPc, BOOL taken, ADDRINT takenNpc, ADDRINT notTakenNpc) {$/;"	f
IndirectStoreSingle	zsim.cpp	/^VOID PIN_FAST_ANALYSIS_CALL IndirectStoreSingle(THREADID tid, ADDRINT addr) {$/;"	f
InitGlobalStats	init.cpp	/^static void InitGlobalStats() {$/;"	f	file:
InitLog	log.cpp	/^void InitLog(const char* header, const char* file) {$/;"	f
InitSystem	init.cpp	/^static void InitSystem(Config& config) {$/;"	f	file:
Instr	decoder.cpp	/^Decoder::Instr::Instr(INS _ins) : ins(_ins), numLoads(0), numInRegs(0), numOutRegs(0), numStores(0) {$/;"	f	class:Decoder::Instr
Instr	decoder.h	/^        struct Instr {$/;"	s	class:Decoder
InstrDataCorePartMapper	partition_mapper.h	/^        explicit InstrDataCorePartMapper(uint32_t _numCores) : numCores(_numCores) {}$/;"	f	class:InstrDataCorePartMapper
InstrDataCorePartMapper	partition_mapper.h	/^class InstrDataCorePartMapper : public PartMapper {$/;"	c
InstrDataPartMapper	partition_mapper.h	/^class InstrDataPartMapper : public PartMapper {$/;"	c
InstrDataProcessPartMapper	partition_mapper.h	/^        explicit InstrDataProcessPartMapper(uint32_t _numProcs) : numProcs(_numProcs) {}$/;"	f	class:InstrDataProcessPartMapper
InstrDataProcessPartMapper	partition_mapper.h	/^class InstrDataProcessPartMapper : public PartMapper {$/;"	c
InstrFuncPtrs	core.h	/^struct InstrFuncPtrs {  \/\/ NOLINT(whitespace)$/;"	s
Instruction	zsim.cpp	/^VOID Instruction(INS ins) {$/;"	f
InternalExceptionHandler	zsim.cpp	/^static EXCEPT_HANDLING_RESULT InternalExceptionHandler(THREADID tid, EXCEPTION_INFO *pExceptInfo, PHYSICAL_CONTEXT *pPhysCtxt, VOID *) {$/;"	f	file:
InvType	memory_hierarchy.h	/^} InvType;$/;"	t	typeref:enum:__anon9
InvTypeName	memory_hierarchy.cpp	/^const char* InvTypeName(InvType t) {$/;"	f
IsCloseRowBufPolicy	detailed_mem_params.cpp	/^bool MemParam::IsCloseRowBufPolicy() {$/;"	f	class:MemParam
IsOpenRowBufPolicy	detailed_mem_params.cpp	/^bool MemParam::IsOpenRowBufPolicy() {$/;"	f	class:MemParam
IsRowBufferHit	detailed_mem.cpp	/^bool MemChannelBase::IsRowBufferHit(uint32_t row, uint32_t rank, uint32_t bank) {$/;"	f	class:MemChannelBase
IsSleepingInFutex	scheduler.cpp	/^bool IsSleepingInFutex(uint32_t linuxPid, uint32_t linuxTid, uintptr_t futexAddr) {$/;"	f
IssueActivate	detailed_mem.cpp	/^void MemChannelBase::IssueActivate(uint32_t rank, uint32_t bank, uint64_t issuedCycle) {$/;"	f	class:MemChannelBase
IssuePrecharge	detailed_mem.cpp	/^void MemChannelBase::IssuePrecharge(uint32_t rank, uint32_t bank, uint64_t issuedCycle, bool continuous) {$/;"	f	class:MemChannelBase
JEDEC_BUS_WIDTH	ddr_mem.h	/^        static const uint32_t JEDEC_BUS_WIDTH = 64;$/;"	m	class:DDRMemory
Join	zsim.cpp	/^void Join(uint32_t tid) {$/;"	f
JoinAndBasicBlock	zsim.cpp	/^VOID JoinAndBasicBlock(THREADID tid, ADDRINT bblAddr, BblInfo* bblInfo) {$/;"	f
JoinAndLoadSingle	zsim.cpp	/^VOID JoinAndLoadSingle(THREADID tid, ADDRINT addr) {$/;"	f
JoinAndPredLoadSingle	zsim.cpp	/^VOID JoinAndPredLoadSingle(THREADID tid, ADDRINT addr, BOOL pred) {$/;"	f
JoinAndPredStoreSingle	zsim.cpp	/^VOID JoinAndPredStoreSingle(THREADID tid, ADDRINT addr, BOOL pred) {$/;"	f
JoinAndRecordBranch	zsim.cpp	/^VOID JoinAndRecordBranch(THREADID tid, ADDRINT branchPc, BOOL taken, ADDRINT takenNpc, ADDRINT notTakenNpc) {$/;"	f
JoinAndStoreSingle	zsim.cpp	/^VOID JoinAndStoreSingle(THREADID tid, ADDRINT addr) {$/;"	f
KILL_EM_ALL	zsim_harness.cpp	/^    KILL_EM_ALL,$/;"	e	enum:__anon3	file:
L1D_LAT	ooo_core.cpp	53;"	d	file:
LACKS_ERRNO_H	g_heap/dlmalloc.h.c	563;"	d	file:
LACKS_FCNTL_H	g_heap/dlmalloc.h.c	548;"	d	file:
LACKS_STRINGS_H	g_heap/dlmalloc.h.c	561;"	d	file:
LACKS_STRING_H	g_heap/dlmalloc.h.c	560;"	d	file:
LACKS_SYS_MMAN_H	g_heap/dlmalloc.h.c	559;"	d	file:
LACKS_SYS_PARAM_H	g_heap/dlmalloc.h.c	558;"	d	file:
LACKS_SYS_TYPES_H	g_heap/dlmalloc.h.c	562;"	d	file:
LACKS_UNISTD_H	g_heap/dlmalloc.h.c	557;"	d	file:
LEFT	barrier.h	/^        enum State {OFFLINE, WAITING, RUNNING, LEFT};$/;"	e	enum:Barrier::State
LFUInfo	repl_policies.h	/^        struct LFUInfo {$/;"	s	class:LFUReplPolicy
LFUReplPolicy	repl_policies.h	/^        explicit LFUReplPolicy(uint32_t _numLines) : timestamp(1), bestCandidate(-1), numLines(_numLines) {$/;"	f	class:LFUReplPolicy
LFUReplPolicy	repl_policies.h	/^class LFUReplPolicy : public LegacyReplPolicy {$/;"	c
LIBCONFIG_VERSION	config.cpp	37;"	d	file:
LIBCONFIG_VERSION	config.cpp	39;"	d	file:
LOCKS_H_	locks.h	29;"	d
LOG_Cache	log.h	/^    LOG_Cache,$/;"	e	enum:__anon1
LOG_Config	log.h	/^    LOG_Config,$/;"	e	enum:__anon1
LOG_FSVirt	log.h	/^    LOG_FSVirt,$/;"	e	enum:__anon1
LOG_H_	log.h	29;"	d
LOG_Harness	log.h	/^    LOG_Harness,$/;"	e	enum:__anon1
LOG_Mem	log.h	/^    LOG_Mem,$/;"	e	enum:__anon1
LOG_Process	log.h	/^    LOG_Process,$/;"	e	enum:__anon1
LOG_Sched	log.h	/^    LOG_Sched,$/;"	e	enum:__anon1
LOG_TimeVirt	log.h	/^    LOG_TimeVirt,$/;"	e	enum:__anon1
LRUReplPolicy	repl_policies.h	/^        explicit LRUReplPolicy(uint32_t _numLines) : timestamp(1), numLines(_numLines) {$/;"	f	class:LRUReplPolicy
LRUReplPolicy	repl_policies.h	/^class LRUReplPolicy : public ReplPolicy {$/;"	c
LambdaStat	stats.h	/^        explicit LambdaStat(F _f) : f(_f) {} \/\/copy the lambda$/;"	f	class:LambdaStat
LambdaStat	stats.h	/^class LambdaStat : public ScalarStat {$/;"	c
LambdaVectorStat	stats.h	/^        LambdaVectorStat(F _f, uint32_t _s) : VectorStat(), f(_f), s(_s) {}$/;"	f	class:LambdaVectorStat
LambdaVectorStat	stats.h	/^class LambdaVectorStat : public VectorStat {$/;"	c
LatencySimulate	detailed_mem.cpp	/^uint64_t MemChannelBase::LatencySimulate(Address lineAddr, uint64_t arrivalCycle, uint64_t lastPhaseCycle, MemAccessType type) {$/;"	f	class:MemChannelBase
LatencySimulate	detailed_mem.cpp	/^uint64_t MemControllerBase::LatencySimulate(Address lineAddr, uint64_t sysCycle, MemAccessType type) {$/;"	f	class:MemControllerBase
LaunchProcess	zsim_harness.cpp	/^void LaunchProcess(uint32_t procIdx) {$/;"	f
LegacyReplPolicy	repl_policies.h	/^class LegacyReplPolicy : public virtual ReplPolicy {$/;"	c
LibInfo	debug.h	/^struct LibInfo {$/;"	s
LineInfo	part_repl_policies.h	/^        struct LineInfo {$/;"	s	class:VantageReplPolicy
LoadAndRecordFunc	timing_core.cpp	/^void TimingCore::LoadAndRecordFunc(THREADID tid, ADDRINT addr) {$/;"	f	class:TimingCore
LoadConfig	detailed_mem_params.cpp	/^void MemParam::LoadConfig(g_string _cfgFile, uint32_t _cacheLineSize)$/;"	f	class:MemParam
LoadConfigMain	detailed_mem_params.cpp	/^void MemParam::LoadConfigMain(Config &cfg, uint32_t _cacheLineSize)$/;"	f	class:MemParam
LoadFunc	null_core.cpp	/^void NullCore::LoadFunc(THREADID tid, ADDRINT addr) {}$/;"	f	class:NullCore
LoadFunc	ooo_core.cpp	/^void OOOCore::LoadFunc(THREADID tid, ADDRINT addr) {static_cast<OOOCore*>(cores[tid])->load(addr);}$/;"	f	class:OOOCore
LoadFunc	simple_core.cpp	/^void SimpleCore::LoadFunc(THREADID tid, ADDRINT addr) {$/;"	f	class:SimpleCore
LoadPower	detailed_mem_params.cpp	/^void MemParam::LoadPower(Config &cfg)$/;"	f	class:MemParam
LoadTiming	detailed_mem_params.cpp	/^void MemParam::LoadTiming(Config &cfg)$/;"	f	class:MemParam
LogType	log.h	/^} LogType;$/;"	t	typeref:enum:__anon1
LookaheadPartitioner	lookahead.cpp	/^LookaheadPartitioner::LookaheadPartitioner(PartReplPolicy* _repl, uint32_t _numPartitions, uint32_t _buckets,$/;"	f	class:LookaheadPartitioner
LookaheadPartitioner	partitioner.h	/^class LookaheadPartitioner : public Partitioner {$/;"	c
M	memory_hierarchy.h	/^    M  \/\/ exclusive and dirty$/;"	e	enum:__anon10
M	mtrand.h	/^        enum { M = 397 };  \/\/ period parameter$/;"	e	enum:MTRand::__anon7
MALLINFO_FIELD_TYPE	g_heap/dlmalloc.h.c	708;"	d	file:
MALLOC_ALIGNMENT	g_heap/dlmalloc.h.c	581;"	d	file:
MALLOC_ALIGNMENT	g_heap/dlmalloc.h.c	612;"	d	file:
MALLOC_FAILURE_ACTION	g_heap/dlmalloc.h.c	565;"	d	file:
MALLOC_FAILURE_ACTION	g_heap/dlmalloc.h.c	653;"	d	file:
MAP_ANONYMOUS	g_heap/dlmalloc.h.c	1535;"	d	file:
MAX	bithacks.h	39;"	d
MAX	bithacks.h	41;"	d
MAX_BBLS	decoder.cpp	1250;"	d	file:
MAX_CACHE_CHILDREN	constants.h	35;"	d
MAX_CHILDREN	zsim_harness.cpp	72;"	d	file:
MAX_CLOCK_DOMAINS	constants.h	39;"	d
MAX_INSTR_LOADS	decoder.h	85;"	d
MAX_INSTR_REG_READS	decoder.h	86;"	d
MAX_INSTR_REG_WRITES	decoder.h	87;"	d
MAX_INSTR_STORES	decoder.h	88;"	d
MAX_IPC	constants.h	44;"	d
MAX_PORT_DOMAINS	constants.h	40;"	d
MAX_REGISTERS	decoder.h	98;"	d
MAX_RELEASE_CHECK_RATE	g_heap/dlmalloc.h.c	693;"	d	file:
MAX_RELEASE_CHECK_RATE	g_heap/dlmalloc.h.c	695;"	d	file:
MAX_REQUEST	g_heap/dlmalloc.h.c	2187;"	d	file:
MAX_SIZE_T	g_heap/dlmalloc.h.c	597;"	d	file:
MAX_SMALL_REQUEST	g_heap/dlmalloc.h.c	2534;"	d	file:
MAX_SMALL_SIZE	g_heap/dlmalloc.h.c	2533;"	d	file:
MAX_SYSCALLS	virt/virt.cpp	34;"	d	file:
MAX_THREADS	constants.h	32;"	d
MAX_TIMEOUTS	barrier.h	55;"	d
MAX_UOPS_PER_INSTR	decoder.h	90;"	d
MAX_UOP_DST_REGS	decoder.h	40;"	d
MAX_UOP_SRC_REGS	decoder.h	39;"	d
MCHUNK_SIZE	g_heap/dlmalloc.h.c	2163;"	d	file:
MD1Memory	mem_ctrls.cpp	/^MD1Memory::MD1Memory(uint32_t requestSize, uint32_t megacyclesPerSecond, uint32_t megabytesPerSecond, uint32_t _zeroLoadLatency, g_string& _name)$/;"	f	class:MD1Memory
MD1Memory	mem_ctrls.h	/^class MD1Memory : public MemObject {$/;"	c
MEMORY_HIERARCHY_H_	memory_hierarchy.h	27;"	d
MEM_CTRLS_H_	mem_ctrls.h	27;"	d
MESIBottomCC	coherence_ctrls.h	/^        MESIBottomCC(uint32_t _numLines, uint32_t _selfId, bool _nonInclusiveHack) : numLines(_numLines), selfId(_selfId), nonInclusiveHack(_nonInclusiveHack) {$/;"	f	class:MESIBottomCC
MESIBottomCC	coherence_ctrls.h	/^class MESIBottomCC : public GlobAlloc {$/;"	c
MESICC	coherence_ctrls.h	/^        MESICC(uint32_t _numLines, bool _nonInclusiveHack, g_string& _name) : tcc(NULL), bcc(NULL),$/;"	f	class:MESICC
MESICC	coherence_ctrls.h	/^class MESICC : public CC {$/;"	c
MESIState	memory_hierarchy.h	/^} MESIState;$/;"	t	typeref:enum:__anon10
MESIStateName	memory_hierarchy.cpp	/^const char* MESIStateName(MESIState s) {$/;"	f
MESITerminalCC	coherence_ctrls.h	/^        MESITerminalCC(uint32_t _numLines, const g_string& _name) : bcc(NULL), numLines(_numLines), name(_name) {}$/;"	f	class:MESITerminalCC
MESITerminalCC	coherence_ctrls.h	/^class MESITerminalCC : public CC {$/;"	c
MESITopCC	coherence_ctrls.h	/^        MESITopCC(uint32_t _numLines, bool _nonInclusiveHack) : numLines(_numLines), nonInclusiveHack(_nonInclusiveHack) {$/;"	f	class:MESITopCC
MESITopCC	coherence_ctrls.h	/^class MESITopCC : public GlobAlloc {$/;"	c
MFAIL	g_heap/dlmalloc.h.c	1526;"	d	file:
MIN	bithacks.h	44;"	d
MIN	bithacks.h	46;"	d
MIN_CHUNK_SIZE	g_heap/dlmalloc.h.c	2177;"	d	file:
MIN_LARGE_SIZE	g_heap/dlmalloc.h.c	2532;"	d	file:
MIN_REQUEST	g_heap/dlmalloc.h.c	2188;"	d	file:
MIN_SMALL_INDEX	g_heap/dlmalloc.h.c	2776;"	d	file:
MLOCK_T	g_heap/dlmalloc.h.c	1744;"	d	file:
MLOCK_T	g_heap/dlmalloc.h.c	1846;"	d	file:
MLOCK_T	g_heap/dlmalloc.h.c	1912;"	d	file:
MLOCK_T	g_heap/dlmalloc.h.c	1944;"	d	file:
MMAP	g_heap/dlmalloc.h.c	1638;"	d	file:
MMAP_CHUNK_OVERHEAD	g_heap/dlmalloc.h.c	2172;"	d	file:
MMAP_CLEARS	g_heap/dlmalloc.h.c	568;"	d	file:
MMAP_CLEARS	g_heap/dlmalloc.h.c	570;"	d	file:
MMAP_CLEARS	g_heap/dlmalloc.h.c	643;"	d	file:
MMAP_DEFAULT	g_heap/dlmalloc.h.c	1539;"	d	file:
MMAP_DEFAULT	g_heap/dlmalloc.h.c	1547;"	d	file:
MMAP_DEFAULT	g_heap/dlmalloc.h.c	1588;"	d	file:
MMAP_FLAGS	g_heap/dlmalloc.h.c	1538;"	d	file:
MMAP_FLAGS	g_heap/dlmalloc.h.c	1545;"	d	file:
MMAP_FOOT_PAD	g_heap/dlmalloc.h.c	2174;"	d	file:
MMAP_PROT	g_heap/dlmalloc.h.c	1533;"	d	file:
MORECORE_CONTIGUOUS	g_heap/dlmalloc.h.c	663;"	d	file:
MORECORE_CONTIGUOUS	g_heap/dlmalloc.h.c	667;"	d	file:
MORECORE_DEFAULT	g_heap/dlmalloc.h.c	665;"	d	file:
MREMAP_DEFAULT	g_heap/dlmalloc.h.c	1596;"	d	file:
MSPACES	g_heap/dlmalloc.h.c	606;"	d	file:
MSPACES	g_heap/dlmalloc.h.c	608;"	d	file:
MTRAND_H_	mtrand.h	84;"	d
MTRand	mtrand.h	/^class MTRand : public GlobAlloc {$/;"	c
MTRand	mtrand.h	/^inline MTRand::MTRand() { seed(); }$/;"	f	class:MTRand
MTRand	mtrand.h	/^inline MTRand::MTRand(const MTRand& o) {$/;"	f	class:MTRand
MTRand	mtrand.h	/^inline MTRand::MTRand(const uint64_t oneSeed) { seed(oneSeed); }$/;"	f	class:MTRand
MTRand	mtrand.h	/^inline MTRand::MTRand(uint64_t *const bigSeed, const uint64_t seedLength) {$/;"	f	class:MTRand
MUNMAP	g_heap/dlmalloc.h.c	1639;"	d	file:
MUNMAP_DEFAULT	g_heap/dlmalloc.h.c	1532;"	d	file:
MUNMAP_DEFAULT	g_heap/dlmalloc.h.c	1589;"	d	file:
M_GRANULARITY	g_heap/dlmalloc.h.c	722;"	d	file:
M_MMAP_THRESHOLD	g_heap/dlmalloc.h.c	723;"	d	file:
M_TRIM_THRESHOLD	g_heap/dlmalloc.h.c	721;"	d	file:
MakeConstraints	detailed_mem_params.cpp	/^void MemParam::MakeConstraints(void)$/;"	f	class:MemParam
MemAccessEventBase	detailed_mem.h	/^        MemAccessEventBase(MemControllerBase* _dram, MemAccessType _type, Address _addr, int32_t domain, uint32_t preDelay, uint32_t postDelay)$/;"	f	class:MemAccessEventBase
MemAccessEventBase	detailed_mem.h	/^class MemAccessEventBase : public TimingEvent {$/;"	c
MemAccessType	detailed_mem.h	/^enum MemAccessType { READ, WRITE, NUM_ACCESS_TYPES};$/;"	g
MemChannelBase	detailed_mem.cpp	/^MemChannelBase::MemChannelBase(uint32_t _myId, MemParam *_mParam) {$/;"	f	class:MemChannelBase
MemChannelBase	detailed_mem.h	/^class MemChannelBase : public GlobAlloc {$/;"	c
MemControllerBase	detailed_mem.cpp	/^MemControllerBase::MemControllerBase(g_string _memCfg, uint32_t _cacheLineSize, uint32_t _sysFreqMHz, uint32_t _domain, g_string& _name) {$/;"	f	class:MemControllerBase
MemControllerBase	detailed_mem.h	/^class MemControllerBase : public MemObject {$/;"	c
MemObject	memory_hierarchy.h	/^class MemObject : public GlobAlloc {$/;"	c
MemParam	detailed_mem_params.cpp	/^MemParam::MemParam()$/;"	f	class:MemParam
MemParam	detailed_mem_params.h	/^class MemParam : public GlobAlloc{$/;"	c
MemRankBase	detailed_mem.cpp	/^MemRankBase::MemRankBase(uint32_t _myId, uint32_t _parentId, uint32_t _bankCount) {$/;"	f	class:MemRankBase
MemRankBase	detailed_mem.h	/^class MemRankBase : public GlobAlloc {$/;"	c
MemReq	memory_hierarchy.h	/^struct MemReq {$/;"	s
MemSchedQueueElem	detailed_mem.h	/^        typedef std::pair<MemAccessEventBase*, Address> MemSchedQueueElem;$/;"	t	class:MemSchedulerBase
MemSchedulerBase	detailed_mem.h	/^        MemSchedulerBase(uint32_t id, MemParam* mParam, MemChannelBase* mChnl)$/;"	f	class:MemSchedulerBase
MemSchedulerBase	detailed_mem.h	/^class MemSchedulerBase : public GlobAlloc {$/;"	c
MemSchedulerDefault	detailed_mem.cpp	/^MemSchedulerDefault::MemSchedulerDefault(uint32_t id, MemParam* mParam, MemChannelBase* mChnl)$/;"	f	class:MemSchedulerDefault
MemSchedulerDefault	detailed_mem.h	/^class MemSchedulerDefault : public MemSchedulerBase {$/;"	c
MissResponseEvent	timing_cache.cpp	/^        MissResponseEvent(TimingCache* _cache, MissStartEvent* _mse, int32_t domain) : TimingEvent(0, 0, domain), cache(_cache), mse(_mse) {}$/;"	f	class:MissResponseEvent
MissResponseEvent	timing_cache.cpp	/^class MissResponseEvent : public TimingEvent {$/;"	c	file:
MissStartEvent	timing_cache.cpp	/^        MissStartEvent(TimingCache* _cache,  uint32_t postDelay, int32_t domain) : TimingEvent(0, postDelay, domain), cache(_cache) {}$/;"	f	class:MissStartEvent
MissStartEvent	timing_cache.cpp	/^class MissStartEvent : public TimingEvent {$/;"	c	file:
MissWritebackEvent	timing_cache.cpp	/^        MissWritebackEvent(TimingCache* _cache,  MissStartEvent* _mse, uint32_t postDelay, int32_t domain) : TimingEvent(0, postDelay, domain), cache(_cache), mse(_mse) {}$/;"	f	class:MissWritebackEvent
MissWritebackEvent	timing_cache.cpp	/^class MissWritebackEvent : public TimingEvent {$/;"	c	file:
N	mtrand.h	/^        enum { N = 624 };       \/\/ length of state vector$/;"	e	enum:MTRand::__anon5
NEED_GLOBAL_LOCK_INIT	g_heap/dlmalloc.h.c	1950;"	d	file:
NETWORK_H_	network.h	27;"	d
NOEXCL	memory_hierarchy.h	/^        NOEXCL        = (1<<2), \/\/Do not give back E on a GETS request (turns MESI protocol into MSI for this line). Used on e.g., ifetches and NUCA.$/;"	e	enum:MemReq::Flag
NOINLINE	g_heap/dlmalloc.h.c	787;"	d	file:
NOINLINE	g_heap/dlmalloc.h.c	789;"	d	file:
NOINLINE	g_heap/dlmalloc.h.c	791;"	d	file:
NONINCLWB	memory_hierarchy.h	/^        NONINCLWB     = (1<<3), \/\/This is a non-inclusive writeback. Do not assume that the line was in the lower level. Used on NUCA (BankDir).$/;"	e	enum:MemReq::Flag
NOPBasicBlock	zsim.cpp	/^VOID NOPBasicBlock(THREADID tid, ADDRINT bblAddr, BblInfo* bblInfo) {}$/;"	f
NOPLoadStoreSingle	zsim.cpp	/^VOID NOPLoadStoreSingle(THREADID tid, ADDRINT addr) {}$/;"	f
NOPPredLoadStoreSingle	zsim.cpp	/^VOID NOPPredLoadStoreSingle(THREADID tid, ADDRINT addr, BOOL pred) {}$/;"	f
NOPRecordBranch	zsim.cpp	/^VOID NOPRecordBranch(THREADID tid, ADDRINT addr, BOOL taken, ADDRINT takenNpc, ADDRINT notTakenNpc) {}$/;"	f
NO_MALLINFO	g_heap/dlmalloc.h.c	705;"	d	file:
NO_SEGMENT_TRAVERSAL	g_heap/dlmalloc.h.c	711;"	d	file:
NRUReplPolicy	repl_policies.h	/^        NRUReplPolicy(uint32_t _numLines, uint32_t _numCands) :numLines(_numLines), numCands(_numCands), youngLines(0), candIdx(0) {$/;"	f	class:NRUReplPolicy
NRUReplPolicy	repl_policies.h	/^class NRUReplPolicy : public LegacyReplPolicy {$/;"	c
NSMALLBINS	g_heap/dlmalloc.h.c	2527;"	d	file:
NSPS	virt/time_conv.h	35;"	d
NTREEBINS	g_heap/dlmalloc.h.c	2528;"	d	file:
NULL_CORE_H_	null_core.h	27;"	d
NULL_THREAD	g_heap/dlmalloc.h.c	1746;"	d	file:
NUMBINS	ddr_mem.h	/^        static const uint32_t BINSIZE = 10, NUMBINS = 100;$/;"	m	class:DDRMemory
NUM_ACCESS_TYPES	detailed_mem.h	/^enum MemAccessType { READ, WRITE, NUM_ACCESS_TYPES};$/;"	e	enum:MemAccessType
Network	network.cpp	/^Network::Network(const char* filename) {$/;"	f	class:Network
Network	network.h	/^class Network {$/;"	c
Node	ddr_mem.h	/^        struct Node : InListNode<Node> {$/;"	s	class:RequestQueue
Node	utility_monitor.h	/^        struct Node {$/;"	s	class:UMon
NullCore	null_core.cpp	/^NullCore::NullCore(g_string& _name) : Core(_name), instrs(0), curCycle(0), phaseEndCycle(0) {}$/;"	f	class:NullCore
NullCore	null_core.h	/^class NullCore : public Core {$/;"	c
NullPatch	virt/virt.cpp	/^PostPatchFn NullPatch(PrePatchArgs) {$/;"	f
NullPostPatch	virt/virt.cpp	/^const PostPatchFn NullPostPatch = [](PostPatchArgs) {return PPA_NOTHING;};$/;"	v
OFFLINE	barrier.h	/^        enum State {OFFLINE, WAITING, RUNNING, LEFT};$/;"	e	enum:Barrier::State
OK	zsim_harness.cpp	/^    OK,$/;"	e	enum:__anon3	file:
ONLY_MSPACES	g_heap/dlmalloc.h.c	28;"	d	file:
ONLY_MSPACES	g_heap/dlmalloc.h.c	600;"	d	file:
ONLY_MSPACES	g_heap/dlmalloc.h.c	602;"	d	file:
OOOCore	ooo_core.cpp	/^OOOCore::OOOCore(FilterCache* _l1i, FilterCache* _l1d, g_string& _name) : Core(_name), l1i(_l1i), l1d(_l1d), cRec(0, _name) {$/;"	f	class:OOOCore
OOOCore	ooo_core.h	/^class OOOCore : public Core {$/;"	c
OOOCoreRecorder	ooo_core_recorder.cpp	/^OOOCoreRecorder::OOOCoreRecorder(uint32_t _domain, g_string& _name)$/;"	f	class:OOOCoreRecorder
OOOCoreRecorder	ooo_core_recorder.h	/^class OOOCoreRecorder {$/;"	c
OOODispatchEvent	ooo_core_recorder.cpp	/^        OOODispatchEvent(uint64_t preDelay, uint64_t _zllStartCycle, int32_t domain = -1) : TimingEvent(preDelay, 0, domain), zllStartCycle(_zllStartCycle) {}$/;"	f	class:OOODispatchEvent
OOODispatchEvent	ooo_core_recorder.cpp	/^class OOODispatchEvent : public TimingEvent {$/;"	c	file:
OOOIssueEvent	ooo_core_recorder.cpp	/^        OOOIssueEvent(uint32_t preDelay, uint64_t _zllStartCycle, OOOCoreRecorder* _cRec, int32_t domain = -1) : TimingEvent(preDelay, 0, domain), zllStartCycle(_zllStartCycle), cRec(_cRec) {}$/;"	f	class:OOOIssueEvent
OOOIssueEvent	ooo_core_recorder.cpp	/^class OOOIssueEvent : public TimingEvent {$/;"	c	file:
OOORespEvent	ooo_core_recorder.cpp	/^        OOORespEvent(uint64_t preDelay, uint64_t _zllStartCycle, OOOCoreRecorder* _cRec, int32_t domain = -1) : TimingEvent(preDelay, 0, domain), zllStartCycle(_zllStartCycle), startCycle(0), cRec(_cRec) {}$/;"	f	class:OOORespEvent
OOORespEvent	ooo_core_recorder.cpp	/^class OOORespEvent : public TimingEvent {$/;"	c	file:
OOO_CORE_H_	ooo_core.h	27;"	d
OOO_CORE_RECORDER_H_	ooo_core_recorder.h	27;"	d
OUT	scheduler.h	/^            OUT, \/\/in leave() this phase, can rejoin immediately$/;"	e	enum:Scheduler::ThreadState
PAD	pad.h	37;"	d
PAD_CONCAT	pad.h	35;"	d
PAD_H_	pad.h	27;"	d
PAD_SZ	pad.h	40;"	d
PANIC_EXIT_CODE	log.h	45;"	d
PARTITIONER_H_	partitioner.h	27;"	d
PARTITION_MAPPER_H_	partition_mapper.h	27;"	d
PART_REPL_POLICIES_H_	part_repl_policies.h	27;"	d
PF	virt/virt.cpp	53;"	d	file:
PF	virt/virt.cpp	55;"	d	file:
PF	virt/virt.cpp	68;"	d	file:
PF	virt/virt.cpp	70;"	d	file:
PHASE_SLAB_ALLOC_H_	phase_slab_alloc.h	27;"	d
PINUSE_BIT	g_heap/dlmalloc.h.c	2209;"	d	file:
PIN_CMD_H_	pin_cmd.h	27;"	d
PORTS_015	decoder.cpp	54;"	d	file:
PORT_0	decoder.cpp	47;"	d	file:
PORT_1	decoder.cpp	48;"	d	file:
PORT_2	decoder.cpp	49;"	d	file:
PORT_3	decoder.cpp	50;"	d	file:
PORT_4	decoder.cpp	51;"	d	file:
PORT_5	decoder.cpp	52;"	d	file:
POSTACTION	g_heap/dlmalloc.h.c	2694;"	d	file:
POSTACTION	g_heap/dlmalloc.h.c	2702;"	d	file:
POST_MORTEM	contention_sim.cpp	41;"	d	file:
PPA_NOTHING	virt/virt.h	/^    PPA_NOTHING,$/;"	e	enum:PostPatchAction
PPA_USE_JOIN_PTRS	virt/virt.h	/^    PPA_USE_JOIN_PTRS,$/;"	e	enum:PostPatchAction
PPA_USE_NOP_PTRS	virt/virt.h	/^    PPA_USE_NOP_PTRS,$/;"	e	enum:PostPatchAction
PQBlock	prio_queue.h	/^        PQBlock() {$/;"	f	struct:PrioQueue::PQBlock
PQBlock	prio_queue.h	/^    struct PQBlock {$/;"	s	class:PrioQueue
PQ_BLOCKS	contention_sim.h	50;"	d
PREACTION	g_heap/dlmalloc.h.c	2693;"	d	file:
PREACTION	g_heap/dlmalloc.h.c	2698;"	d	file:
PREFETCH	memory_hierarchy.h	/^        PREFETCH      = (1<<5), \/\/Prefetch GETS access. Only set at level where prefetch is issued; handled early in MESICC$/;"	e	enum:MemReq::Flag
PREFETCHER_H_	prefetcher.h	27;"	d
PRIO_QUEUE_H_	prio_queue.h	27;"	d
PROCEED_ON_ERROR	g_heap/dlmalloc.h.c	624;"	d	file:
PROCESS_STATS_H_	process_stats.h	27;"	d
PROCESS_TREE_H_	process_tree.h	27;"	d
PROC_EXITED	zsim.h	/^    PROC_EXITED = 1,$/;"	e	enum:ProcExitStatus
PROC_RESTARTME	zsim.h	/^    PROC_RESTARTME  = 2$/;"	e	enum:ProcExitStatus
PROC_RUNNING	zsim.h	/^    PROC_RUNNING = 0,$/;"	e	enum:ProcExitStatus
PROFILE_CROSSINGS	contention_sim.h	43;"	d
PROFILE_STATS_H_	profile_stats.h	27;"	d
PROF_BOUND	zsim.h	/^    PROF_BOUND = 1,$/;"	e	enum:ProfileStates
PROF_FF	zsim.h	/^    PROF_FF = 3,$/;"	e	enum:ProfileStates
PROF_INIT	zsim.h	/^    PROF_INIT = 0,$/;"	e	enum:ProfileStates
PROF_WEAVE	zsim.h	/^    PROF_WEAVE = 2,$/;"	e	enum:ProfileStates
PS_DONE	zsim_harness.cpp	/^    PS_DONE,$/;"	e	enum:__anon4	file:
PS_INVALID	zsim_harness.cpp	/^    PS_INVALID,$/;"	e	enum:__anon4	file:
PS_RUNNING	zsim_harness.cpp	/^    PS_RUNNING,$/;"	e	enum:__anon4	file:
PTHREAD_MUTEX_RECURSIVE	g_heap/dlmalloc.h.c	1928;"	d	file:
PUTS	memory_hierarchy.h	/^    PUTS, \/\/ clean writeback (lower cache is evicting this line, line was not modified)$/;"	e	enum:__anon8
PUTX	memory_hierarchy.h	/^    PUTX  \/\/ dirty writeback (lower cache is evicting this line, line was modified)$/;"	e	enum:__anon8
PUTX_KEEPEXCL	memory_hierarchy.h	/^        PUTX_KEEPEXCL = (1<<4), \/\/Non-relinquishing PUTX. On a PUTX, maintain the requestor's E state instead of removing the sharer (i.e., this is a pure writeback)$/;"	e	enum:MemReq::Flag
ParseList	config.cpp	/^std::vector<T> ParseList(const std::string& listStr) {$/;"	f
ParseList	config.h	/^template <typename T> std::vector<T> ParseList(const std::string& listStr, uint32_t maxSize, uint32_t fillValue) {$/;"	f
ParseMask	config.cpp	/^std::vector<bool> ParseMask(const std::string& maskStr, uint32_t maskSize) {$/;"	f
PartInfo	part_repl_policies.h	/^struct PartInfo {$/;"	s
PartMapper	partition_mapper.h	/^class PartMapper : public GlobAlloc {$/;"	c
PartReplPolicy	part_repl_policies.h	/^        PartReplPolicy(PartitionMonitor* _monitor, PartMapper* _mapper) : monitor(_monitor), mapper(_mapper) {}$/;"	f	class:PartReplPolicy
PartReplPolicy	part_repl_policies.h	/^class PartReplPolicy : public virtual ReplPolicy {$/;"	c
PartitionEvent	partitioner.h	/^                PartitionEvent(Partitioner* _part, uint64_t _period) : Event(_period), part(_part) {}$/;"	f	class:Partitioner::PartitionEvent
PartitionEvent	partitioner.h	/^        class PartitionEvent: public Event {$/;"	c	class:Partitioner
PartitionMonitor	partitioner.h	/^        explicit PartitionMonitor(uint32_t _buckets) : buckets(_buckets) {}$/;"	f	class:PartitionMonitor
PartitionMonitor	partitioner.h	/^class PartitionMonitor : public GlobAlloc {$/;"	c
Partitioner	partitioner.h	/^        Partitioner(uint32_t _minAlloc, double _allocPortion, bool* _forbidden)$/;"	f	class:Partitioner
Partitioner	partitioner.h	/^class Partitioner : public GlobAlloc {$/;"	c
PatchBind	virt/ports.cpp	/^PostPatchFn PatchBind(PrePatchArgs args) {$/;"	f
PatchClockGettime	virt/time.cpp	/^PostPatchFn PatchClockGettime(PrePatchArgs args) {$/;"	f
PatchConnect	virt/ports.cpp	/^PostPatchFn PatchConnect(PrePatchArgs args) {$/;"	f
PatchGetcpu	virt/cpu.cpp	/^PostPatchFn PatchGetcpu(PrePatchArgs args) {$/;"	f
PatchGetsockname	virt/ports.cpp	/^PostPatchFn PatchGetsockname(PrePatchArgs args) {$/;"	f
PatchGettimeofday	virt/time.cpp	/^PostPatchFn PatchGettimeofday(PrePatchArgs args) {$/;"	f
PatchNanosleep	virt/time.cpp	/^PostPatchFn PatchNanosleep(PrePatchArgs args) {$/;"	f
PatchOpen	virt/fs.cpp	/^PostPatchFn PatchOpen(PrePatchArgs args) {$/;"	f
PatchSchedGetaffinity	virt/cpu.cpp	/^PostPatchFn PatchSchedGetaffinity(PrePatchArgs args) {$/;"	f
PatchSchedSetaffinity	virt/cpu.cpp	/^PostPatchFn PatchSchedSetaffinity(PrePatchArgs args) {$/;"	f
PatchTime	virt/time.cpp	/^PostPatchFn PatchTime(PrePatchArgs args) {$/;"	f
PatchTimeoutSyscall	virt/timeout.cpp	/^PostPatchFn PatchTimeoutSyscall(PrePatchArgs args) {$/;"	f
PeriodicUpdatePower	detailed_mem.cpp	/^void MemChannelBase::PeriodicUpdatePower(uint64_t phaseCycle, uint64_t lastPhaseCycle) {$/;"	f	class:MemChannelBase
PhaseSlabAlloc	phase_slab_alloc.h	/^        PhaseSlabAlloc() {$/;"	f	class:PhaseSlabAlloc
PhaseSlabAlloc	phase_slab_alloc.h	/^class PhaseSlabAlloc {$/;"	c
PinCmd	pin_cmd.cpp	/^PinCmd::PinCmd(Config* conf, const char* configFile, const char* outputDir, uint64_t shmid) {$/;"	f	class:PinCmd
PinCmd	pin_cmd.h	/^class PinCmd : public GlobAlloc {$/;"	c
PopulateLevel	process_tree.cpp	/^static void PopulateLevel(Config& config, const std::string& prefix, std::vector<ProcessTreeNode*>& globProcVector, ProcessTreeNode* parent, uint32_t& procIdx, uint32_t& groupIdx) {$/;"	f	file:
PortVirtualizer	virt/port_virtualizer.h	/^        PortVirtualizer() {$/;"	f	class:PortVirtualizer
PortVirtualizer	virt/port_virtualizer.h	/^class PortVirtualizer : public GlobAlloc {$/;"	c
PostInitStats	init.cpp	/^static void PostInitStats(bool perProcessDir, Config& config) {$/;"	f	file:
PostPatchAction	virt/virt.h	/^enum PostPatchAction {$/;"	g
PostPatchArgs	virt/common.h	/^struct PostPatchArgs {$/;"	s
PostPatchFn	virt/common.h	/^typedef std::function<PostPatchAction(PostPatchArgs)> PostPatchFn;$/;"	t
PostPatchFutex	virt/timeout.cpp	/^void PostPatchFutex(uint32_t tid, FutexInfo fi, CONTEXT* ctxt, SYSCALL_STANDARD std) {$/;"	f
PostPatchTimeoutSyscall	virt/timeout.cpp	/^static bool PostPatchTimeoutSyscall(uint32_t tid, CONTEXT* ctxt, SYSCALL_STANDARD std, int syscall, ADDRINT prevIp, ADDRINT timeoutArgVal) {$/;"	f	file:
PreInitStats	init.cpp	/^static void PreInitStats() {$/;"	f	file:
PrePatchArgs	virt/common.h	/^struct PrePatchArgs {$/;"	s
PrePatchFn	virt/common.h	/^typedef PostPatchFn (*PrePatchFn)(PrePatchArgs);$/;"	t
PrePatchFutex	virt/timeout.cpp	/^FutexInfo PrePatchFutex(uint32_t tid, CONTEXT* ctxt, SYSCALL_STANDARD std) {$/;"	f
PrePatchTimeoutSyscall	virt/timeout.cpp	/^static bool PrePatchTimeoutSyscall(uint32_t tid, CONTEXT* ctxt, SYSCALL_STANDARD std, int syscall) {$/;"	f	file:
PredLoadAndRecordFunc	timing_core.cpp	/^void TimingCore::PredLoadAndRecordFunc(THREADID tid, ADDRINT addr, BOOL pred) {$/;"	f	class:TimingCore
PredLoadFunc	null_core.cpp	/^void NullCore::PredLoadFunc(THREADID tid, ADDRINT addr, BOOL pred) {}$/;"	f	class:NullCore
PredLoadFunc	ooo_core.cpp	/^void OOOCore::PredLoadFunc(THREADID tid, ADDRINT addr, BOOL pred) {$/;"	f	class:OOOCore
PredLoadFunc	simple_core.cpp	/^void SimpleCore::PredLoadFunc(THREADID tid, ADDRINT addr, BOOL pred) {$/;"	f	class:SimpleCore
PredStoreAndRecordFunc	timing_core.cpp	/^void TimingCore::PredStoreAndRecordFunc(THREADID tid, ADDRINT addr, BOOL pred) {$/;"	f	class:TimingCore
PredStoreFunc	null_core.cpp	/^void NullCore::PredStoreFunc(THREADID tid, ADDRINT addr, BOOL pred) {}$/;"	f	class:NullCore
PredStoreFunc	ooo_core.cpp	/^void OOOCore::PredStoreFunc(THREADID tid, ADDRINT addr, BOOL pred) {$/;"	f	class:OOOCore
PredStoreFunc	simple_core.cpp	/^void SimpleCore::PredStoreFunc(THREADID tid, ADDRINT addr, BOOL pred) {$/;"	f	class:SimpleCore
PrioQueue	prio_queue.h	/^        PrioQueue() {$/;"	f	class:PrioQueue
PrioQueue	prio_queue.h	/^class PrioQueue {$/;"	c
ProcCmdInfo	pin_cmd.h	/^        struct ProcCmdInfo {$/;"	s	class:PinCmd
ProcExitStatus	zsim.h	/^enum ProcExitStatus {$/;"	g
ProcInfo	zsim_harness.cpp	/^struct ProcInfo {$/;"	s	file:
ProcStatus	zsim_harness.cpp	/^} ProcStatus;$/;"	t	typeref:enum:__anon4	file:
ProcessGroupPartMapper	partition_mapper.h	/^        ProcessGroupPartMapper() {}$/;"	f	class:ProcessGroupPartMapper
ProcessGroupPartMapper	partition_mapper.h	/^class ProcessGroupPartMapper : public PartMapper {$/;"	c
ProcessPartMapper	partition_mapper.h	/^        explicit ProcessPartMapper(uint32_t _numProcs) : numProcs(_numProcs) {}$/;"	f	class:ProcessPartMapper
ProcessPartMapper	partition_mapper.h	/^class ProcessPartMapper : public PartMapper {$/;"	c
ProcessStats	process_stats.cpp	/^ProcessStats::ProcessStats(AggregateStat* parentStat) {$/;"	f	class:ProcessStats
ProcessStats	process_stats.h	/^class ProcessStats : public GlobAlloc {$/;"	c
ProcessTreeNode	process_tree.h	/^        ProcessTreeNode(uint32_t _procIdx, uint32_t _groupIdx, bool _inFastForward, bool _inPause, bool _syncedFastForward,$/;"	f	class:ProcessTreeNode
ProcessTreeNode	process_tree.h	/^class ProcessTreeNode : public GlobAlloc {$/;"	c
ProfViolReplPolicy	repl_policies.h	/^        explicit ProfViolReplPolicy(uint32_t nl) : T(nl) {}$/;"	f	class:ProfViolReplPolicy
ProfViolReplPolicy	repl_policies.h	/^class ProfViolReplPolicy : public T {$/;"	c
ProfileStates	zsim.h	/^enum ProfileStates {$/;"	g
ProxyFuncStat	stats.h	/^        ProxyFuncStat() : Stat(), _func(NULL) {}$/;"	f	class:ProxyFuncStat
ProxyFuncStat	stats.h	/^class ProxyFuncStat : public Stat {$/;"	c
ProxyReplPolicy	ideal_arrays.h	/^                explicit ProxyReplPolicy(IdealLRUArray* _a) : a(_a) {}$/;"	f	class:IdealLRUArray::ProxyReplPolicy
ProxyReplPolicy	ideal_arrays.h	/^        class ProxyReplPolicy : public ReplPolicy {$/;"	c	class:IdealLRUArray
ProxyStat	stats.h	/^        ProxyStat() : Stat(), _statPtr(NULL) {}$/;"	f	class:ProxyStat
ProxyStat	stats.h	/^class ProxyStat : public Stat {$/;"	c
QUEUED	ddr_mem.cpp	/^        enum State { IDLE, QUEUED, RUNNING, ANNULLED };$/;"	e	enum:SchedEvent::State	file:
QUEUED	scheduler.h	/^            QUEUED \/\/in the runqueue$/;"	e	enum:Scheduler::ThreadState
QUOTED	debug_harness.cpp	36;"	d	file:
QUOTED	pin_cmd.cpp	35;"	d	file:
QUOTED	virt/syscall_name.cpp	28;"	d	file:
QUOTED	zsim.cpp	997;"	d	file:
QUOTED_	debug_harness.cpp	35;"	d	file:
QUOTED_	pin_cmd.cpp	34;"	d	file:
QUOTED_	virt/syscall_name.cpp	27;"	d	file:
QUOTED_	zsim.cpp	996;"	d	file:
RB_CLOSE	detailed_mem_params.h	/^            RB_CLOSE = 0,$/;"	e	enum:MemParam::eRowBufferPolicy
RB_OPEN	detailed_mem_params.h	/^            RB_OPEN$/;"	e	enum:MemParam::eRowBufferPolicy
RDTSC_H_	rdtsc.h	27;"	d
READ	detailed_mem.h	/^enum MemAccessType { READ, WRITE, NUM_ACCESS_TYPES};$/;"	e	enum:MemAccessType
REG_EXEC_TEMP	decoder.h	96;"	d
REG_LOAD_TEMP	decoder.h	93;"	d
REG_STORE_ADDR_TEMP	decoder.h	95;"	d
REG_STORE_TEMP	decoder.h	94;"	d
RELEASE_LOCK	g_heap/dlmalloc.h.c	1749;"	d	file:
RELEASE_LOCK	g_heap/dlmalloc.h.c	1850;"	d	file:
RELEASE_LOCK	g_heap/dlmalloc.h.c	1916;"	d	file:
RELEASE_LOCK	g_heap/dlmalloc.h.c	1948;"	d	file:
RELEASE_MALLOC_GLOBAL_LOCK	g_heap/dlmalloc.h.c	2002;"	d	file:
RELEASE_MALLOC_GLOBAL_LOCK	g_heap/dlmalloc.h.c	2006;"	d	file:
REPL_POLICIES_H_	repl_policies.h	27;"	d
RF_READS_PER_CYCLE	ooo_core.cpp	56;"	d	file:
RTCHECK	g_heap/dlmalloc.h.c	2985;"	d	file:
RTCHECK	g_heap/dlmalloc.h.c	2987;"	d	file:
RTCHECK	g_heap/dlmalloc.h.c	2990;"	d	file:
RUNNING	barrier.h	/^        enum State {OFFLINE, WAITING, RUNNING, LEFT};$/;"	e	enum:Barrier::State
RUNNING	core_recorder.h	/^            RUNNING, \/\/Scheduled. leave() --> DRAINING$/;"	e	enum:CoreRecorder::__anon12
RUNNING	ddr_mem.cpp	/^        enum State { IDLE, QUEUED, RUNNING, ANNULLED };$/;"	e	enum:SchedEvent::State	file:
RUNNING	ooo_core_recorder.h	/^            RUNNING, \/\/Scheduled. leave() --> DRAINING$/;"	e	enum:OOOCoreRecorder::__anon2
RUNNING	scheduler.h	/^            RUNNING, \/\/has cid assigned, managed by the phase barrier$/;"	e	enum:Scheduler::ThreadState
RandReplPolicy	repl_policies.h	/^        explicit RandReplPolicy(uint32_t _numCands) : numCands(_numCands), rnd(0x23A5F + (uint64_t)this), candIdx(0) {$/;"	f	class:RandReplPolicy
RandReplPolicy	repl_policies.h	/^class RandReplPolicy : public LegacyReplPolicy {$/;"	c
Range	config.cpp	/^    explicit Range(string r)  {$/;"	f	struct:Range
Range	config.cpp	/^struct Range {$/;"	s	file:
Rank	repl_policies.h	/^        struct Rank {$/;"	s	class:LFUReplPolicy
RefreshEvent	ddr_mem.cpp	/^        RefreshEvent(DDRMemory* _mem, uint32_t _refInterval, int32_t domain) :$/;"	f	class:RefreshEvent
RefreshEvent	ddr_mem.cpp	/^class RefreshEvent : public TimingEvent, public GlobAlloc {$/;"	c	file:
ReorderBuffer	ooo_core.h	/^        ReorderBuffer() {$/;"	f	class:ReorderBuffer
ReorderBuffer	ooo_core.h	/^class ReorderBuffer {$/;"	c
ReplAccessEvent	timing_cache.cpp	/^        ReplAccessEvent(TimingCache* _cache, uint32_t _accsLeft, uint32_t preDelay, uint32_t postDelay, int32_t domain) : TimingEvent(preDelay, postDelay, domain), cache(_cache), accsLeft(_accsLeft) {}$/;"	f	class:ReplAccessEvent
ReplAccessEvent	timing_cache.cpp	/^class ReplAccessEvent : public TimingEvent {$/;"	c	file:
ReplPolicy	repl_policies.h	/^        ReplPolicy() : cc(NULL) {}$/;"	f	class:ReplPolicy
ReplPolicy	repl_policies.h	/^class ReplPolicy : public GlobAlloc {$/;"	c
Request	ddr_mem.h	/^        struct Request : InListNode<Request> {$/;"	s	class:DDRMemory
RequestQueue	ddr_mem.h	/^class RequestQueue {$/;"	c
ReturnChannel	detailed_mem.cpp	/^uint64_t MemControllerBase::ReturnChannel(Address addr) {$/;"	f	class:MemControllerBase
S	memory_hierarchy.h	/^    S, \/\/ shared (and clean)$/;"	e	enum:__anon10
SAVE	mtrand.h	/^        enum { SAVE = N + 1 };  \/\/ length of array for save()$/;"	e	enum:MTRand::__anon6
SCHEDULER_H_	scheduler.h	28;"	d
SHA1HashFamily	hash.cpp	/^SHA1HashFamily::SHA1HashFamily(int numFunctions) : numFuncs(numFunctions) {$/;"	f	class:SHA1HashFamily
SHA1HashFamily	hash.cpp	/^SHA1HashFamily::SHA1HashFamily(int numFunctions) {$/;"	f	class:SHA1HashFamily
SHA1HashFamily	hash.h	/^class SHA1HashFamily : public HashFamily {$/;"	c
SIMPLE_CORE_H_	simple_core.h	27;"	d
SIX_SIZE_T_SIZES	g_heap/dlmalloc.h.c	1502;"	d	file:
SIZE_T_BITSIZE	g_heap/dlmalloc.h.c	1492;"	d	file:
SIZE_T_FOUR	g_heap/dlmalloc.h.c	1499;"	d	file:
SIZE_T_ONE	g_heap/dlmalloc.h.c	1497;"	d	file:
SIZE_T_SIZE	g_heap/dlmalloc.h.c	1491;"	d	file:
SIZE_T_TWO	g_heap/dlmalloc.h.c	1498;"	d	file:
SIZE_T_ZERO	g_heap/dlmalloc.h.c	1496;"	d	file:
SLEEPING	scheduler.h	/^            SLEEPING, \/\/inside a patched sleep syscall; no cid assigned, in sleepQueue; it is our responsibility to wake this thread up when its deadline arrives$/;"	e	enum:Scheduler::ThreadState
SMALLBIN_SHIFT	g_heap/dlmalloc.h.c	2529;"	d	file:
SMALLBIN_WIDTH	g_heap/dlmalloc.h.c	2530;"	d	file:
SPINS_PER_YIELD	g_heap/dlmalloc.h.c	1751;"	d	file:
SPINS_PER_YIELD	g_heap/dlmalloc.h.c	1852;"	d	file:
SPIN_LOCKS_AVAILABLE	g_heap/dlmalloc.h.c	591;"	d	file:
SPIN_LOCKS_AVAILABLE	g_heap/dlmalloc.h.c	593;"	d	file:
STARTED	scheduler.h	/^            STARTED, \/\/transient state, thread will do a join immediately after$/;"	e	enum:Scheduler::ThreadState
STATS_FILTER_H_	stats_filter.h	27;"	d
STATS_H_	stats.h	73;"	d
STL_GALLOC_H_	g_std/stl_galloc.h	27;"	d
STRUCT_MALLINFO_DECLARED	g_heap/dlmalloc.h.c	756;"	d	file:
STR_H_	str.h	27;"	d
SType	config.cpp	/^typedef libconfig::Setting::Type SType;$/;"	t	file:
SYS_ALLOC_PADDING	g_heap/dlmalloc.h.c	2635;"	d	file:
SatCounter	prefetcher.h	/^        SatCounter() : count(I) {}$/;"	f	class:SatCounter
SatCounter	prefetcher.h	/^class SatCounter {$/;"	c
SaveBackgroundCycles	detailed_mem.cpp	/^void MemRankBase::SaveBackgroundCycles(void) {$/;"	f	class:MemRankBase
ScalarStat	stats.h	/^        ScalarStat() : Stat() {}$/;"	f	class:ScalarStat
ScalarStat	stats.h	/^class ScalarStat : public Stat {$/;"	c
SchedEvent	ddr_mem.cpp	/^        SchedEvent(DDRMemory* _mem, int32_t domain) : TimingEvent(0, 0, domain), mem(_mem) {$/;"	f	class:SchedEvent
SchedEvent	ddr_mem.cpp	/^class SchedEvent : public TimingEvent, public GlobAlloc {$/;"	c	file:
Scheduler	scheduler.h	/^        Scheduler(void (*_atSyncFunc)(void), uint32_t _parallelThreads, uint32_t _numCores, uint32_t _schedQuantum) :$/;"	f	class:Scheduler
Scheduler	scheduler.h	/^class Scheduler : public GlobAlloc, public Callee {$/;"	c
Section	zsim.cpp	/^struct Section {$/;"	s	file:
SetAccessInRefresh	detailed_mem.h	/^        void SetAccessInRefresh(uint32_t num) { accessInRefresh = num; }$/;"	f	class:MemRankBase
SetActvPowerDownCycle	detailed_mem.h	/^        void SetActvPowerDownCycle(uint64_t cycle) { assert(actvPowerDownCycle <= cycle); actvPowerDownCycle = cycle; }$/;"	f	class:MemRankBase
SetAssocArray	cache_arrays.cpp	/^SetAssocArray::SetAssocArray(uint32_t _numLines, uint32_t _assoc, ReplPolicy* _rp, HashFamily* _hf) : rp(_rp), hf(_hf), numLines(_numLines), assoc(_assoc)  {$/;"	f	class:SetAssocArray
SetAssocArray	cache_arrays.h	/^class SetAssocArray : public CacheArray {$/;"	c
SetAssocCands	cache_arrays.h	/^    inline SetAssocCands(uint32_t _b, uint32_t _e) : b(_b), e(_e) {}$/;"	f	struct:SetAssocCands
SetAssocCands	cache_arrays.h	/^struct SetAssocCands {$/;"	s
SetBankClose	detailed_mem.h	/^        void SetBankClose(uint32_t bank) { bankinfo[bank] = false; }$/;"	f	class:MemRankBase
SetBankOpen	detailed_mem.h	/^        void SetBankOpen(uint32_t bank)  { bankinfo[bank] = true; }$/;"	f	class:MemRankBase
SetFAWCycle	detailed_mem.h	/^        void SetFAWCycle(uint32_t bank, uint64_t cycle) { assert(tFAWCycle[bank] <= cycle); tFAWCycle[bank] = cycle; }$/;"	f	class:MemRankBase
SetFAWCycle	detailed_mem.h	/^        void SetFAWCycle(uint64_t cycle) { assert(tFAWCycle[tFAWIndex] <= cycle); tFAWCycle[tFAWIndex++] = cycle; tFAWIndex %= 4; }$/;"	f	class:MemRankBase
SetIdlePowerDownCycle	detailed_mem.h	/^        void SetIdlePowerDownCycle(uint64_t cycle) { assert(idlePowerDownCycle <= cycle); idlePowerDownCycle = cycle; }$/;"	f	class:MemRankBase
SetIdleStandbyCycle	detailed_mem.h	/^        void SetIdleStandbyCycle(uint64_t cycle) { assert(idleStandbyCycle <= cycle); idleStandbyCycle = cycle; }$/;"	f	class:MemRankBase
SetLastActCycle	detailed_mem.h	/^        void SetLastActCycle(uint32_t bank, uint64_t cycle) { assert(lastActCycle[bank] <= cycle); lastActCycle[bank] = cycle; }$/;"	f	class:MemRankBase
SetLastPreCycle	detailed_mem.h	/^        void SetLastPreCycle(uint32_t bank, uint64_t cycle) { assert(lastPreCycle[bank] <= cycle); lastPreCycle[bank] = cycle; }$/;"	f	class:MemRankBase
SetRefreshNum	detailed_mem.h	/^        void SetRefreshNum(uint32_t num) { assert(refreshNum <= num); refreshNum = num;}$/;"	f	class:MemRankBase
SimEnd	zsim.cpp	/^VOID SimEnd() {$/;"	f
SimInit	init.cpp	/^void SimInit(const char* configFile, const char* outputDir, uint32_t shmid) {$/;"	f
SimThreadData	contention_sim.h	/^        struct SimThreadData {$/;"	s	class:ContentionSim
SimThreadFini	zsim.cpp	/^VOID SimThreadFini(THREADID tid) {$/;"	f
SimThreadStart	zsim.cpp	/^void SimThreadStart(THREADID tid) {$/;"	f
SimThreadTrampoline	contention_sim.cpp	/^void ContentionSim::SimThreadTrampoline(void* arg) {$/;"	f	class:ContentionSim
SimpleCore	simple_core.cpp	/^SimpleCore::SimpleCore(FilterCache* _l1i, FilterCache* _l1d, g_string& _name) : Core(_name), l1i(_l1i), l1d(_l1d), instrs(0), curCycle(0), haltedCycles(0) {$/;"	f	class:SimpleCore
SimpleCore	simple_core.h	/^class SimpleCore : public Core {$/;"	c
SimpleMemory	mem_ctrls.h	/^        SimpleMemory(uint32_t _latency, g_string& _name) : name(_name), latency(_latency) {}$/;"	f	class:SimpleMemory
SimpleMemory	mem_ctrls.h	/^class SimpleMemory : public MemObject {$/;"	c
SkipTimeVirt	virt/time.cpp	/^static bool SkipTimeVirt(PrePatchArgs args) {$/;"	f	file:
SkipTimeoutVirt	virt/timeout.cpp	/^static bool SkipTimeoutVirt(PrePatchArgs args) {$/;"	f	file:
Slab	phase_slab_alloc.h	/^        struct Slab {$/;"	s	class:PhaseSlabAlloc
SlabList	phase_slab_alloc.h	/^                SlabList() : start(NULL), end(NULL) {}$/;"	f	class:PhaseSlabAlloc::SlabList
SlabList	phase_slab_alloc.h	/^        class SlabList {$/;"	c	class:PhaseSlabAlloc
SplitAddrMemory	dramsim_mem_ctrl.h	/^        SplitAddrMemory(const g_vector<MemObject*>& _mems, const char* _name) : mems(_mems), name(_name) {}$/;"	f	class:SplitAddrMemory
SplitAddrMemory	dramsim_mem_ctrl.h	/^class SplitAddrMemory : public MemObject {$/;"	c
Stat	stats.h	/^        Stat() : _name(NULL), _desc(NULL) {}$/;"	f	class:Stat
Stat	stats.h	/^class Stat : public GlobAlloc {$/;"	c
State	barrier.h	/^        enum State {OFFLINE, WAITING, RUNNING, LEFT};$/;"	g	class:Barrier
State	core_recorder.h	/^        } State;$/;"	t	class:CoreRecorder	typeref:enum:CoreRecorder::__anon12
State	ddr_mem.cpp	/^        enum State { IDLE, QUEUED, RUNNING, ANNULLED };$/;"	g	class:SchedEvent	file:
State	ooo_core_recorder.h	/^        } State;$/;"	t	class:OOOCoreRecorder	typeref:enum:OOOCoreRecorder::__anon2
StatsBackend	stats.h	/^        StatsBackend() {}$/;"	f	class:StatsBackend
StatsBackend	stats.h	/^class StatsBackend : public GlobAlloc {$/;"	c
StlGlobAlloc	g_std/stl_galloc.h	/^        StlGlobAlloc() {}$/;"	f	class:StlGlobAlloc
StlGlobAlloc	g_std/stl_galloc.h	/^        StlGlobAlloc(const StlGlobAlloc&) {}$/;"	f	class:StlGlobAlloc
StlGlobAlloc	g_std/stl_galloc.h	/^        template <class U> StlGlobAlloc(const StlGlobAlloc<U>&) {}$/;"	f	class:StlGlobAlloc
StlGlobAlloc	g_std/stl_galloc.h	/^class StlGlobAlloc {$/;"	c
StoreAndRecordFunc	timing_core.cpp	/^void TimingCore::StoreAndRecordFunc(THREADID tid, ADDRINT addr) {$/;"	f	class:TimingCore
StoreFunc	null_core.cpp	/^void NullCore::StoreFunc(THREADID tid, ADDRINT addr) {}$/;"	f	class:NullCore
StoreFunc	ooo_core.cpp	/^void OOOCore::StoreFunc(THREADID tid, ADDRINT addr) {static_cast<OOOCore*>(cores[tid])->store(addr);}$/;"	f	class:OOOCore
StoreFunc	simple_core.cpp	/^void SimpleCore::StoreFunc(THREADID tid, ADDRINT addr) {$/;"	f	class:SimpleCore
Str	str.h	/^template <typename T> std::string Str(T v) {$/;"	f
Str	str.h	/^template <typename T> std::string Str(const std::vector<T>& v) {$/;"	f
StreamPrefetcher	prefetcher.h	/^        explicit StreamPrefetcher(const g_string& _name) : timestamp(0), name(_name) {}$/;"	f	class:StreamPrefetcher
StreamPrefetcher	prefetcher.h	/^class StreamPrefetcher : public BaseCache {$/;"	c
SyncEvent	zsim.cpp	/^        SyncEvent() : Event(0 \/*one-shot*\/) {$/;"	f	class:SyncEvent
SyncEvent	zsim.cpp	/^class SyncEvent: public Event {$/;"	c	file:
SyscallEnter	zsim.cpp	/^VOID SyscallEnter(THREADID tid, CONTEXT *ctxt, SYSCALL_STANDARD std, VOID *v) {$/;"	f
SyscallExit	zsim.cpp	/^VOID SyscallExit(THREADID tid, CONTEXT *ctxt, SYSCALL_STANDARD std, VOID *v) {$/;"	f
TICKET_MASK	locks.h	93;"	d
TICK_EVENT_H_	tick_event.h	27;"	d
TIMEOUT_LENGTH	barrier.h	54;"	d
TIMING_BLOCK_EVENTS	timing_event.h	36;"	d
TIMING_CACHE_H_	timing_cache.h	27;"	d
TIMING_CORE_H_	timing_core.h	27;"	d
TIMING_EVENT_H_	timing_event.h	27;"	d
TOP_FOOT_SIZE	g_heap/dlmalloc.h.c	2679;"	d	file:
TRACE_MSG	ooo_core_recorder.cpp	34;"	d	file:
TREEBIN_SHIFT	g_heap/dlmalloc.h.c	2531;"	d	file:
TRY_LOCK	g_heap/dlmalloc.h.c	1750;"	d	file:
TRY_LOCK	g_heap/dlmalloc.h.c	1851;"	d	file:
TRY_LOCK	g_heap/dlmalloc.h.c	1917;"	d	file:
TRY_LOCK	g_heap/dlmalloc.h.c	1949;"	d	file:
TWO_SIZE_T_SIZES	g_heap/dlmalloc.h.c	1500;"	d	file:
TakeBarrier	zsim.cpp	/^uint32_t TakeBarrier(uint32_t tid, uint32_t cid) {$/;"	f
TerminationStatus	zsim_harness.cpp	/^} TerminationStatus;$/;"	t	typeref:enum:__anon3	file:
TextBackend	stats.h	/^class TextBackend : public StatsBackend {$/;"	c
TextBackend	text_stats.cpp	/^TextBackend::TextBackend(const char* filename, AggregateStat* rootStat) {$/;"	f	class:TextBackend
TextBackendImpl	text_stats.cpp	/^        TextBackendImpl(const char* _filename, AggregateStat* _rootStat) :$/;"	f	class:TextBackendImpl
TextBackendImpl	text_stats.cpp	/^class TextBackendImpl : public GlobAlloc {$/;"	c	file:
ThreadFini	zsim.cpp	/^VOID ThreadFini(THREADID tid, const CONTEXT *ctxt, INT32 flags, VOID *v) {$/;"	f
ThreadInfo	scheduler.h	/^            ThreadInfo(uint32_t _gid, uint32_t _linuxPid, uint32_t _linuxTid, const g_vector<bool>& _mask) :$/;"	f	struct:Scheduler::ThreadInfo
ThreadInfo	scheduler.h	/^        struct ThreadInfo : GlobAlloc, InListNode<ThreadInfo> {$/;"	s	class:Scheduler
ThreadStart	zsim.cpp	/^VOID ThreadStart(THREADID tid, CONTEXT *ctxt, INT32 flags, VOID *v) {$/;"	f
ThreadState	scheduler.h	/^        enum ThreadState {$/;"	g	class:Scheduler
ThreadSyncInfo	barrier.h	/^        struct ThreadSyncInfo {$/;"	s	class:Barrier
TickEvent	tick_event.h	/^        TickEvent(T* _obj, int32_t domain) : TimingEvent(0, 0, domain), obj(_obj), active(false) {$/;"	f	class:TickEvent
TickEvent	tick_event.h	/^class TickEvent : public TimingEvent, public GlobAlloc { \/\/this one should be allocated from glob mem$/;"	c
TickScheduler	detailed_mem.cpp	/^void MemControllerBase::TickScheduler(uint64_t sysCycle) {$/;"	f	class:MemControllerBase
TimeBreakdownStat	profile_stats.h	/^        TimeBreakdownStat() : VectorCounter() {}$/;"	f	class:TimeBreakdownStat
TimeBreakdownStat	profile_stats.h	/^class TimeBreakdownStat : public VectorCounter {$/;"	c
TimingCache	timing_cache.cpp	/^TimingCache::TimingCache(uint32_t _numLines, CC* _cc, CacheArray* _array, ReplPolicy* _rp,$/;"	f	class:TimingCache
TimingCache	timing_cache.h	/^class TimingCache : public Cache {$/;"	c
TimingCore	timing_core.cpp	/^TimingCore::TimingCore(FilterCache* _l1i, FilterCache* _l1d, uint32_t _domain, g_string& _name)$/;"	f	class:TimingCore
TimingCore	timing_core.h	/^class TimingCore : public Core {$/;"	c
TimingCoreEvent	core_recorder.cpp	/^        TimingCoreEvent(uint64_t _delay, uint64_t _origStartCycle, CoreRecorder* _cRec, int32_t domain = -1) : TimingEvent(0, _delay, domain), origStartCycle(_origStartCycle), cRec(_cRec) {}$/;"	f	class:TimingCoreEvent
TimingCoreEvent	core_recorder.cpp	/^class TimingCoreEvent : public TimingEvent {$/;"	c	file:
TimingEvent	timing_event.h	/^        TimingEvent(uint32_t _preDelay, uint32_t _postDelay, int32_t _domain = -1) : next(NULL), state(EV_NONE), cycle(0), minStartCycle(-1L), child(NULL),$/;"	f	class:TimingEvent
TimingEvent	timing_event.h	/^        explicit TimingEvent(int32_t _domain = -1) : next(NULL), state(EV_NONE), minStartCycle(-1L), child(NULL),$/;"	f	class:TimingEvent
TimingEvent	timing_event.h	/^class TimingEvent {$/;"	c
TimingEventBlock	timing_event.h	/^    TimingEventBlock() {$/;"	f	struct:TimingEventBlock
TimingEventBlock	timing_event.h	/^struct TimingEventBlock {$/;"	s
TimingRecord	event_recorder.h	/^struct TimingRecord {$/;"	s
Tokenize	config.cpp	/^void Tokenize(const string& str, vector<string>& tokens, const string& delimiters) {$/;"	f
Trace	zsim.cpp	/^VOID Trace(TRACE trace, VOID *v) {$/;"	f
TreeLRUReplPolicy	repl_policies.h	/^        TreeLRUReplPolicy(uint32_t _numLines, uint32_t _numCands) : LRUReplPolicy<true>(_numLines), numCands(_numCands), candIdx(0) {$/;"	f	class:TreeLRUReplPolicy
TreeLRUReplPolicy	repl_policies.h	/^class TreeLRUReplPolicy : public LRUReplPolicy<true> {$/;"	c
TrueSleep	scheduler.cpp	/^static void TrueSleep(uint32_t usecs) {$/;"	f	file:
UBWin	ooo_core.h	/^        typedef g_map<uint64_t, WinCycle> UBWin;$/;"	t	class:WindowStructure
UBWinIterator	ooo_core.h	/^        typedef typename UBWin::iterator UBWinIterator;$/;"	t	class:WindowStructure
UMON_INFO	utility_monitor.h	34;"	d
UMon	utility_monitor.cpp	/^UMon::UMon(uint32_t _bankLines, uint32_t _umonLines, uint32_t _buckets) {$/;"	f	class:UMon
UMon	utility_monitor.h	/^class UMon : public GlobAlloc {$/;"	c
UMonMonitor	monitor.cpp	/^UMonMonitor::UMonMonitor(uint32_t _numLines, uint32_t _umonLines, uint32_t _umonBuckets, uint32_t _numPartitions, uint32_t _buckets)$/;"	f	class:UMonMonitor
UMonMonitor	partitioner.h	/^class UMonMonitor : public PartitionMonitor {$/;"	c
UNINITIALIZED_CID	zsim.cpp	107;"	d	file:
UOP_FENCE	decoder.h	/^enum UopType : uint8_t {UOP_GENERAL, UOP_LOAD, UOP_STORE, UOP_STORE_ADDR, UOP_FENCE};$/;"	e	enum:uint8_t
UOP_GENERAL	decoder.h	/^enum UopType : uint8_t {UOP_GENERAL, UOP_LOAD, UOP_STORE, UOP_STORE_ADDR, UOP_FENCE};$/;"	e	enum:uint8_t
UOP_LOAD	decoder.h	/^enum UopType : uint8_t {UOP_GENERAL, UOP_LOAD, UOP_STORE, UOP_STORE_ADDR, UOP_FENCE};$/;"	e	enum:uint8_t
UOP_STORE	decoder.h	/^enum UopType : uint8_t {UOP_GENERAL, UOP_LOAD, UOP_STORE, UOP_STORE_ADDR, UOP_FENCE};$/;"	e	enum:uint8_t
UOP_STORE_ADDR	decoder.h	/^enum UopType : uint8_t {UOP_GENERAL, UOP_LOAD, UOP_STORE, UOP_STORE_ADDR, UOP_FENCE};$/;"	e	enum:uint8_t
USAGE_ERROR_ACTION	g_heap/dlmalloc.h.c	2724;"	d	file:
USAGE_ERROR_ACTION	g_heap/dlmalloc.h.c	2733;"	d	file:
USED	scheduler.h	/^            USED$/;"	e	enum:Scheduler::ContextState
USE_BUILTIN_FFS	g_heap/dlmalloc.h.c	699;"	d	file:
USE_DEV_RANDOM	g_heap/dlmalloc.h.c	702;"	d	file:
USE_LOCKS	g_heap/dlmalloc.h.c	32;"	d	file:
USE_LOCKS	g_heap/dlmalloc.h.c	627;"	d	file:
USE_LOCK_BIT	g_heap/dlmalloc.h.c	1991;"	d	file:
USE_LOCK_BIT	g_heap/dlmalloc.h.c	1993;"	d	file:
USE_MMAP_BIT	g_heap/dlmalloc.h.c	1618;"	d	file:
USE_MMAP_BIT	g_heap/dlmalloc.h.c	1636;"	d	file:
USE_NONCONTIGUOUS_BIT	g_heap/dlmalloc.h.c	1660;"	d	file:
USE_SPIN_LOCKS	g_heap/dlmalloc.h.c	631;"	d	file:
USE_SPIN_LOCKS	g_heap/dlmalloc.h.c	633;"	d	file:
UTILITY_MONITOR_H_	utility_monitor.h	27;"	d
UpdateCmdCounters	detailed_mem.cpp	/^void MemControllerBase::UpdateCmdCounters(void) {$/;"	f	class:MemControllerBase
UpdateDataBusCycle	detailed_mem.cpp	/^void MemChannelBase::UpdateDataBusCycle(uint64_t start, uint64_t end) {$/;"	f	class:MemChannelBase
UpdateLastRefreshCycle	detailed_mem.cpp	/^uint64_t MemChannelBase::UpdateLastRefreshCycle(uint32_t rank, uint64_t arrivalCycle, uint32_t refreshNum) {$/;"	f	class:MemChannelBase
UpdatePowerDownCycle	detailed_mem.cpp	/^void MemChannelBase::UpdatePowerDownCycle(uint32_t rank, uint64_t arrivalCycle, uint64_t lastPhaseCycle, uint32_t refreshNum) {$/;"	f	class:MemChannelBase
UpdateRefreshNum	detailed_mem.cpp	/^uint32_t MemChannelBase::UpdateRefreshNum(uint32_t rank, uint64_t arrivalCycle) {$/;"	f	class:MemChannelBase
Usage	zsim.cpp	/^INT32 Usage() {$/;"	f
VANTAGE_8BIT_BTS	part_repl_policies.h	236;"	d
VDD1	detailed_mem_params.h	/^        uint32_t VDD1;$/;"	m	class:MemParam
VF_CLOCK_GETTIME	zsim.cpp	/^enum VdsoFunc {VF_CLOCK_GETTIME, VF_GETTIMEOFDAY, VF_TIME, VF_GETCPU};$/;"	e	enum:VdsoFunc	file:
VF_GETCPU	zsim.cpp	/^enum VdsoFunc {VF_CLOCK_GETTIME, VF_GETTIMEOFDAY, VF_TIME, VF_GETCPU};$/;"	e	enum:VdsoFunc	file:
VF_GETTIMEOFDAY	zsim.cpp	/^enum VdsoFunc {VF_CLOCK_GETTIME, VF_GETTIMEOFDAY, VF_TIME, VF_GETCPU};$/;"	e	enum:VdsoFunc	file:
VF_TIME	zsim.cpp	/^enum VdsoFunc {VF_CLOCK_GETTIME, VF_GETTIMEOFDAY, VF_TIME, VF_GETCPU};$/;"	e	enum:VdsoFunc	file:
VIRT_COMMON_H_	virt/common.h	27;"	d
VIRT_PORT_VIRTUALIZER_H_	virt/port_virtualizer.h	27;"	d
VIRT_SYSCALL_NAME_H_	virt/syscall_name.h	27;"	d
VIRT_TIME_CONV_H_	virt/time_conv.h	28;"	d
VIRT_VIRT_H_	virt/virt.h	28;"	d
VantagePartInfo	part_repl_policies.h	/^        struct VantagePartInfo : public PartInfo {$/;"	s	class:VantageReplPolicy
VantageReplPolicy	part_repl_policies.h	/^        VantageReplPolicy(PartitionMonitor* _monitor, PartMapper* _mapper, uint64_t _lines,  uint32_t _assoc, uint32_t partPortionPct,$/;"	f	class:VantageReplPolicy
VantageReplPolicy	part_repl_policies.h	/^class VantageReplPolicy : public PartReplPolicy, public LegacyReplPolicy {$/;"	c
VdsoCallPoint	zsim.cpp	/^VOID VdsoCallPoint(THREADID tid) {$/;"	f
VdsoEntryPoint	zsim.cpp	/^VOID VdsoEntryPoint(THREADID tid, uint32_t func, ADDRINT arg0, ADDRINT arg1) {$/;"	f
VdsoFunc	zsim.cpp	/^enum VdsoFunc {VF_CLOCK_GETTIME, VF_GETTIMEOFDAY, VF_TIME, VF_GETCPU};$/;"	g	file:
VdsoInit	zsim.cpp	/^void VdsoInit() {$/;"	f
VdsoInsertFunc	zsim.cpp	/^void VdsoInsertFunc(IMG vi, const char* fName, VdsoFunc func) {$/;"	f
VdsoInstrument	zsim.cpp	/^VOID VdsoInstrument(INS ins) {$/;"	f
VdsoPatchData	zsim.cpp	/^struct VdsoPatchData {$/;"	s	file:
VdsoRetPoint	zsim.cpp	/^VOID VdsoRetPoint(THREADID tid, REG* raxPtr) {$/;"	f
VectorCounter	stats.h	/^        VectorCounter() : VectorStat() {}$/;"	f	class:VectorCounter
VectorCounter	stats.h	/^class VectorCounter : public VectorStat {$/;"	c
VectorStat	stats.h	/^        VectorStat() : _counterNames(NULL) {}$/;"	f	class:VectorStat
VectorStat	stats.h	/^class VectorStat : public Stat {$/;"	c
VirtCaptureClocks	virt/time.cpp	/^void VirtCaptureClocks(bool isDeffwd) {$/;"	f
VirtClockGettime	virt/time.cpp	/^void VirtClockGettime(uint32_t tid, ADDRINT arg0, ADDRINT arg1) {$/;"	f
VirtGetPhaseRDTSC	virt/time.cpp	/^uint64_t VirtGetPhaseRDTSC() {$/;"	f
VirtGetcpu	virt/cpu.cpp	/^void VirtGetcpu(uint32_t tid, uint32_t cpu, ADDRINT arg0, ADDRINT arg1) {$/;"	f
VirtGettimeofday	virt/time.cpp	/^void VirtGettimeofday(uint32_t tid, ADDRINT arg0) {$/;"	f
VirtInit	virt/virt.cpp	/^void VirtInit() {$/;"	f
VirtSyscallEnter	virt/virt.cpp	/^void VirtSyscallEnter(THREADID tid, CONTEXT *ctxt, SYSCALL_STANDARD std, const char* patchRoot, bool isNopThread) {$/;"	f
VirtSyscallExit	virt/virt.cpp	/^PostPatchAction VirtSyscallExit(THREADID tid, CONTEXT *ctxt, SYSCALL_STANDARD std) {$/;"	f
VirtTime	virt/time.cpp	/^void VirtTime(uint32_t tid, REG* out, ADDRINT arg0) {$/;"	f
WAITING	barrier.h	/^        enum State {OFFLINE, WAITING, RUNNING, LEFT};$/;"	e	enum:Barrier::State
WATCHDOG_INTERVAL_USEC	scheduler.cpp	40;"	d	file:
WATCHDOG_MAX_MULTIPLER	scheduler.cpp	41;"	d	file:
WATCHDOG_STALL_THRESHOLD	scheduler.cpp	42;"	d	file:
WEAVE_MD1_MEM_H_	weave_md1_mem.h	27;"	d
WIN32	g_heap/dlmalloc.h.c	545;"	d	file:
WIN32	g_heap/dlmalloc.h.c	549;"	d	file:
WIN32_LEAN_AND_MEAN	g_heap/dlmalloc.h.c	553;"	d	file:
WRITE	detailed_mem.h	/^enum MemAccessType { READ, WRITE, NUM_ACCESS_TYPES};$/;"	e	enum:MemAccessType
WarnTimingRelated	virt/virt.cpp	/^PostPatchFn WarnTimingRelated(PrePatchArgs args) {$/;"	f
WayPartInfo	part_repl_policies.h	/^        struct WayPartInfo {$/;"	s	class:WayPartReplPolicy
WayPartReplPolicy	part_repl_policies.h	/^        WayPartReplPolicy(PartitionMonitor* _monitor, PartMapper* _mapper, uint64_t _lines, uint32_t _ways, bool _testMode)$/;"	f	class:WayPartReplPolicy
WayPartReplPolicy	part_repl_policies.h	/^class WayPartReplPolicy : public PartReplPolicy, public LegacyReplPolicy {$/;"	c
WeaveMD1Memory	weave_md1_mem.h	/^        WeaveMD1Memory(uint32_t lineSize, uint32_t megacyclesPerSecond, uint32_t megabytesPerSecond, uint32_t _zeroLoadLatency, uint32_t _boundLatency, uint32_t _domain, g_string& _name) :$/;"	f	class:WeaveMD1Memory
WeaveMD1Memory	weave_md1_mem.h	/^class WeaveMD1Memory : public MD1Memory {$/;"	c
WeaveMemAccEvent	weave_md1_mem.h	/^        WeaveMemAccEvent(uint32_t _lat, int32_t domain, uint32_t preDelay, uint32_t postDelay) :  TimingEvent(preDelay, postDelay, domain), lat(_lat) {}$/;"	f	class:WeaveMemAccEvent
WeaveMemAccEvent	weave_md1_mem.h	/^class WeaveMemAccEvent : public TimingEvent {$/;"	c
WeaveSimpleMemory	weave_md1_mem.h	/^        WeaveSimpleMemory(uint32_t _latency, uint32_t _zeroLoadLatency, uint32_t _domain, g_string& _name) :$/;"	f	class:WeaveSimpleMemory
WeaveSimpleMemory	weave_md1_mem.h	/^class WeaveSimpleMemory : public SimpleMemory {$/;"	c
WinCycle	ooo_core.h	/^        struct WinCycle {$/;"	s	class:WindowStructure
WindowStructure	ooo_core.h	/^        WindowStructure() {$/;"	f	class:WindowStructure
WindowStructure	ooo_core.h	/^class WindowStructure {$/;"	c
XC	decoder.cpp	43;"	d	file:
XO	decoder.cpp	44;"	d	file:
ZArray	cache_arrays.cpp	/^ZArray::ZArray(uint32_t _numLines, uint32_t _ways, uint32_t _candidates, ReplPolicy* _rp, HashFamily* _hf) \/\/(int _size, int _lineSize, int _assoc, int _zassoc, ReplacementPolicy<T>* _rp, int _hashType)$/;"	f	class:ZArray
ZArray	cache_arrays.h	/^class ZArray : public CacheArray {$/;"	c
ZCands	cache_arrays.h	/^    inline ZCands(ZWalkInfo* _b, ZWalkInfo* _e) : b(_b), e(_e) {}$/;"	f	struct:ZCands
ZCands	cache_arrays.h	/^struct ZCands {$/;"	s
ZSIM_H_	zsim.h	27;"	d
ZSIM_MAGIC_OP_HEARTBEAT	zsim.cpp	1137;"	d	file:
ZSIM_MAGIC_OP_REGISTER_THREAD	zsim.cpp	1136;"	d	file:
ZSIM_MAGIC_OP_ROI_BEGIN	zsim.cpp	1134;"	d	file:
ZSIM_MAGIC_OP_ROI_END	zsim.cpp	1135;"	d	file:
ZWalkInfo	cache_arrays.h	/^struct ZWalkInfo {$/;"	s
_PAD_CONCAT	pad.h	34;"	d
_SC_PAGE_SIZE	g_heap/dlmalloc.h.c	1443;"	d	file:
__DETAILED_MEM_H__	detailed_mem.h	27;"	d
__DETAILED_MEM_PARAMS_H__	detailed_mem_params.h	27;"	d
__SYSCALL	virt/syscall_name.cpp	30;"	d	file:
__USE_GNU	g_heap/dlmalloc.h.c	1375;"	d	file:
__USE_GNU	g_heap/dlmalloc.h.c	1377;"	d	file:
__gm_calloc	galloc.cpp	/^void* __gm_calloc(size_t num, size_t size) {$/;"	f
__gm_memalign	galloc.cpp	/^void* __gm_memalign(size_t blocksize, size_t bytes) {$/;"	f
__log_lock	log.cpp	/^void __log_lock() {futex_lock(&log_printLock);}$/;"	f
__log_unlock	log.cpp	/^void __log_unlock() {futex_unlock(&log_printLock);}$/;"	f
_children	stats.h	/^        g_vector<Stat*> _children;$/;"	m	class:AggregateStat
_count	stats.h	/^        uint64_t _count;$/;"	m	class:Counter
_counterNames	stats.h	/^        const char** _counterNames;$/;"	m	class:VectorStat
_counters	stats.h	/^        g_vector<uint64_t> _counters;$/;"	m	class:VectorCounter
_desc	stats.h	/^        const char* _desc;$/;"	m	class:Stat
_func	stats.h	/^        uint64_t (*_func)();$/;"	m	class:ProxyFuncStat
_gm_	g_heap/dlmalloc.h.c	/^static struct malloc_state _gm_;$/;"	v	typeref:struct:malloc_state	file:
_isMutable	stats.h	/^        bool _isMutable;$/;"	m	class:AggregateStat
_isRegular	stats.h	/^        bool _isRegular;$/;"	m	class:AggregateStat
_name	stats.h	/^        const char* _name;$/;"	m	class:Stat
_statPtr	stats.h	/^        uint64_t* _statPtr;$/;"	m	class:ProxyStat
a	ideal_arrays.h	/^                IdealLRUArray* a;$/;"	m	class:IdealLRUArray::ProxyReplPolicy
acc	repl_policies.h	/^            uint64_t acc;$/;"	m	struct:LFUReplPolicy::LFUInfo
accAvgPowerReport	detailed_mem_params.h	/^        bool accAvgPowerReport;$/;"	m	class:MemParam
accLat	cache.h	/^        uint32_t accLat; \/\/latency of a normal access (could split in get\/put, probably not needed)$/;"	m	class:Cache
accTimes	repl_policies.h	/^        AccTimes* accTimes;$/;"	m	class:ProfViolReplPolicy
access	cache.cpp	/^uint64_t Cache::access(MemReq& req) {$/;"	f	class:Cache
access	ddr_mem.cpp	/^uint64_t DDRMemory::access(MemReq& req) {$/;"	f	class:DDRMemory
access	detailed_mem.cpp	/^uint64_t MemControllerBase::access(MemReq& req) {$/;"	f	class:MemControllerBase
access	detailed_mem.cpp	/^void MemRankBase::access(uint64_t accessCycle, uint64_t issuedCycle, uint32_t row, uint32_t col, uint32_t bank, MemAccessType type) {$/;"	f	class:MemRankBase
access	dramsim_mem_ctrl.cpp	/^uint64_t DRAMSimMemory::access(MemReq& req) { panic("???"); return 0; }$/;"	f	class:DRAMSimMemory
access	dramsim_mem_ctrl.cpp	/^uint64_t DRAMSimMemory::access(MemReq& req) {$/;"	f	class:DRAMSimMemory
access	dramsim_mem_ctrl.h	/^        uint64_t access(MemReq& req) {$/;"	f	class:SplitAddrMemory
access	mem_ctrls.cpp	/^uint64_t MD1Memory::access(MemReq& req) {$/;"	f	class:MD1Memory
access	mem_ctrls.cpp	/^uint64_t SimpleMemory::access(MemReq& req) {$/;"	f	class:SimpleMemory
access	monitor.cpp	/^void UMonMonitor::access(uint32_t partition, Address lineAddr) {$/;"	f	class:UMonMonitor
access	prefetcher.cpp	/^uint64_t StreamPrefetcher::access(MemReq& req) {$/;"	f	class:StreamPrefetcher
access	timing_cache.cpp	/^uint64_t TimingCache::access(MemReq& req) {$/;"	f	class:TimingCache
access	utility_monitor.cpp	/^void UMon::access(Address lineAddr) {$/;"	f	class:UMon
access	weave_md1_mem.h	/^        uint64_t access(MemReq& req) {$/;"	f	class:WeaveMD1Memory
access	weave_md1_mem.h	/^        uint64_t access(MemReq& req) {$/;"	f	class:WeaveSimpleMemory
accessInRefresh	detailed_mem.h	/^        uint32_t accessInRefresh;$/;"	m	class:MemRankBase
accessLog	detailed_mem.h	/^        std::vector<std::pair<uint64_t, uint64_t> > accessLog;$/;"	m	class:MemChannelBase
accessLogDepth	detailed_mem_params.h	/^        uint32_t accessLogDepth;$/;"	m	class:MemParam
accessTypeNames	memory_hierarchy.cpp	/^static const char* accessTypeNames[] = {"GETS", "GETX", "PUTS", "PUTX"};$/;"	v	file:
accsLeft	timing_cache.cpp	/^        uint32_t accsLeft;$/;"	m	class:ReplAccessEvent	file:
actPre	detailed_mem.h	/^            uint64_t actPre;$/;"	m	struct:MemControllerBase::powerValue
action	scheduler.h	/^            FutexJoinAction action;$/;"	m	struct:Scheduler::FutexJoinInfo
activateCount	detailed_mem.h	/^        uint64_t activateCount;$/;"	m	class:MemRankBase
active	tick_event.h	/^        bool active;$/;"	m	class:TickEvent
activeMisses	timing_cache.h	/^        uint32_t numMSHRs, activeMisses;$/;"	m	class:TimingCache
activeThreads	zsim.cpp	/^bool activeThreads[MAX_THREADS];  \/\/ set in ThreadStart, reset in ThreadFini, we need this for exec() (see FollowChild)$/;"	v
actvPowerDownCycle	detailed_mem.h	/^        uint64_t actvPowerDownCycle;$/;"	m	class:MemRankBase
addActivation	ddr_mem.h	/^        inline void addActivation(uint64_t actCycle) {$/;"	f	class:ActWindow
addChild	process_tree.h	/^        void addChild(ProcessTreeNode* child) {$/;"	f	class:ProcessTreeNode
addChild	timing_event.h	/^        TimingEvent* addChild(TimingEvent* childEv, EventRecorder& evRec) {$/;"	f	class:TimingEvent
addChild	timing_event.h	/^        TimingEvent* addChild(TimingEvent* childEv, EventRecorder* evRec) {$/;"	f	class:TimingEvent
addIssueEvent	ooo_core_recorder.cpp	/^void OOOCoreRecorder::addIssueEvent(uint64_t evCycle) {$/;"	f	class:OOOCoreRecorder
add_segment	g_heap/dlmalloc.h.c	/^static void add_segment(mstate m, char* tbase, size_t tsize, flag_t mmapped) {$/;"	f	file:
addr	ddr_mem.cpp	/^        Address addr;$/;"	m	class:DDRMemoryAccEvent	file:
addr	ddr_mem.h	/^            Address addr;$/;"	m	struct:DDRMemory::Request
addr	decoder.h	/^    uint64_t addr;$/;"	m	struct:DynBbl
addr	detailed_mem.h	/^        Address addr;$/;"	m	class:MemAccessEventBase
addr	dramsim_mem_ctrl.cpp	/^        Address addr;$/;"	m	class:DRAMSimAccEvent	file:
addr	event_recorder.h	/^    Address addr;$/;"	m	struct:TimingRecord
addr	ooo_core.h	/^            Address addr;$/;"	m	struct:OOOCore::FwdEntry
addr	part_repl_policies.h	/^            Address addr; \/\/FIXME: This is redundant due to the replacement policy interface$/;"	m	struct:VantageReplPolicy::LineInfo
addr	part_repl_policies.h	/^            Address addr; \/\/FIXME: This is redundant due to the replacement policy interface$/;"	m	struct:WayPartReplPolicy::WayPartInfo
addr	utility_monitor.h	/^            Address addr;$/;"	m	struct:UMon::Node
addrTrace	detailed_mem_params.h	/^        bool addrTrace;$/;"	m	class:MemParam
addrTraceLog	detailed_mem.h	/^        gzFile addrTraceLog;$/;"	m	class:MemControllerBase
address	g_std/stl_galloc.h	/^        const_pointer address(const_reference x) const { return &x; }$/;"	f	class:StlGlobAlloc
address	g_std/stl_galloc.h	/^        pointer address(reference x) const { return &x; }$/;"	f	class:StlGlobAlloc
advance	event_recorder.h	/^        void advance(uint64_t prodCycle, uint64_t usedCycle) {$/;"	f	class:EventRecorder
advance	ooo_core.cpp	/^void OOOCore::advance(uint64_t targetCycle) {$/;"	f	class:OOOCore
advance	phase_slab_alloc.h	/^        void advance(uint64_t prodCycle, uint64_t usedCycle) {$/;"	f	class:PhaseSlabAlloc
advancePos	ooo_core.h	/^        inline void advancePos(uint64_t& curCycle) {$/;"	f	class:WindowStructure
align_as_chunk	g_heap/dlmalloc.h.c	2184;"	d	file:
align_offset	g_heap/dlmalloc.h.c	1512;"	d	file:
alloc	ddr_mem.h	/^        inline T* alloc() {$/;"	f	class:RequestQueue
alloc	event_recorder.h	/^        T* alloc() {$/;"	f	class:EventRecorder
alloc	event_recorder.h	/^        void* alloc(size_t sz) {$/;"	f	class:EventRecorder
alloc	phase_slab_alloc.h	/^            void* alloc(uint32_t bytes) {$/;"	f	struct:PhaseSlabAlloc::Slab
alloc	phase_slab_alloc.h	/^        T* alloc() {$/;"	f	class:PhaseSlabAlloc
alloc	phase_slab_alloc.h	/^        void* alloc(size_t sz) {$/;"	f	class:PhaseSlabAlloc
alloc	prefetcher.h	/^            void alloc(uint64_t curCycle) {$/;"	f	struct:StreamPrefetcher::Entry
allocPortion	partitioner.h	/^        double allocPortion;$/;"	m	class:Partitioner
allocSlab	phase_slab_alloc.h	/^        void allocSlab() {$/;"	f	class:PhaseSlabAlloc
allocate	g_std/stl_galloc.h	/^        pointer allocate(size_type n, const void * = 0) {$/;"	f	class:StlGlobAlloc
annul	ddr_mem.cpp	/^        void annul() {$/;"	f	class:SchedEvent
anyReport	detailed_mem_params.h	/^        bool anyReport;$/;"	m	class:MemParam
append	stats.h	/^        void append(Stat* child) {$/;"	f	class:AggregateStat
approxInstrs	decoder.h	/^    uint32_t approxInstrs;$/;"	m	struct:DynBbl
approxInstrs	ooo_core.h	/^        uint64_t instrs, uops, bbls, approxInstrs, mispredBranches;$/;"	m	class:OOOCore
arena	g_heap/dlmalloc.h.c	/^  MALLINFO_FIELD_TYPE arena;    \/* non-mmapped space allocated from system *\/$/;"	m	struct:mallinfo	file:
arg0	scheduler.h	/^            const uint64_t arg0; \/\/ kept for reference$/;"	m	struct:Scheduler::FakeLeaveInfo
arg0	zsim.cpp	/^    ADDRINT arg0, arg1;$/;"	m	struct:VdsoPatchData	file:
arg1	scheduler.h	/^            const uint64_t arg1; \/\/ kept for reference$/;"	m	struct:Scheduler::FakeLeaveInfo
arg1	zsim.cpp	/^    ADDRINT arg0, arg1;$/;"	m	struct:VdsoPatchData	file:
args	pin_cmd.h	/^        g_vector<g_string> args;$/;"	m	class:PinCmd
array	cache.h	/^        CacheArray* array;$/;"	m	class:Cache
array	cache_arrays.h	/^        Address* array; \/\/maps line id to address$/;"	m	class:ZArray
array	cache_arrays.h	/^        Address* array;$/;"	m	class:SetAssocArray
array	coherence_ctrls.h	/^        Entry* array;$/;"	m	class:MESITopCC
array	coherence_ctrls.h	/^        MESIState* array;$/;"	m	class:MESIBottomCC
array	ideal_arrays.h	/^        Entry* array;$/;"	m	class:IdealLRUArray
array	ideal_arrays.h	/^        Entry* array;$/;"	m	class:IdealLRUPartReplPolicy
array	part_repl_policies.h	/^        LineInfo* array;$/;"	m	class:VantageReplPolicy
array	part_repl_policies.h	/^        WayPartInfo* array;$/;"	m	class:WayPartReplPolicy
array	prefetcher.h	/^        Entry array[16];$/;"	m	class:StreamPrefetcher
array	prio_queue.h	/^        T* array[64];$/;"	m	struct:PrioQueue::PQBlock
array	repl_policies.h	/^        LFUInfo* array;$/;"	m	class:LFUReplPolicy
array	repl_policies.h	/^        uint32_t* array;$/;"	m	class:NRUReplPolicy
array	repl_policies.h	/^        uint64_t* array;$/;"	m	class:LRUReplPolicy
array	utility_monitor.h	/^        Node** array;$/;"	m	class:UMon
arrivalCycle	ddr_mem.h	/^            uint64_t arrivalCycle;  \/\/ in memCycles$/;"	m	struct:DDRMemory::Request
arrivalLock	zsim.cpp	/^        lock_t arrivalLock;$/;"	m	class:SyncEvent	file:
aslr	zsim_harness.cpp	/^bool perProcessDir, aslr;$/;"	v
assert	g_heap/dlmalloc.h.c	1352;"	d	file:
assert	g_heap/dlmalloc.h.c	1353;"	d	file:
assert	g_heap/dlmalloc.h.c	1359;"	d	file:
assert	log.h	127;"	d
assert	log.h	147;"	d
assert_msg	log.h	135;"	d
assert_msg	log.h	148;"	d
assoc	cache_arrays.h	/^        uint32_t assoc;$/;"	m	class:SetAssocArray
assoc	part_repl_policies.h	/^        uint32_t assoc;$/;"	m	class:VantageReplPolicy
atSyncFunc	scheduler.h	/^        void (*atSyncFunc)(void); \/\/executed by syncing thread while others are waiting. Good for non-thread-safe stuff$/;"	m	class:Scheduler
atomicInc	stats.h	/^        inline void atomicInc() {$/;"	f	class:Counter
atomicInc	stats.h	/^        inline void atomicInc(uint32_t idx) {$/;"	f	class:VectorCounter
atomicInc	stats.h	/^        inline void atomicInc(uint32_t idx, uint64_t delta) {$/;"	f	class:VectorCounter
atomicInc	stats.h	/^        inline void atomicInc(uint64_t delta) {$/;"	f	class:Counter
attachDebugger	zsim.h	/^    bool attachDebugger;$/;"	m	struct:GlobSimInfo
availCycle	filter_cache.h	/^            volatile uint64_t availCycle;$/;"	m	struct:FilterCache::FilterEntry
b	cache_arrays.h	/^    ZWalkInfo* b;$/;"	m	struct:ZCands
b	cache_arrays.h	/^    uint32_t b, e;$/;"	m	struct:SetAssocCands
back	intrusive_list.h	/^        T* back() const {return tail;}$/;"	f	class:InList
backend	stats.h	/^        HDF5BackendImpl* backend;$/;"	m	class:HDF5Backend
backend	stats.h	/^        TextBackendImpl* backend;$/;"	m	class:TextBackend
background	detailed_mem.h	/^            uint64_t background;$/;"	m	struct:MemControllerBase::powerValue
bandwidthReport	detailed_mem_params.h	/^        bool bandwidthReport;$/;"	m	class:MemParam
bank	ddr_mem.h	/^            uint32_t bank;$/;"	m	struct:DDRMemory::AddrLoc
bankCount	detailed_mem.h	/^        uint32_t bankCount;$/;"	m	class:MemRankBase
bankCount	detailed_mem_params.h	/^        uint32_t bankCount;$/;"	m	class:MemParam
bankMask	ddr_mem.h	/^        uint32_t bankShift, bankMask;$/;"	m	class:DDRMemory
bankShift	ddr_mem.h	/^        uint32_t bankShift, bankMask;$/;"	m	class:DDRMemory
bankWidth	detailed_mem_params.h	/^        uint32_t bankWidth;$/;"	m	class:MemParam
bankinfo	detailed_mem.h	/^        bool *bankinfo;$/;"	m	class:MemRankBase
banks	ddr_mem.h	/^        g_vector< g_vector<Bank> > banks; \/\/ indexed by rank, bank$/;"	m	class:DDRMemory
banksPerRank	ddr_mem.h	/^        const uint32_t lineSize, ranksPerChannel, banksPerRank;$/;"	m	class:DDRMemory
bar	scheduler.h	/^        Barrier bar;$/;"	m	class:Scheduler
base	g_heap/dlmalloc.h.c	/^  char*        base;             \/* base address *\/$/;"	m	struct:malloc_segment	file:
base_regp	galloc.cpp	/^    volatile void* base_regp; \/\/common data structure, accessible with glob_ptr; threads poll on gm_isready to determine when everything has been initialized$/;"	m	struct:gm_segment	file:
bbl	null_core.cpp	/^void NullCore::bbl(BblInfo* bblInfo) {$/;"	f	class:NullCore
bbl	ooo_core.cpp	/^inline void OOOCore::bbl(Address bblAddr, BblInfo* bblInfo) {$/;"	f	class:OOOCore
bbl	simple_core.cpp	/^void SimpleCore::bbl(Address bblAddr, BblInfo* bblInfo) {$/;"	f	class:SimpleCore
bblAndRecord	timing_core.cpp	/^void TimingCore::bblAndRecord(Address bblAddr, BblInfo* bblInfo) {$/;"	f	class:TimingCore
bblApproxOpcodes	decoder.cpp	/^static std::vector<uint32_t>* bblApproxOpcodes[MAX_BBLS];$/;"	v	file:
bblCount	decoder.cpp	/^static uint64_t bblCount[MAX_BBLS];$/;"	v	file:
bblIdx	decoder.cpp	/^static uint64_t bblIdx = 0;$/;"	v	file:
bblIdx	decoder.h	/^    uint64_t bblIdx;$/;"	m	struct:DynBbl
bblIdxLock	decoder.cpp	/^static lock_t bblIdxLock = 0;$/;"	v	file:
bblPtr	core.h	/^    void (*bblPtr)(THREADID, ADDRINT, BblInfo*);$/;"	m	struct:InstrFuncPtrs
bbls	ooo_core.h	/^        uint64_t instrs, uops, bbls, approxInstrs, mispredBranches;$/;"	m	class:OOOCore
bcc	coherence_ctrls.h	/^        MESIBottomCC* bcc;$/;"	m	class:MESICC
bcc	coherence_ctrls.h	/^        MESIBottomCC* bcc;$/;"	m	class:MESITerminalCC
begin	cache_arrays.h	/^    inline iterator begin() const {return iterator(b);}$/;"	f	struct:SetAssocCands
begin	cache_arrays.h	/^    inline iterator begin() const {return iterator(b);}$/;"	f	struct:ZCands
begin	ddr_mem.h	/^        inline iterator begin() const {return iterator(reqList.front());}$/;"	f	class:RequestQueue
bestCandidate	repl_policies.h	/^        int32_t bestCandidate; \/\/ id$/;"	m	class:LFUReplPolicy
bestId	part_repl_policies.h	/^        int32_t bestId;$/;"	m	class:WayPartReplPolicy
bestRank	repl_policies.h	/^        Rank bestRank;$/;"	m	class:LFUReplPolicy
bhsr	ooo_core.h	/^        uint32_t bhsr[1 << NB];$/;"	m	class:BranchPredictorPAg
bin_find	g_heap/dlmalloc.h.c	/^static int bin_find(mstate m, mchunkptr x) {$/;"	f	file:
bindex_t	g_heap/dlmalloc.h.c	/^typedef unsigned int bindex_t;         \/* Described below *\/$/;"	t	file:
binmap_t	g_heap/dlmalloc.h.c	/^typedef unsigned int binmap_t;         \/* Described below *\/$/;"	t	file:
bit_for_tree_index	g_heap/dlmalloc.h.c	2848;"	d	file:
bk	g_heap/dlmalloc.h.c	/^  struct malloc_chunk* bk;$/;"	m	struct:malloc_chunk	typeref:struct:malloc_chunk::malloc_chunk	file:
bk	g_heap/dlmalloc.h.c	/^  struct malloc_tree_chunk* bk;$/;"	m	struct:malloc_tree_chunk	typeref:struct:malloc_tree_chunk::malloc_tree_chunk	file:
blockingSyscalls	scheduler.h	/^        g_vector< g_unordered_set<uint64_t> > blockingSyscalls;$/;"	m	class:Scheduler
blockingSyscalls	zsim.h	/^    bool blockingSyscalls;$/;"	m	struct:GlobSimInfo
blocks	prio_queue.h	/^    PQBlock blocks[B];$/;"	m	class:PrioQueue
boundLatency	weave_md1_mem.h	/^        const uint32_t boundLatency;$/;"	m	class:WeaveMD1Memory
branch	ooo_core.cpp	/^void OOOCore::branch(Address pc, bool taken, Address takenNpc, Address notTakenNpc) {$/;"	f	class:OOOCore
branchNotTakenNpc	ooo_core.h	/^        Address branchNotTakenNpc;$/;"	m	class:OOOCore
branchPc	ooo_core.h	/^        Address branchPc;  \/\/0 if last bbl was not a conditional branch$/;"	m	class:OOOCore
branchPred	ooo_core.h	/^        BranchPredictorPAg<11, 18, 14> branchPred;$/;"	m	class:OOOCore
branchPtr	core.h	/^    void (*branchPtr)(THREADID, ADDRINT, BOOL, ADDRINT, ADDRINT);$/;"	m	struct:InstrFuncPtrs
branchTaken	ooo_core.h	/^        bool branchTaken;$/;"	m	class:OOOCore
branchTakenNpc	ooo_core.h	/^        Address branchTakenNpc;$/;"	m	class:OOOCore
bssAddr	debug.h	/^    void* bssAddr;$/;"	m	struct:LibInfo
bts	part_repl_policies.h	/^            uint64_t bts; \/\/coarse-grain per-partition timestamp$/;"	m	struct:VantageReplPolicy::LineInfo
buckets	partitioner.h	/^        uint32_t buckets;$/;"	m	class:LookaheadPartitioner
buckets	partitioner.h	/^        uint32_t buckets;$/;"	m	class:PartitionMonitor
buckets	utility_monitor.h	/^        uint32_t buckets; \/\/umon ways$/;"	m	class:UMon
buf	ddr_mem.h	/^        g_vector<uint64_t> buf;$/;"	m	class:ActWindow
buf	ooo_core.h	/^        uint64_t buf[SZ];$/;"	m	class:CycleQueue
buf	ooo_core.h	/^        uint64_t buf[SZ];$/;"	m	class:ReorderBuffer
buf	phase_slab_alloc.h	/^            char buf[0]; \/\/buffer starts here$/;"	m	struct:PhaseSlabAlloc::Slab
bufferedRecords	hdf5_stats.cpp	/^        uint32_t bufferedRecords; \/\/number of records buffered (dumped w\/o being written), <= recordsPerWrite$/;"	m	class:HDF5BackendImpl	file:
burst	detailed_mem.h	/^            uint64_t burst;$/;"	m	struct:MemControllerBase::powerValue
bwCounterNum	detailed_mem.h	/^        static const uint32_t bwCounterNum = 4;$/;"	m	class:MemControllerBase
byteOffsetWidth	detailed_mem_params.h	/^        uint32_t byteOffsetWidth;$/;"	m	class:MemParam
bytes	core.h	/^    uint32_t bytes;$/;"	m	struct:BblInfo
bytes	decoder.h	/^    static uint32_t bytes(uint32_t uops) {$/;"	f	struct:DynBbl
c	g_heap/dlmalloc.h.c	/^  unsigned int c;$/;"	m	struct:pthread_mlock_t	file:
c	g_heap/dlmalloc.h.c	/^  unsigned int c;$/;"	m	struct:win32_mlock_t	file:
cRec	core_recorder.cpp	/^        CoreRecorder* cRec;$/;"	m	class:TimingCoreEvent	file:
cRec	ooo_core.h	/^        OOOCoreRecorder cRec;$/;"	m	class:OOOCore
cRec	ooo_core_recorder.cpp	/^        OOOCoreRecorder* cRec;$/;"	m	class:OOOIssueEvent	file:
cRec	ooo_core_recorder.cpp	/^        OOOCoreRecorder* cRec;$/;"	m	class:OOORespEvent	file:
cRec	timing_core.h	/^        CoreRecorder cRec;$/;"	m	class:TimingCore
cSimEnd	core_recorder.cpp	/^uint64_t CoreRecorder::cSimEnd(uint64_t curCycle) {$/;"	f	class:CoreRecorder
cSimEnd	ooo_core.cpp	/^void OOOCore::cSimEnd() {$/;"	f	class:OOOCore
cSimEnd	ooo_core_recorder.cpp	/^uint64_t OOOCoreRecorder::cSimEnd(uint64_t curCycle) {$/;"	f	class:OOOCoreRecorder
cSimEnd	timing_core.h	/^        void cSimEnd() {curCycle = cRec.cSimEnd(curCycle);}$/;"	f	class:TimingCore
cSimStart	core_recorder.cpp	/^uint64_t CoreRecorder::cSimStart(uint64_t curCycle) {$/;"	f	class:CoreRecorder
cSimStart	ooo_core.cpp	/^void OOOCore::cSimStart() {$/;"	f	class:OOOCore
cSimStart	ooo_core_recorder.cpp	/^uint64_t OOOCoreRecorder::cSimStart(uint64_t curCycle) {$/;"	f	class:OOOCoreRecorder
cSimStart	timing_core.h	/^        void cSimStart() {curCycle = cRec.cSimStart(curCycle);}$/;"	f	class:TimingCore
cache	timing_cache.cpp	/^        TimingCache* cache;$/;"	m	class:HitEvent	file:
cache	timing_cache.cpp	/^        TimingCache* cache;$/;"	m	class:MissResponseEvent	file:
cache	timing_cache.cpp	/^        TimingCache* cache;$/;"	m	class:MissStartEvent	file:
cache	timing_cache.cpp	/^        TimingCache* cache;$/;"	m	class:MissWritebackEvent	file:
cache	timing_cache.cpp	/^        TimingCache* cache;$/;"	m	class:ReplAccessEvent	file:
cacheLineSize	detailed_mem.h	/^        uint32_t cacheLineSize;$/;"	m	class:MemControllerBase
cacheLineSize	detailed_mem_params.h	/^        uint32_t cacheLineSize;$/;"	m	class:MemParam
callback	event_queue.h	/^        void callback() {$/;"	f	class:AdaptiveEvent
callback	partitioner.h	/^                void callback() { part->partition(); }$/;"	f	class:Partitioner::PartitionEvent
callback	scheduler.h	/^        virtual void callback() {$/;"	f	class:Scheduler
callback	zsim.cpp	/^        void callback() {$/;"	f	class:SyncEvent
called	timing_event.h	/^        volatile bool called;$/;"	m	class:CrossingEvent
calloc_must_clear	g_heap/dlmalloc.h.c	2257;"	d	file:
calloc_must_clear	g_heap/dlmalloc.h.c	2259;"	d	file:
canFuse	decoder.cpp	/^bool Decoder::canFuse(INS ins) {$/;"	f	class:Decoder
candArray	repl_policies.h	/^        uint32_t* candArray;$/;"	m	class:NRUReplPolicy
candArray	repl_policies.h	/^        uint32_t* candArray;$/;"	m	class:RandReplPolicy
candArray	repl_policies.h	/^        uint32_t* candArray;$/;"	m	class:TreeLRUReplPolicy
candIdx	part_repl_policies.h	/^        uint32_t candIdx;$/;"	m	class:VantageReplPolicy
candIdx	part_repl_policies.h	/^        uint32_t candIdx;$/;"	m	class:WayPartReplPolicy
candIdx	repl_policies.h	/^        uint32_t candIdx;$/;"	m	class:NRUReplPolicy
candIdx	repl_policies.h	/^        uint32_t candIdx;$/;"	m	class:RandReplPolicy
candIdx	repl_policies.h	/^        uint32_t candIdx;$/;"	m	class:TreeLRUReplPolicy
candList	part_repl_policies.h	/^        uint32_t* candList;$/;"	m	class:VantageReplPolicy
candVal	repl_policies.h	/^        uint32_t candVal;$/;"	m	class:NRUReplPolicy
candVal	repl_policies.h	/^        uint32_t candVal;$/;"	m	class:RandReplPolicy
cands	cache_arrays.h	/^        uint32_t cands;$/;"	m	class:ZArray
cands	timing_cache.h	/^        uint32_t tagLat, ways, cands;$/;"	m	class:TimingCache
cc	cache.h	/^        CC* cc;$/;"	m	class:Cache
cc	ideal_arrays.h	/^        CC* cc;$/;"	m	class:IdealLRUArray
cc	repl_policies.h	/^        CC* cc; \/\/coherence controller, used to figure out whether candidates are valid or number of sharers$/;"	m	class:ReplPolicy
ccLock	coherence_ctrls.h	/^        lock_t ccLock;$/;"	m	class:MESIBottomCC
ccLock	coherence_ctrls.h	/^        lock_t ccLock;$/;"	m	class:MESITopCC
ce	timing_event.h	/^                CrossingEvent* ce;$/;"	m	class:CrossingEvent::CrossingSrcEvent
change_mparam	g_heap/dlmalloc.h.c	/^static int change_mparam(int param_number, int value) {$/;"	f	file:
channelCount	detailed_mem_params.h	/^        uint32_t channelCount;$/;"	m	class:MemParam
channelDataWidth	detailed_mem_params.h	/^        uint32_t channelDataWidth; \/\/ Data bus bits (= JEDEC_BUS_WIDTH)$/;"	m	class:MemParam
channelDataWidthLog	detailed_mem_params.h	/^        uint32_t channelDataWidthLog; \/\/ ilog2(Datawdith \/ 8)$/;"	m	class:MemParam
channelWidth	detailed_mem_params.h	/^        uint32_t channelWidth;$/;"	m	class:MemParam
checkDomain	timing_event.cpp	/^void TimingEvent::checkDomain(TimingEvent* ch) {$/;"	f	class:TimingEvent
checkEndPhase	barrier.h	/^        inline void checkEndPhase(uint32_t tid) {$/;"	f	class:Barrier
checkIncluded	config.cpp	/^static uint32_t checkIncluded(libconfig::Setting& s1, libconfig::Setting& s2, std::string prefix) {$/;"	f	file:
checkRunList	barrier.h	/^        inline void checkRunList(uint32_t tid) {$/;"	f	class:Barrier
check_free_chunk	g_heap/dlmalloc.h.c	2742;"	d	file:
check_free_chunk	g_heap/dlmalloc.h.c	2750;"	d	file:
check_inuse_chunk	g_heap/dlmalloc.h.c	2743;"	d	file:
check_inuse_chunk	g_heap/dlmalloc.h.c	2751;"	d	file:
check_malloc_state	g_heap/dlmalloc.h.c	2746;"	d	file:
check_malloc_state	g_heap/dlmalloc.h.c	2755;"	d	file:
check_malloced_chunk	g_heap/dlmalloc.h.c	2744;"	d	file:
check_malloced_chunk	g_heap/dlmalloc.h.c	2753;"	d	file:
check_mmapped_chunk	g_heap/dlmalloc.h.c	2745;"	d	file:
check_mmapped_chunk	g_heap/dlmalloc.h.c	2754;"	d	file:
check_top_chunk	g_heap/dlmalloc.h.c	2747;"	d	file:
check_top_chunk	g_heap/dlmalloc.h.c	2752;"	d	file:
checkpoint	log.h	151;"	d
child	g_heap/dlmalloc.h.c	/^  struct malloc_tree_chunk* child[2];$/;"	m	struct:malloc_tree_chunk	typeref:struct:malloc_tree_chunk::malloc_tree_chunk	file:
child	prefetcher.h	/^        BaseCache* child;$/;"	m	class:StreamPrefetcher
child	timing_event.h	/^            TimingEvent* child;$/;"	m	union:TimingEvent::__anon11
childId	memory_hierarchy.h	/^    uint32_t childId;$/;"	m	struct:MemReq
childId	prefetcher.h	/^        uint32_t childId;$/;"	m	class:StreamPrefetcher
childInfo	zsim_harness.cpp	/^ProcInfo childInfo[MAX_CHILDREN];$/;"	v
childLock	memory_hierarchy.h	/^    lock_t* childLock;$/;"	m	struct:MemReq
children	coherence_ctrls.h	/^        g_vector<BaseCache*> children;$/;"	m	class:MESITopCC
children	process_tree.h	/^        g_vector<ProcessTreeNode*> children;$/;"	m	class:ProcessTreeNode
children	timing_event.h	/^            TimingEventBlock* children;$/;"	m	union:TimingEvent::__anon11
childrenRTTs	coherence_ctrls.h	/^        g_vector<uint32_t> childrenRTTs;$/;"	m	class:MESITopCC
chipCapacity	detailed_mem_params.h	/^        uint32_t chipCapacity; \/\/ megabits$/;"	m	class:MemParam
chipCountPerRank	detailed_mem_params.h	/^        uint32_t chipCountPerRank;$/;"	m	class:MemParam
chldSigHandler	zsim_harness.cpp	/^void chldSigHandler(int sig) {$/;"	f
chnls	detailed_mem.h	/^        g_vector <MemChannelBase*> chnls;$/;"	m	class:MemControllerBase
chunk2mem	g_heap/dlmalloc.h.c	2181;"	d	file:
chunk_minus_offset	g_heap/dlmalloc.h.c	2230;"	d	file:
chunk_plus_offset	g_heap/dlmalloc.h.c	2229;"	d	file:
chunksize	g_heap/dlmalloc.h.c	2224;"	d	file:
cid	scheduler.h	/^            uint32_t cid; \/\/only current if RUNNING; otherwise, it's the last one used.$/;"	m	struct:Scheduler::ThreadInfo
cid	scheduler.h	/^            uint32_t cid;$/;"	m	struct:Scheduler::ContextInfo
cids	zsim.cpp	/^static uint32_t cids[MAX_THREADS];$/;"	v	file:
cinuse	g_heap/dlmalloc.h.c	2219;"	d	file:
clear	coherence_ctrls.h	/^            void clear() {$/;"	f	struct:MESITopCC::Entry
clear	decoder.cpp	/^void DynUop::clear() {$/;"	f	class:DynUop
clear	filter_cache.h	/^            void clear() {wrAddr = 0; rdAddr = 0; availCycle = 0;}$/;"	f	struct:FilterCache::FilterEntry
clear	phase_slab_alloc.h	/^            void clear() {$/;"	f	class:PhaseSlabAlloc::SlabList
clear	phase_slab_alloc.h	/^            void clear() {$/;"	f	struct:PhaseSlabAlloc::Slab
clearCid	zsim.cpp	/^static inline void clearCid(uint32_t tid) {$/;"	f	file:
clearRecords	event_recorder.h	/^        inline void clearRecords() {$/;"	f	class:EventRecorder
clear_pinuse	g_heap/dlmalloc.h.c	2226;"	d	file:
clear_smallmap	g_heap/dlmalloc.h.c	2869;"	d	file:
clear_treemap	g_heap/dlmalloc.h.c	2873;"	d	file:
clockDomain	process_tree.h	/^        const uint32_t clockDomain;$/;"	m	class:ProcessTreeNode
clockDomainInfo	zsim.h	/^    ClockDomainInfo clockDomainInfo[MAX_CLOCK_DOMAINS];$/;"	m	struct:GlobSimInfo
closedPage	ddr_mem.h	/^        const bool closedPage;$/;"	m	class:DDRMemory
cmd	pin_cmd.h	/^            g_string cmd;$/;"	m	struct:PinCmd::ProcCmdInfo
col	ddr_mem.h	/^            uint32_t col;$/;"	m	struct:DDRMemory::AddrLoc
colAddrWidth	detailed_mem_params.h	/^        uint32_t colAddrWidth;$/;"	m	class:MemParam
colMask	ddr_mem.h	/^        uint32_t colShift, colMask;$/;"	m	class:DDRMemory
colShift	ddr_mem.h	/^        uint32_t colShift, colMask;$/;"	m	class:DDRMemory
compactPeriodicStats	zsim.h	/^    bool compactPeriodicStats;$/;"	m	struct:GlobSimInfo
compactStatsBackend	zsim.h	/^    StatsBackend* compactStatsBackend;$/;"	m	struct:GlobSimInfo
computeBestPartitioning	lookahead.cpp	/^void computeBestPartitioning($/;"	f	namespace:lookahead
computePartitioningTotalUtility	lookahead.cpp	/^uint64_t computePartitioningTotalUtility($/;"	f	namespace:lookahead
compute_bit2idx	g_heap/dlmalloc.h.c	2888;"	d	file:
compute_bit2idx	g_heap/dlmalloc.h.c	2896;"	d	file:
compute_bit2idx	g_heap/dlmalloc.h.c	2904;"	d	file:
compute_bit2idx	g_heap/dlmalloc.h.c	2912;"	d	file:
compute_bit2idx	g_heap/dlmalloc.h.c	2915;"	d	file:
compute_tree_index	g_heap/dlmalloc.h.c	2784;"	d	file:
compute_tree_index	g_heap/dlmalloc.h.c	2799;"	d	file:
compute_tree_index	g_heap/dlmalloc.h.c	2813;"	d	file:
compute_tree_index	g_heap/dlmalloc.h.c	2828;"	d	file:
conf	prefetcher.h	/^            SatCounter<3, 2, 1> conf;$/;"	m	struct:StreamPrefetcher::Entry
const_pointer	g_std/stl_galloc.h	/^        typedef const T* const_pointer;$/;"	t	class:StlGlobAlloc
const_reference	g_std/stl_galloc.h	/^        typedef const T& const_reference;$/;"	t	class:StlGlobAlloc
constraints	detailed_mem_params.h	/^        int32_t constraints[4];$/;"	m	class:MemParam
construct	g_std/stl_galloc.h	/^        void construct(_Up* __p, _Args&&... __args) { ::new((void *)__p) _Up(std::forward<_Args>(__args)...); }$/;"	f	class:StlGlobAlloc
construct	g_std/stl_galloc.h	/^        void construct(pointer p) { construct(p, value_type()); } \/\/required by gcc 4.6$/;"	f	class:StlGlobAlloc
construct	g_std/stl_galloc.h	/^        void construct(pointer p, const T& val) { new (static_cast<T*>(p)) T(val); }$/;"	f	class:StlGlobAlloc
contentionSim	zsim.h	/^    ContentionSim* contentionSim;$/;"	m	struct:GlobSimInfo
contextSwitch	filter_cache.h	/^        void contextSwitch() {$/;"	f	class:FilterCache
contextSwitch	null_core.cpp	/^void NullCore::contextSwitch(int32_t gid) {}$/;"	f	class:NullCore
contextSwitch	ooo_core.cpp	/^void OOOCore::contextSwitch(int32_t gid) {$/;"	f	class:OOOCore
contextSwitch	simple_core.cpp	/^void SimpleCore::contextSwitch(int32_t gid) {$/;"	f	class:SimpleCore
contextSwitch	timing_core.cpp	/^void TimingCore::contextSwitch(int32_t gid) {$/;"	f	class:TimingCore
contexts	scheduler.h	/^        g_vector<ContextInfo> contexts;$/;"	m	class:Scheduler
controllerLatency	detailed_mem_params.h	/^        uint32_t controllerLatency;$/;"	m	class:MemParam
controllerSysLatency	ddr_mem.h	/^        const uint32_t controllerSysLatency;  \/\/ in sysCycles$/;"	m	class:DDRMemory
copyNonSimVars	config.cpp	/^static uint32_t copyNonSimVars(libconfig::Setting& s1, libconfig::Setting& s2, std::string prefix) {$/;"	f	file:
cores	zsim.cpp	/^Core* cores[MAX_THREADS];$/;"	v
cores	zsim.h	/^    Core** cores;$/;"	m	struct:GlobSimInfo
count	breakdown_stats.h	/^        inline virtual uint64_t count(uint32_t idx) const {$/;"	f	class:CycleBreakdownStat
count	ooo_core.h	/^            uint8_t count;$/;"	m	struct:WindowStructure::WinCycle
count	prefetcher.h	/^        int32_t count;$/;"	m	class:SatCounter
count	profile_stats.h	/^        inline virtual uint64_t count(uint32_t idx) const {$/;"	f	class:TimeBreakdownStat
count	stats.h	/^        inline uint64_t count() const {$/;"	f	class:Counter
count	stats.h	/^        inline virtual uint64_t count(uint32_t idx) const {$/;"	f	class:VectorCounter
count	stats.h	/^        uint64_t count(uint32_t idx) const { \/\/dsm: Interestingly, this compiles even if f() is not const. gcc may catch this eventually...$/;"	f	class:LambdaVectorStat
counter	prefetcher.h	/^        uint32_t counter() const { return count; }$/;"	f	class:SatCounter
counterName	stats.h	/^        inline const char* counterName(uint32_t idx) const {$/;"	f	class:VectorStat
cpe	timing_event.h	/^        CrossingSrcEvent cpe;$/;"	m	class:CrossingEvent
cpuenumCpu	cpuenum.h	/^inline uint32_t cpuenumCpu(uint32_t pid, uint32_t cid) {$/;"	f
cpuenumMask	cpuenum.h	/^inline std::vector<bool> cpuenumMask(uint32_t pid) {$/;"	f
cpuenumNumCpus	cpuenum.h	/^inline uint32_t cpuenumNumCpus(uint32_t pid) {$/;"	f
cpuidEax	zsim.cpp	/^static uint32_t cpuidEax[MAX_THREADS];$/;"	v	file:
cpuidEcx	zsim.cpp	/^static uint32_t cpuidEcx[MAX_THREADS];$/;"	v	file:
cpuid_core2	cpuid.h	/^CpuIdRecord cpuid_core2[] = { \/\/ 2-socket Xeon E5335 (2x4 cores, core2 arch, 2.00GHz)$/;"	v
create_mspace	g_heap/dlmalloc.h.c	/^mspace create_mspace(size_t capacity, int locked) {$/;"	f
create_mspace_with_base	g_heap/dlmalloc.h.c	/^mspace create_mspace_with_base(void* base, size_t capacity, int locked) {$/;"	f
crossingStack	event_recorder.h	/^        CrossingStack crossingStack;$/;"	m	class:EventRecorder
ctxt	virt/common.h	/^    CONTEXT* ctxt;$/;"	m	struct:PostPatchArgs
ctxt	virt/common.h	/^    CONTEXT* ctxt;$/;"	m	struct:PrePatchArgs
curAllocs	partitioner.h	/^        uint32_t* curAllocs;$/;"	m	class:LookaheadPartitioner
curAvgPowerReport	detailed_mem_params.h	/^        bool curAvgPowerReport;$/;"	m	class:MemParam
curBlock	prio_queue.h	/^    uint64_t curBlock;$/;"	m	class:PrioQueue
curBts	part_repl_policies.h	/^            uint64_t curBts; \/\/per-partition coarse-grain timestamp (CurrentTS in paper)$/;"	m	struct:VantageReplPolicy::VantagePartInfo
curBtsHits	part_repl_policies.h	/^            uint32_t curBtsHits; \/\/hits on current timestamp (AccessCounter in paper)$/;"	m	struct:VantageReplPolicy::VantagePartInfo
curChildren	process_tree.h	/^        volatile uint32_t curChildren;$/;"	m	class:ProcessTreeNode
curCycle	contention_sim.h	/^            volatile uint64_t curCycle;$/;"	m	struct:ContentionSim::DomainData
curCycle	dramsim_mem_ctrl.h	/^        uint64_t curCycle; \/\/processor cycle, used in callbacks$/;"	m	class:DRAMSimMemory
curCycle	null_core.h	/^        uint64_t curCycle;$/;"	m	class:NullCore
curCycle	ooo_core.h	/^        uint64_t curCycle; \/\/this model is issue-centric; curCycle refers to the current issue cycle$/;"	m	class:OOOCore
curCycle	simple_core.h	/^        uint64_t curCycle;$/;"	m	class:SimpleCore
curCycle	timing_core.h	/^        uint64_t curCycle; \/\/phase 1 clock$/;"	m	class:TimingCore
curCycleIssuedUops	ooo_core.h	/^        uint32_t curCycleIssuedUops; \/\/for uop issue limits$/;"	m	class:OOOCore
curCycleRFReads	ooo_core.h	/^        uint32_t curCycleRFReads; \/\/for RF read stalls$/;"	m	class:OOOCore
curCycleRetires	ooo_core.h	/^        uint32_t curCycleRetires;$/;"	m	class:ReorderBuffer
curId	ooo_core_recorder.h	/^        uint64_t curId;$/;"	m	class:OOOCoreRecorder
curIntervalCands	part_repl_policies.h	/^            uint32_t curIntervalCands; \/\/ CandsSeen in paper$/;"	m	struct:VantageReplPolicy::VantagePartInfo
curIntervalDems	part_repl_policies.h	/^            uint32_t curIntervalDems; \/\/ CandsDemoted in paper$/;"	m	struct:VantageReplPolicy::VantagePartInfo
curIntervalIns	part_repl_policies.h	/^            uint32_t curIntervalIns; \/\/ insertions in current interval. Not currently used.$/;"	m	struct:VantageReplPolicy::VantagePartInfo
curLatency	mem_ctrls.h	/^        uint32_t curLatency;$/;"	m	class:MD1Memory
curMisses	utility_monitor.h	/^        uint64_t curMisses;$/;"	m	class:UMon
curPhase	scheduler.h	/^        uint64_t curPhase;$/;"	m	class:Scheduler
curPhaseAccesses	mem_ctrls.h	/^        uint32_t curPhaseAccesses;$/;"	m	class:MD1Memory
curPhaseList	phase_slab_alloc.h	/^        SlabList curPhaseList;$/;"	m	class:PhaseSlabAlloc
curPos	ooo_core.h	/^        uint32_t curPos;$/;"	m	class:WindowStructure
curPtr	hdf5_stats.cpp	/^        uint64_t* curPtr; \/\/points to next element to write in dump$/;"	m	class:HDF5BackendImpl	file:
curRetireCycle	ooo_core.h	/^        uint64_t curRetireCycle;$/;"	m	class:ReorderBuffer
curRowHits	ddr_mem.h	/^            uint64_t curRowHits;    \/\/ row hits on the currently opened row$/;"	m	struct:DDRMemory::Bank
curSlab	phase_slab_alloc.h	/^        Slab* curSlab;$/;"	m	class:PhaseSlabAlloc
curState	breakdown_stats.h	/^        uint32_t curState;$/;"	m	class:CycleBreakdownStat
curState	profile_stats.h	/^        uint32_t curState;$/;"	m	class:TimeBreakdownStat
curThread	scheduler.h	/^            ThreadInfo* curThread; \/\/only current if used, otherwise NULL$/;"	m	struct:Scheduler::ContextInfo
curThreadIdx	barrier.h	/^        uint32_t curThreadIdx;$/;"	m	class:Barrier
curWayHits	utility_monitor.h	/^        uint64_t* curWayHits;$/;"	m	class:UMon
curWin	ooo_core.h	/^        WinCycle* curWin;$/;"	m	class:WindowStructure
cycle	contention_sim.h	/^            uint64_t cycle;$/;"	m	struct:ContentionSim::CrossingEventInfo
cycle	memory_hierarchy.h	/^    uint64_t cycle; \/\/cycle where request arrives at component$/;"	m	struct:MemReq
cycle	timing_event.h	/^        uint64_t cycle;$/;"	m	class:TimingEvent
cyclesToNs	virt/time_conv.h	/^static inline uint64_t cyclesToNs(uint64_t cycles) {$/;"	f
dataAddr	debug.h	/^    void* dataAddr;$/;"	m	struct:LibInfo
dataBuf	hdf5_stats.cpp	/^        uint64_t* dataBuf; \/\/buffered record data$/;"	m	class:HDF5BackendImpl	file:
dataBusWidth	detailed_mem_params.h	/^        uint32_t dataBusWidth;$/;"	m	class:MemParam
deallocate	g_std/stl_galloc.h	/^        void deallocate(void* p, size_type) {$/;"	f	class:StlGlobAlloc
debugSigHandler	zsim_harness.cpp	/^void debugSigHandler(int signum, siginfo_t* siginfo, void* dummy) {$/;"	f
debuggerChildIdx	zsim_harness.cpp	/^volatile uint32_t debuggerChildIdx = MAX_THREADS;$/;"	v
dec	ddr_mem.h	/^        inline uint32_t dec(uint32_t i) const { return i? i-1 : buf.size()-1; }$/;"	f	class:ActWindow
dec	prefetcher.h	/^        void dec() { count = MAX(count - 1, 0); }$/;"	f	class:SatCounter
decCycle	decoder.h	/^    uint16_t decCycle;$/;"	m	struct:DynUop
decodeBbl	decoder.cpp	/^BblInfo* Decoder::decodeBbl(BBL bbl, bool oooDecoding) {$/;"	f	class:Decoder
decodeCycle	ooo_core.h	/^        uint64_t decodeCycle;$/;"	m	class:OOOCore
decodeFusedInstrs	decoder.cpp	/^bool Decoder::decodeFusedInstrs(INS ins, DynUopVec& uops) {$/;"	f	class:Decoder
decodeInstr	decoder.cpp	/^bool Decoder::decodeInstr(INS ins, DynUopVec& uops) {$/;"	f	class:Decoder
deduplicateH5Type	hdf5_stats.cpp	/^        hid_t deduplicateH5Type(hid_t type) {$/;"	f	class:HDF5BackendImpl	file:
default_mflags	g_heap/dlmalloc.h.c	/^  flag_t default_mflags;$/;"	m	struct:malloc_params	file:
deferredWrites	ddr_mem.h	/^        const bool deferredWrites;$/;"	m	class:DDRMemory
delayMap	network.h	/^        std::unordered_map<std::string, uint32_t> delayMap;$/;"	m	class:Network
dequeue	prio_queue.h	/^        T* dequeue(uint64_t& deqCycle) {$/;"	f	class:PrioQueue
dequeue	prio_queue.h	/^        inline T* dequeue(uint32_t& offset) {$/;"	f	struct:PrioQueue::PQBlock
desc	stats.h	/^        const char* desc() const {$/;"	f	class:Stat
deschedule	scheduler.h	/^        void deschedule(ThreadInfo* th, ContextInfo* ctx, ThreadState targetState) {$/;"	f	class:Scheduler
destroy	g_std/stl_galloc.h	/^        template<typename _Up> void destroy(_Up* __p) { __p->~_Up(); }$/;"	f	class:StlGlobAlloc
destroy	g_std/stl_galloc.h	/^        void destroy(pointer p) { p->~T(); }$/;"	f	class:StlGlobAlloc
destroy_mspace	g_heap/dlmalloc.h.c	/^size_t destroy_mspace(mspace msp) {$/;"	f
dev_zero_fd	g_heap/dlmalloc.h.c	/^static int dev_zero_fd = -1; \/* Cached file descriptor for \/dev\/zero. *\/$/;"	v	file:
difference_type	g_std/stl_galloc.h	/^        typedef ptrdiff_t difference_type;$/;"	t	class:StlGlobAlloc
disable_contiguous	g_heap/dlmalloc.h.c	2610;"	d	file:
disable_lock	g_heap/dlmalloc.h.c	2603;"	d	file:
disable_mmap	g_heap/dlmalloc.h.c	2607;"	d	file:
dlcalloc	g_heap/dlmalloc.h.c	/^void* dlcalloc(size_t n_elements, size_t elem_size) {$/;"	f
dlcalloc	g_heap/dlmalloc.h.c	810;"	d	file:
dlfree	g_heap/dlmalloc.h.c	/^void dlfree(void* mem) {$/;"	f
dlfree	g_heap/dlmalloc.h.c	811;"	d	file:
dlindependent_calloc	g_heap/dlmalloc.h.c	/^void** dlindependent_calloc(size_t n_elements, size_t elem_size,$/;"	f
dlindependent_calloc	g_heap/dlmalloc.h.c	824;"	d	file:
dlindependent_comalloc	g_heap/dlmalloc.h.c	/^void** dlindependent_comalloc(size_t n_elements, size_t sizes[],$/;"	f
dlindependent_comalloc	g_heap/dlmalloc.h.c	825;"	d	file:
dlmallinfo	g_heap/dlmalloc.h.c	/^struct mallinfo dlmallinfo(void) {$/;"	f
dlmallinfo	g_heap/dlmalloc.h.c	817;"	d	file:
dlmalloc	g_heap/dlmalloc.h.c	/^void* dlmalloc(size_t bytes) {$/;"	f
dlmalloc	g_heap/dlmalloc.h.c	812;"	d	file:
dlmalloc_footprint	g_heap/dlmalloc.h.c	/^size_t dlmalloc_footprint(void) {$/;"	f
dlmalloc_footprint	g_heap/dlmalloc.h.c	822;"	d	file:
dlmalloc_max_footprint	g_heap/dlmalloc.h.c	/^size_t dlmalloc_max_footprint(void) {$/;"	f
dlmalloc_max_footprint	g_heap/dlmalloc.h.c	823;"	d	file:
dlmalloc_stats	g_heap/dlmalloc.h.c	/^void dlmalloc_stats() {$/;"	f
dlmalloc_stats	g_heap/dlmalloc.h.c	820;"	d	file:
dlmalloc_trim	g_heap/dlmalloc.h.c	/^int dlmalloc_trim(size_t pad) {$/;"	f
dlmalloc_trim	g_heap/dlmalloc.h.c	819;"	d	file:
dlmalloc_usable_size	g_heap/dlmalloc.h.c	/^size_t dlmalloc_usable_size(void* mem) {$/;"	f
dlmalloc_usable_size	g_heap/dlmalloc.h.c	821;"	d	file:
dlmallopt	g_heap/dlmalloc.h.c	/^int dlmallopt(int param_number, int value) {$/;"	f
dlmallopt	g_heap/dlmalloc.h.c	818;"	d	file:
dlmemalign	g_heap/dlmalloc.h.c	/^void* dlmemalign(size_t alignment, size_t bytes) {$/;"	f
dlmemalign	g_heap/dlmalloc.h.c	813;"	d	file:
dlpvalloc	g_heap/dlmalloc.h.c	/^void* dlpvalloc(size_t bytes) {$/;"	f
dlpvalloc	g_heap/dlmalloc.h.c	816;"	d	file:
dlrealloc	g_heap/dlmalloc.h.c	/^void* dlrealloc(void* oldmem, size_t bytes) {$/;"	f
dlrealloc	g_heap/dlmalloc.h.c	814;"	d	file:
dlvalloc	g_heap/dlmalloc.h.c	/^void* dlvalloc(size_t bytes) {$/;"	f
dlvalloc	g_heap/dlmalloc.h.c	815;"	d	file:
do_check_any_chunk	g_heap/dlmalloc.h.c	/^static void do_check_any_chunk(mstate m, mchunkptr p) {$/;"	f	file:
do_check_free_chunk	g_heap/dlmalloc.h.c	/^static void do_check_free_chunk(mstate m, mchunkptr p) {$/;"	f	file:
do_check_inuse_chunk	g_heap/dlmalloc.h.c	/^static void do_check_inuse_chunk(mstate m, mchunkptr p) {$/;"	f	file:
do_check_malloc_state	g_heap/dlmalloc.h.c	/^static void do_check_malloc_state(mstate m) {$/;"	f	file:
do_check_malloced_chunk	g_heap/dlmalloc.h.c	/^static void do_check_malloced_chunk(mstate m, void* mem, size_t s) {$/;"	f	file:
do_check_mmapped_chunk	g_heap/dlmalloc.h.c	/^static void do_check_mmapped_chunk(mstate m, mchunkptr p) {$/;"	f	file:
do_check_smallbin	g_heap/dlmalloc.h.c	/^static void do_check_smallbin(mstate m, bindex_t i) {$/;"	f	file:
do_check_top_chunk	g_heap/dlmalloc.h.c	/^static void do_check_top_chunk(mstate m, mchunkptr p) {$/;"	f	file:
do_check_tree	g_heap/dlmalloc.h.c	/^static void do_check_tree(mstate m, tchunkptr t) {$/;"	f	file:
do_check_treebin	g_heap/dlmalloc.h.c	/^static void do_check_treebin(mstate m, bindex_t i) {$/;"	f	file:
domain	core_recorder.h	/^        uint32_t domain;$/;"	m	class:CoreRecorder
domain	ddr_mem.h	/^        const uint32_t domain;$/;"	m	class:DDRMemory
domain	detailed_mem.h	/^        uint32_t domain;$/;"	m	class:MemControllerBase
domain	dramsim_mem_ctrl.h	/^        uint32_t domain;$/;"	m	class:DRAMSimMemory
domain	ooo_core_recorder.h	/^        uint32_t domain;$/;"	m	class:OOOCoreRecorder
domain	timing_cache.h	/^        uint32_t domain;$/;"	m	class:TimingCache
domain	timing_event.h	/^        int32_t domain; \/\/-1 if none; if none, it acquires it from the parent. Cannot be a starting event (no parents at enqueue time) and get -1 as domain$/;"	m	class:TimingEvent
domain	weave_md1_mem.h	/^        const uint32_t domain;$/;"	m	class:WeaveMD1Memory
domain	weave_md1_mem.h	/^        uint32_t domain;$/;"	m	class:WeaveSimpleMemory
domains	contention_sim.h	/^        DomainData* domains;$/;"	m	class:ContentionSim
done	timing_event.h	/^        void done(uint64_t doneCycle) {$/;"	f	class:TimingEvent
doneCycle	timing_event.h	/^        volatile uint64_t doneCycle;$/;"	m	class:CrossingEvent
dq	detailed_mem.h	/^            uint64_t dq;$/;"	m	struct:MemControllerBase::powerValue
dram	detailed_mem.h	/^        MemControllerBase* dram;$/;"	m	class:MemAccessEventBase
dram	dramsim_mem_ctrl.cpp	/^        DRAMSimMemory* dram;$/;"	m	class:DRAMSimAccEvent	file:
dramCore	dramsim_mem_ctrl.h	/^        DRAMSim::MultiChannelMemorySystem* dramCore;$/;"	m	class:DRAMSimMemory
dropRegister	decoder.cpp	/^static bool dropRegister(uint32_t targetReg, uint32_t* regs, uint32_t& numRegs) {$/;"	f	file:
dropStackRegister	decoder.cpp	/^void Decoder::dropStackRegister(Instr& instr) {$/;"	f	class:Decoder
dump	hdf5_stats.cpp	/^        void dump(bool buffered) {$/;"	f	class:HDF5BackendImpl
dump	hdf5_stats.cpp	/^void HDF5Backend::dump(bool buffered) {$/;"	f	class:HDF5Backend
dump	text_stats.cpp	/^        void dump(bool buffered) {$/;"	f	class:TextBackendImpl
dump	text_stats.cpp	/^void TextBackend::dump(bool buffered) {$/;"	f	class:TextBackend
dumpBblProfile	decoder.cpp	/^void Decoder::dumpBblProfile() {$/;"	f	class:Decoder
dumpHeartbeats	process_tree.h	/^        const uint64_t dumpHeartbeats;$/;"	m	class:ProcessTreeNode
dumpStat	text_stats.cpp	/^        void dumpStat(Stat* s, uint32_t level, std::ofstream* out) {$/;"	f	class:TextBackendImpl	file:
dumpWalk	hdf5_stats.cpp	/^        void dumpWalk(Stat* s) {$/;"	f	class:HDF5BackendImpl	file:
dumpsResetHeartbeats	process_tree.h	/^        const bool dumpsResetHeartbeats;$/;"	m	class:ProcessTreeNode
dv	g_heap/dlmalloc.h.c	/^  mchunkptr  dv;$/;"	m	struct:malloc_state	file:
dvsize	g_heap/dlmalloc.h.c	/^  size_t     dvsize;$/;"	m	struct:malloc_state	file:
e	cache_arrays.h	/^    ZWalkInfo* e;$/;"	m	struct:ZCands
e	cache_arrays.h	/^    uint32_t b, e;$/;"	m	struct:SetAssocCands
eRowBufferPolicy	detailed_mem_params.h	/^        enum eRowBufferPolicy {$/;"	g	class:MemParam
eax	cpuid.h	/^    unsigned eax, ebx, ecx, edx;$/;"	m	struct:CpuIdRecord
eaxIn	cpuid.h	/^    unsigned eaxIn;$/;"	m	struct:CpuIdRecord
ebx	cpuid.h	/^    unsigned eax, ebx, ecx, edx;$/;"	m	struct:CpuIdRecord
ecx	cpuid.h	/^    unsigned eax, ebx, ecx, edx;$/;"	m	struct:CpuIdRecord
ecxIn	cpuid.h	/^    unsigned ecxIn;$/;"	m	struct:CpuIdRecord
edx	cpuid.h	/^    unsigned eax, ebx, ecx, edx;$/;"	m	struct:CpuIdRecord
elem	ddr_mem.h	/^            T elem;$/;"	m	struct:RequestQueue::Node
elems	intrusive_list.h	/^        size_t elems;$/;"	m	class:InList
elems	prio_queue.h	/^    uint64_t elems;$/;"	m	class:PrioQueue
emitBasicMove	decoder.cpp	/^void Decoder::emitBasicMove(Instr& instr, DynUopVec& uops, uint32_t lat, uint8_t ports) {$/;"	f	class:Decoder
emitBasicOp	decoder.cpp	/^void Decoder::emitBasicOp(Instr& instr, DynUopVec& uops, uint32_t lat, uint8_t ports, uint8_t extraSlots, bool reportUnhandled) {$/;"	f	class:Decoder
emitChainedOp	decoder.cpp	/^void Decoder::emitChainedOp(Instr& instr, DynUopVec& uops, uint32_t numUops, uint32_t* latArray, uint8_t* portsArray) {$/;"	f	class:Decoder
emitCompareAndExchange	decoder.cpp	/^void Decoder::emitCompareAndExchange(Instr& instr, DynUopVec& uops) {$/;"	f	class:Decoder
emitConditionalMove	decoder.cpp	/^void Decoder::emitConditionalMove(Instr& instr, DynUopVec& uops, uint32_t lat, uint8_t ports) {$/;"	f	class:Decoder
emitConvert2Op	decoder.cpp	/^void Decoder::emitConvert2Op(Instr& instr, DynUopVec& uops, uint32_t lat1, uint32_t lat2, uint8_t ports1, uint8_t ports2) {$/;"	f	class:Decoder
emitDiv	decoder.cpp	/^void Decoder::emitDiv(Instr& instr, DynUopVec& uops) {$/;"	f	class:Decoder
emitExecUop	decoder.cpp	/^void Decoder::emitExecUop(uint32_t rs0, uint32_t rs1, uint32_t rd0, uint32_t rd1, DynUopVec& uops, uint32_t lat, uint8_t ports, uint8_t extraSlots) {$/;"	f	class:Decoder
emitFence	decoder.cpp	/^void Decoder::emitFence(DynUopVec& uops, uint32_t lat) {$/;"	f	class:Decoder
emitLoad	decoder.cpp	/^void Decoder::emitLoad(Instr& instr, uint32_t idx, DynUopVec& uops, uint32_t destReg) {$/;"	f	class:Decoder
emitLoads	decoder.cpp	/^void Decoder::emitLoads(Instr& instr, DynUopVec& uops) {$/;"	f	class:Decoder
emitMul	decoder.cpp	/^void Decoder::emitMul(Instr& instr, DynUopVec& uops) {$/;"	f	class:Decoder
emitStore	decoder.cpp	/^void Decoder::emitStore(Instr& instr, uint32_t idx, DynUopVec& uops, uint32_t srcReg) {$/;"	f	class:Decoder
emitStores	decoder.cpp	/^void Decoder::emitStores(Instr& instr, DynUopVec& uops) {$/;"	f	class:Decoder
emitXchg	decoder.cpp	/^void Decoder::emitXchg(Instr& instr, DynUopVec& uops) {$/;"	f	class:Decoder
empty	ddr_mem.h	/^        inline bool empty() const { return reqList.empty(); }$/;"	f	class:RequestQueue
empty	intrusive_list.h	/^        bool empty() const {return !head;}$/;"	f	class:InList
empty	phase_slab_alloc.h	/^            bool empty() const {$/;"	f	class:PhaseSlabAlloc::SlabList
enable_lock	g_heap/dlmalloc.h.c	2602;"	d	file:
enable_mmap	g_heap/dlmalloc.h.c	2606;"	d	file:
end	cache_arrays.h	/^    inline iterator end() const {return iterator(e);}$/;"	f	struct:SetAssocCands
end	cache_arrays.h	/^    inline iterator end() const {return iterator(e);}$/;"	f	struct:ZCands
end	ddr_mem.h	/^        inline iterator end() const {return iterator(NULL);}$/;"	f	class:RequestQueue
end	phase_slab_alloc.h	/^                Slab* end;$/;"	m	class:PhaseSlabAlloc::SlabList
end	profile_stats.h	/^        void end() {$/;"	f	class:ClockStat
end	zsim.cpp	/^    uintptr_t end;$/;"	m	struct:Section	file:
endAccess	coherence_ctrls.h	/^        void endAccess(const MemReq& req) {$/;"	f	class:MESICC
endAccess	coherence_ctrls.h	/^        void endAccess(const MemReq& req) {$/;"	f	class:MESITerminalCC
endEvent	event_recorder.h	/^    TimingEvent* endEvent;$/;"	m	struct:TimingRecord
enqueue	contention_sim.cpp	/^void ContentionSim::enqueue(TimingEvent* ev, uint64_t cycle) {$/;"	f	class:ContentionSim
enqueue	ddr_mem.cpp	/^        void enqueue(uint64_t cycle) {$/;"	f	class:SchedEvent
enqueue	ddr_mem.cpp	/^void DDRMemory::enqueue(DDRMemoryAccEvent* ev, uint64_t sysCycle) {$/;"	f	class:DDRMemory
enqueue	detailed_mem.cpp	/^void MemControllerBase::enqueue(MemAccessEventBase* ev, uint64_t cycle) {$/;"	f	class:MemControllerBase
enqueue	dramsim_mem_ctrl.cpp	/^void DRAMSimMemory::enqueue(DRAMSimAccEvent* ev, uint64_t cycle) { panic("???"); }$/;"	f	class:DRAMSimMemory
enqueue	dramsim_mem_ctrl.cpp	/^void DRAMSimMemory::enqueue(DRAMSimAccEvent* ev, uint64_t cycle) {$/;"	f	class:DRAMSimMemory
enqueue	prio_queue.h	/^        inline void enqueue(T* obj, uint32_t pos) {$/;"	f	struct:PrioQueue::PQBlock
enqueue	prio_queue.h	/^        void enqueue(T* obj, uint64_t cycle) {$/;"	f	class:PrioQueue
enqueueCrossing	contention_sim.cpp	/^void ContentionSim::enqueueCrossing(CrossingEvent* ev, uint64_t cycle, uint32_t srcId, uint32_t srcDomain, uint32_t dstDomain, EventRecorder* evRec) {$/;"	f	class:ContentionSim
enqueueSynced	contention_sim.cpp	/^void ContentionSim::enqueueSynced(TimingEvent* ev, uint64_t cycle) {$/;"	f	class:ContentionSim
ensure_initialization	g_heap/dlmalloc.h.c	2584;"	d	file:
enterFastForward	process_tree.cpp	/^void ProcessTreeNode::enterFastForward() {$/;"	f	class:ProcessTreeNode
env	pin_cmd.h	/^            g_string env;$/;"	m	struct:PinCmd::ProcCmdInfo
eraseChild	zsim_harness.cpp	/^int eraseChild(int pid) {$/;"	f
ev	contention_sim.h	/^            CrossingEvent* ev; \/\/only valid if the source's curCycle < cycle (otherwise this may be already executed or recycled)$/;"	m	struct:ContentionSim::CrossingEventInfo
ev	ddr_mem.h	/^            DDRMemoryAccEvent* ev;$/;"	m	struct:DDRMemory::Request
evMap	event_queue.h	/^        g_multimap<uint64_t, Event*> evMap;$/;"	m	class:EventQueue
evRec	timing_event.h	/^        EventRecorder* evRec;$/;"	m	class:CrossingEvent
eventFreelist	ddr_mem.h	/^        SchedEvent* eventFreelist;$/;"	m	class:DDRMemory
eventQueue	zsim.h	/^    EventQueue* eventQueue;$/;"	m	struct:GlobSimInfo
eventRecorder	core_recorder.h	/^        EventRecorder eventRecorder;$/;"	m	class:CoreRecorder
eventRecorder	ooo_core_recorder.h	/^        EventRecorder eventRecorder;$/;"	m	class:OOOCoreRecorder
eventRecorders	zsim.h	/^    EventRecorder** eventRecorders; \/\/CID->EventRecorder* array$/;"	m	struct:GlobSimInfo
events	timing_event.h	/^    TimingEvent* events[TIMING_BLOCK_EVENTS];$/;"	m	struct:TimingEventBlock
eventualStatsBackend	zsim.h	/^    StatsBackend* eventualStatsBackend;$/;"	m	struct:GlobSimInfo
exclusive	coherence_ctrls.h	/^            bool exclusive;$/;"	m	struct:MESITopCC::Entry
exists	config.cpp	/^bool Config::exists(const char* key) {$/;"	f	class:Config
exists	config.h	/^        bool exists(const std::string& key) {return exists(key.c_str());}$/;"	f	class:Config
exitFastForward	process_tree.cpp	/^void ProcessTreeNode::exitFastForward() {$/;"	f	class:ProcessTreeNode
exitHandler	zsim_harness.cpp	/^void exitHandler() {$/;"	f
exitPause	process_tree.h	/^        void exitPause() {$/;"	f	class:ProcessTreeNode
extendedSize	part_repl_policies.h	/^            uint64_t extendedSize;$/;"	m	struct:VantageReplPolicy::VantagePartInfo
externalTermPending	zsim.h	/^    volatile bool externalTermPending;$/;"	m	struct:GlobSimInfo
extp	g_heap/dlmalloc.h.c	/^  void*      extp;      \/* Unused but available for extensions *\/$/;"	m	struct:malloc_state	file:
extraSlots	decoder.h	/^    uint8_t extraSlots; \/\/FU exec slots$/;"	m	struct:DynUop
exts	g_heap/dlmalloc.h.c	/^  size_t     exts;$/;"	m	struct:malloc_state	file:
f	stats.h	/^        F f;$/;"	m	class:LambdaStat
f	stats.h	/^        F f;$/;"	m	class:LambdaVectorStat
fGETSHit	filter_cache.h	/^        uint64_t fGETSHit, fGETXHit;$/;"	m	class:FilterCache
fGETXHit	filter_cache.h	/^        uint64_t fGETSHit, fGETXHit;$/;"	m	class:FilterCache
fakeLeave	scheduler.h	/^            FakeLeaveInfo* fakeLeave; \/\/ for accurate join-leaves, see below$/;"	m	struct:Scheduler::ThreadInfo
fakeLeaves	scheduler.h	/^        InList<FakeLeaveInfo> fakeLeaves;$/;"	m	class:Scheduler
fakeTimeouts	virt/timeout.cpp	/^static struct timespec fakeTimeouts[MAX_THREADS]; \/\/for syscalls that use timespec to indicate a timeout$/;"	v	typeref:struct:timespec	file:
fakedPaths	virt/fs.cpp	/^static const char* fakedPaths[] = {"\/proc\/cpuinfo", "\/proc\/stat", "\/sys"};$/;"	v	file:
fd	g_heap/dlmalloc.h.c	/^  struct malloc_chunk* fd;         \/* double links -- used only if free. *\/$/;"	m	struct:malloc_chunk	typeref:struct:malloc_chunk::malloc_chunk	file:
fd	g_heap/dlmalloc.h.c	/^  struct malloc_tree_chunk* fd;$/;"	m	struct:malloc_tree_chunk	typeref:struct:malloc_tree_chunk::malloc_tree_chunk	file:
feMap	prio_queue.h	/^    FEMap feMap;$/;"	m	class:PrioQueue
ffLock	zsim.h	/^    lock_t ffLock; \/\/global, grabbed in all ff entry\/exit ops.$/;"	m	struct:GlobSimInfo
ffPtrs	zsim.cpp	/^static const InstrFuncPtrs ffPtrs = {NOPLoadStoreSingle, NOPLoadStoreSingle, FFBasicBlock, NOPRecordBranch, NOPPredLoadStoreSingle, NOPPredLoadStoreSingle, FPTR_NOP};$/;"	v	file:
ffReinstrument	zsim.h	/^    bool ffReinstrument; \/\/true if we should reinstrument on ffwd, works fine with ST apps and it's faster since we run with basically no instrumentation, but it's not precise with MT apps$/;"	m	struct:GlobSimInfo
ffToggleLocks	zsim.h	/^    lock_t ffToggleLocks[256]; \/\/f*ing Pin and its f*ing inability to handle external signals...$/;"	m	struct:GlobSimInfo
ffiEnabled	zsim.cpp	/^static bool ffiEnabled;$/;"	v	file:
ffiEntryPtrs	zsim.cpp	/^static const InstrFuncPtrs ffiEntryPtrs = {NOPLoadStoreSingle, NOPLoadStoreSingle, FFIEntryBasicBlock, NOPRecordBranch, NOPPredLoadStoreSingle, NOPPredLoadStoreSingle, FPTR_NOP};$/;"	v	file:
ffiFFStartInstrs	zsim.cpp	/^static uint64_t* ffiFFStartInstrs; \/\/hack, needs to be a pointer, written to outside this process$/;"	v	file:
ffiInstrsDone	zsim.cpp	/^static uint64_t ffiInstrsDone;$/;"	v	file:
ffiInstrsLimit	zsim.cpp	/^static uint64_t ffiInstrsLimit;$/;"	v	file:
ffiNFF	zsim.cpp	/^static bool ffiNFF;$/;"	v	file:
ffiPoint	zsim.cpp	/^static uint32_t ffiPoint;$/;"	v	file:
ffiPoints	process_tree.h	/^        const g_vector<uint64_t> ffiPoints;$/;"	m	class:ProcessTreeNode
ffiPrevFFStartInstrs	zsim.cpp	/^static uint64_t* ffiPrevFFStartInstrs;$/;"	v	file:
ffiPtrs	zsim.cpp	/^static const InstrFuncPtrs ffiPtrs = {NOPLoadStoreSingle, NOPLoadStoreSingle, FFIBasicBlock, NOPRecordBranch, NOPPredLoadStoreSingle, NOPPredLoadStoreSingle, FPTR_NOP};$/;"	v	file:
filename	hdf5_stats.cpp	/^        const char* filename;$/;"	m	class:HDF5BackendImpl	file:
filename	text_stats.cpp	/^        const char* filename;$/;"	m	class:TextBackendImpl	file:
fill	config.cpp	/^    void fill(vector<bool>& mask) {$/;"	f	struct:Range
fill	prefetcher.h	/^                void fill(uint32_t s, uint64_t r) { startCycle = s; respCycle = r; }$/;"	f	struct:StreamPrefetcher::Entry::AccessTimes
filterArray	filter_cache.h	/^        FilterEntry* filterArray;$/;"	m	class:FilterCache
filterLock	filter_cache.h	/^        lock_t filterLock;$/;"	m	class:FilterCache
findMinCmdCycle	ddr_mem.cpp	/^uint64_t DDRMemory::findMinCmdCycle(const Request& r) const {$/;"	f	class:DDRMemory
finish	contention_sim.cpp	/^void ContentionSim::finish() {$/;"	f	class:ContentionSim
finish	detailed_mem.cpp	/^void MemControllerBase::finish(void) {$/;"	f	class:MemControllerBase
finish	scheduler.h	/^        void finish(uint32_t pid, uint32_t tid) {$/;"	f	class:Scheduler
finishFakeLeave	scheduler.cpp	/^void Scheduler::finishFakeLeave(ThreadInfo* th) {$/;"	f	class:Scheduler
fire	event_queue.h	/^        F fire;$/;"	m	class:AdaptiveEvent
firstCycle	prio_queue.h	/^        inline uint64_t firstCycle() const {$/;"	f	class:PrioQueue
firstDomain	contention_sim.h	/^            uint32_t firstDomain;$/;"	m	struct:ContentionSim::SimThreadData
flag_t	g_heap/dlmalloc.h.c	/^typedef unsigned int flag_t;           \/* The type of various bit flag sets *\/$/;"	t	file:
flags	memory_hierarchy.h	/^    uint32_t flags;$/;"	m	struct:MemReq
fm	g_heap/dlmalloc.h.c	4928;"	d	file:
footprint	g_heap/dlmalloc.h.c	/^  size_t     footprint;$/;"	m	struct:malloc_state	file:
forbidden	partitioner.h	/^        bool* forbidden;$/;"	m	class:Partitioner
fordblks	g_heap/dlmalloc.h.c	/^  MALLINFO_FIELD_TYPE fordblks; \/* total free space *\/$/;"	m	struct:mallinfo	file:
forkedChildNode	zsim.cpp	/^static ProcessTreeNode* forkedChildNode = NULL;$/;"	v	file:
freeList	ddr_mem.h	/^        InList<Node> freeList; \/\/ LIFO (higher locality)$/;"	m	class:RequestQueue
freeList	phase_slab_alloc.h	/^        SlabList freeList;$/;"	m	class:PhaseSlabAlloc
freeList	scheduler.h	/^        InList<ContextInfo> freeList;$/;"	m	class:Scheduler
freqMHz	zsim.h	/^    uint32_t freqMHz;$/;"	m	struct:GlobSimInfo
front	intrusive_list.h	/^        T* front() const {return head;}$/;"	f	class:InList
fsmblks	g_heap/dlmalloc.h.c	/^  MALLINFO_FIELD_TYPE fsmblks;  \/* always 0 *\/$/;"	m	struct:mallinfo	file:
full	ddr_mem.h	/^        inline bool full() const { return freeList.empty(); }$/;"	f	class:RequestQueue
func	zsim.cpp	/^    VdsoFunc func;$/;"	m	struct:VdsoPatchData	file:
futexJoin	scheduler.h	/^            FutexJoinInfo futexJoin;$/;"	m	struct:Scheduler::ThreadInfo
futexWaitJoin	scheduler.cpp	/^void Scheduler::futexWaitJoin(ThreadInfo* th) {$/;"	f	class:Scheduler
futexWakeJoin	scheduler.cpp	/^void Scheduler::futexWakeJoin(ThreadInfo* th) {  \/\/ may release schedLock$/;"	f	class:Scheduler
futexWord	barrier.h	/^            volatile uint32_t futexWord;$/;"	m	struct:Barrier::ThreadSyncInfo
futexWord	scheduler.h	/^            volatile uint32_t futexWord;$/;"	m	struct:Scheduler::ThreadInfo
futex_haswaiters	locks.h	/^static inline bool futex_haswaiters(volatile uint32_t* lock) {$/;"	f
futex_init	locks.h	/^static inline void futex_init(volatile uint32_t* lock) {$/;"	f
futex_lock	locks.h	/^static inline void futex_lock(volatile uint32_t* lock) {$/;"	f
futex_lock_nospin	locks.h	/^static inline void futex_lock_nospin(volatile uint32_t* lock) {$/;"	f
futex_trylock_nospin_timeout	locks.h	/^static inline bool futex_trylock_nospin_timeout(volatile uint32_t* lock, uint64_t timeoutNs) {$/;"	f
futex_unlock	locks.h	/^static inline void futex_unlock(volatile uint32_t* lock) {$/;"	f
futureResponses	ooo_core_recorder.h	/^        std::priority_queue<OOORespEvent*, g_vector<OOORespEvent*>, CompareRespEvents> futureResponses;$/;"	m	class:OOOCoreRecorder
fwdArray	ooo_core.h	/^        FwdEntry fwdArray[FWD_ENTRIES];$/;"	m	class:OOOCore
g_list	g_std/g_list.h	/^template <typename T> class g_list : public std::list<T, StlGlobAlloc<T> > {};$/;"	c
g_map	g_std/g_multimap.h	/^template <typename K, typename V> class g_map : public std::map<K, V, std::less<K>, StlGlobAlloc<std::pair<const K, V> > > {};$/;"	c
g_multimap	g_std/g_multimap.h	/^template <typename K, typename V> class g_multimap : public std::multimap<K, V, std::less<K>, StlGlobAlloc<std::pair<const K, V> > > {};$/;"	c
g_string	g_std/g_string.h	/^typedef std::basic_string<char, std::char_traits<char>, StlGlobAlloc<char> > g_string;$/;"	t
g_unordered_map	g_std/g_unordered_map.h	/^template <typename K, typename V> class g_unordered_map : public std::unordered_map<K, V, std::hash<K>, std::equal_to<K>, StlGlobAlloc<std::pair<const K, V> > > {};$/;"	c
g_unordered_set	g_std/g_unordered_set.h	/^template <typename K> class g_unordered_set : public std::unordered_set<K, std::hash<K>, std::equal_to<K>, StlGlobAlloc<K> > {};$/;"	c
g_vector	g_std/g_vector.h	/^        g_vector(const std::vector<T>& v) {$/;"	f	class:g_vector
g_vector	g_std/g_vector.h	/^        g_vector(size_t n, const T& t = T()) : std::vector<T, StlGlobAlloc<T>>(n, t) {}$/;"	f	class:g_vector
g_vector	g_std/g_vector.h	/^        g_vector(std::initializer_list<T> list) : std::vector<T, StlGlobAlloc<T>>(list) {}$/;"	f	class:g_vector
g_vector	g_std/g_vector.h	/^template <typename T> class g_vector : public std::vector<T, StlGlobAlloc<T> >, public GlobAlloc {$/;"	c
gapCycles	core_recorder.h	/^        uint64_t gapCycles; \/\/phase 2 clock == curCycle - gapCycles$/;"	m	class:CoreRecorder
gapCycles	ooo_core_recorder.h	/^        uint64_t gapCycles; \/\/phase 2 clock == curCycle - gapCycles$/;"	m	class:OOOCoreRecorder
genericGet	config.cpp	/^T Config::genericGet(const char* key) {$/;"	f	class:Config
genericGet	config.cpp	/^T Config::genericGet(const char* key, T def) {$/;"	f	class:Config
get	config.cpp	/^template<> bool Config::get<bool>(const char* key) {return genericGet<bool>(key);}$/;"	f	class:Config
get	config.cpp	/^template<> bool Config::get<bool>(const char* key, bool def) {return genericGet<bool>(key, def);}$/;"	f	class:Config
get	config.cpp	/^template<> const char* Config::get<const char*>(const char* key) {return genericGet<const char*>(key);}$/;"	f	class:Config
get	config.cpp	/^template<> const char* Config::get<const char*>(const char* key, const char* def) {return genericGet<const char*>(key, def);}$/;"	f	class:Config
get	config.cpp	/^template<> double Config::get<double>(const char* key) {return (double) genericGet<double>(key);}$/;"	f	class:Config
get	config.cpp	/^template<> double Config::get<double>(const char* key, double def) {return (double) genericGet<double>(key, (double)def);}$/;"	f	class:Config
get	config.cpp	/^template<> uint32_t Config::get<uint32_t>(const char* key) {return (uint32_t) genericGet<int>(key);}$/;"	f	class:Config
get	config.cpp	/^template<> uint32_t Config::get<uint32_t>(const char* key, uint32_t def) {return (uint32_t) genericGet<int>(key, (int)def);}$/;"	f	class:Config
get	config.cpp	/^template<> uint64_t Config::get<uint64_t>(const char* key) {return (uint64_t) genericGet<lc_int64>(key);}$/;"	f	class:Config
get	config.cpp	/^template<> uint64_t Config::get<uint64_t>(const char* key, uint64_t def) {return (uint64_t) genericGet<lc_int64>(key, (lc_int64)def);}$/;"	f	class:Config
get	config.h	/^        template<typename T> T get(const std::string& key) {return get<T>(key.c_str());}$/;"	f	class:Config
get	config.h	/^        template<typename T> T get(const std::string& key, T def) {return get<T>(key.c_str(), def);}$/;"	f	class:Config
get	event_queue.h	/^        G get;$/;"	m	class:AdaptiveEvent
get	monitor.cpp	/^uint32_t UMonMonitor::get(uint32_t partition, uint32_t bucket) const {$/;"	f	class:UMonMonitor
get	profile_stats.h	/^        uint64_t get() const {$/;"	f	class:ClockStat
get	stats.h	/^        Stat* get(uint32_t idx) const {$/;"	f	class:AggregateStat
get	stats.h	/^        uint64_t get() const {return f();}$/;"	f	class:LambdaStat
getAddr	ddr_mem.cpp	/^        Address getAddr() const {return addr;}$/;"	f	class:DDRMemoryAccEvent
getAddr	detailed_mem.h	/^        Address getAddr() const { return addr; }$/;"	f	class:MemAccessEventBase
getAddr	dramsim_mem_ctrl.cpp	/^        Address getAddr() const {$/;"	f	class:DRAMSimAccEvent
getBaseH5Type	hdf5_stats.cpp	/^        hid_t getBaseH5Type(Stat* s) {$/;"	f	class:HDF5BackendImpl	file:
getBestCandidate	part_repl_policies.h	/^        uint32_t getBestCandidate() {$/;"	f	class:VantageReplPolicy
getBestCandidate	part_repl_policies.h	/^        uint32_t getBestCandidate() {$/;"	f	class:WayPartReplPolicy
getBestCandidate	repl_policies.h	/^        uint32_t getBestCandidate() {$/;"	f	class:LFUReplPolicy
getBestCandidate	repl_policies.h	/^        uint32_t getBestCandidate() {$/;"	f	class:NRUReplPolicy
getBestCandidate	repl_policies.h	/^        uint32_t getBestCandidate() {$/;"	f	class:RandReplPolicy
getBestCandidate	repl_policies.h	/^        uint32_t getBestCandidate() {$/;"	f	class:TreeLRUReplPolicy
getBuckets	partitioner.h	/^        uint32_t getBuckets() const { return buckets; }$/;"	f	class:PartitionMonitor
getBuckets	utility_monitor.h	/^        uint32_t getBuckets() const { return buckets; }$/;"	f	class:UMon
getCid	zsim.cpp	/^uint32_t getCid(uint32_t tid) {$/;"	f
getClockDomain	process_tree.h	/^        inline uint32_t getClockDomain() const {$/;"	f	class:ProcessTreeNode
getContentionCycles	core_recorder.cpp	/^uint64_t CoreRecorder::getContentionCycles() const {$/;"	f	class:CoreRecorder
getContentionCycles	ooo_core_recorder.cpp	/^uint64_t OOOCoreRecorder::getContentionCycles() const {$/;"	f	class:OOOCoreRecorder
getCrossingStack	event_recorder.h	/^        inline CrossingStack& getCrossingStack() {$/;"	f	class:EventRecorder
getCurCycle	contention_sim.h	/^        uint64_t getCurCycle(uint32_t domain) {$/;"	f	class:ContentionSim
getCycles	null_core.h	/^        uint64_t getCycles() const {return instrs; \/*IPC=1*\/ }$/;"	f	class:NullCore
getCycles	ooo_core.h	/^        uint64_t getCycles() const {return cRec.getUnhaltedCycles(curCycle);}$/;"	f	class:OOOCore
getCycles	simple_core.h	/^        uint64_t getCycles() const {return curCycle - haltedCycles;}$/;"	f	class:SimpleCore
getCycles	timing_core.h	/^        uint64_t getCycles() const {return cRec.getUnhaltedCycles(curCycle);}$/;"	f	class:TimingCore
getDomain	timing_event.h	/^        inline uint32_t getDomain() const {return domain;}$/;"	f	class:TimingEvent
getEq	config.cpp	/^template<> bool getEq<bool>(bool v1, bool v2) {return v1 == v2;}$/;"	f
getEq	config.cpp	/^template<> bool getEq<const char*>(const char* v1, const char* v2) {return strcmp(v1, v2) == 0;}$/;"	f
getEq	config.cpp	/^template<> bool getEq<double>(double v1, double v2) {return v1 == v2;}$/;"	f
getEq	config.cpp	/^template<> bool getEq<int>(int v1, int v2) {return v1 == v2;}$/;"	f
getEq	config.cpp	/^template<> bool getEq<lc_int64>(lc_int64 v1, lc_int64 v2) {return v1 == v2;}$/;"	f
getEventRecorder	core_recorder.h	/^        inline EventRecorder* getEventRecorder() {return &eventRecorder;}$/;"	f	class:CoreRecorder
getEventRecorder	ooo_core.h	/^        inline EventRecorder* getEventRecorder() {return cRec.getEventRecorder();}$/;"	f	class:OOOCore
getEventRecorder	ooo_core_recorder.h	/^        inline EventRecorder* getEventRecorder() {return &eventRecorder;}$/;"	f	class:OOOCoreRecorder
getEventRecorder	timing_core.h	/^        inline EventRecorder* getEventRecorder() {return cRec.getEventRecorder();}$/;"	f	class:TimingCore
getFFIPoints	process_tree.h	/^        const g_vector<uint64_t>& getFFIPoints() const {$/;"	f	class:ProcessTreeNode
getFullCmdArgs	pin_cmd.cpp	/^g_vector<g_string> PinCmd::getFullCmdArgs(uint32_t procIdx, const char** inputFile) {$/;"	f	class:PinCmd
getGapCycles	event_recorder.h	/^        inline uint64_t getGapCycles() const {$/;"	f	class:EventRecorder
getGid	scheduler.h	/^        inline uint32_t getGid(uint32_t pid, uint32_t tid) const {return (pid << 16) | tid;}$/;"	f	class:Scheduler
getGroupIdx	process_tree.h	/^        uint32_t getGroupIdx() const {return groupIdx;}$/;"	f	class:ProcessTreeNode
getH5Type	hdf5_stats.cpp	/^        hid_t getH5Type(Stat* stat) { \/\/I'd like to make this functional, but passing a member function as an argument is non-trivial...$/;"	f	class:HDF5BackendImpl	file:
getInstrs	null_core.h	/^        uint64_t getInstrs() const {return instrs;}$/;"	f	class:NullCore
getInstrs	ooo_core.cpp	/^uint64_t OOOCore::getInstrs() const {return instrs;}$/;"	f	class:OOOCore
getInstrs	simple_core.h	/^        uint64_t getInstrs() const {return instrs;}$/;"	f	class:SimpleCore
getInstrs	timing_core.h	/^        uint64_t getInstrs() const {return instrs;}$/;"	f	class:TimingCore
getLastCandIdx	cache_arrays.h	/^        uint32_t getLastCandIdx() const {return lastCandIdx;}$/;"	f	class:ZArray
getLastLimit	contention_sim.h	/^        uint64_t getLastLimit() {return lastLimit;}$/;"	f	class:ContentionSim
getLibzsimAddrs	debug_zsim.cpp	/^void getLibzsimAddrs(LibInfo* libzsimAddrs) {$/;"	f
getMask	process_tree.h	/^        const g_vector<bool>& getMask() const {$/;"	f	class:ProcessTreeNode
getMaxMarginalUtility	lookahead.cpp	/^static tuple<double, uint32_t> getMaxMarginalUtility($/;"	f	namespace:lookahead
getMinStartCycle	timing_event.h	/^        inline uint64_t getMinStartCycle() const {return minStartCycle;}$/;"	f	class:TimingEvent
getMissCurve	monitor.cpp	/^void UMonMonitor::getMissCurve(uint32_t* misses, uint32_t partition) const {$/;"	f	class:UMonMonitor
getMissCurves	monitor.cpp	/^void UMonMonitor::getMissCurves() const {$/;"	f	class:UMonMonitor
getMisses	utility_monitor.cpp	/^void UMon::getMisses(uint64_t* misses) {$/;"	f	class:UMon
getMonitor	part_repl_policies.h	/^        PartitionMonitor* getMonitor() { return monitor; }$/;"	f	class:PartReplPolicy
getMonitor	part_repl_policies.h	/^        const PartitionMonitor* getMonitor() const { return monitor; }$/;"	f	class:PartReplPolicy
getName	cache.cpp	/^const char* Cache::getName() {$/;"	f	class:Cache
getName	ddr_mem.h	/^        const char* getName() {return name.c_str();}$/;"	f	class:DDRMemory
getName	detailed_mem.h	/^        const char* getName() { return name.c_str(); }$/;"	f	class:MemControllerBase
getName	dramsim_mem_ctrl.h	/^        const char* getName() {$/;"	f	class:SplitAddrMemory
getName	dramsim_mem_ctrl.h	/^        const char* getName() {return name.c_str();}$/;"	f	class:DRAMSimMemory
getName	mem_ctrls.h	/^        const char* getName() {return name.c_str();}$/;"	f	class:MD1Memory
getName	mem_ctrls.h	/^        const char* getName() {return name.c_str();}$/;"	f	class:SimpleMemory
getName	ooo_core_recorder.h	/^        const g_string& getName() const {return name;}$/;"	f	class:OOOCoreRecorder
getName	prefetcher.h	/^        const char* getName() { return name.c_str();}$/;"	f	class:StreamPrefetcher
getNextChild	process_tree.h	/^        ProcessTreeNode* getNextChild() {$/;"	f	class:ProcessTreeNode
getNs	profile_stats.h	/^inline uint64_t getNs() {$/;"	f
getNumAccesses	monitor.cpp	/^uint32_t UMonMonitor::getNumAccesses(uint32_t partition) const {$/;"	f	class:UMonMonitor
getNumAccesses	utility_monitor.cpp	/^uint64_t UMon::getNumAccesses() const {$/;"	f	class:UMon
getNumChildren	timing_event.h	/^        inline uint32_t getNumChildren() const {return numChildren;}$/;"	f	class:TimingEvent
getNumChildren	zsim_harness.cpp	/^int getNumChildren() {$/;"	f
getNumCmdProcs	pin_cmd.h	/^        uint32_t getNumCmdProcs() {return procInfo.size();}$/;"	f	class:PinCmd
getNumPartitions	partition_mapper.cpp	/^uint32_t ProcessGroupPartMapper::getNumPartitions() {$/;"	f	class:ProcessGroupPartMapper
getNumPartitions	partition_mapper.h	/^        virtual uint32_t getNumPartitions() {return 2*numCores;}$/;"	f	class:InstrDataCorePartMapper
getNumPartitions	partition_mapper.h	/^        virtual uint32_t getNumPartitions() {return 2*numProcs;}$/;"	f	class:InstrDataProcessPartMapper
getNumPartitions	partition_mapper.h	/^        virtual uint32_t getNumPartitions() {return 2;}$/;"	f	class:InstrDataPartMapper
getNumPartitions	partition_mapper.h	/^        virtual uint32_t getNumPartitions() {return numCores;}$/;"	f	class:CorePartMapper
getNumPartitions	partition_mapper.h	/^        virtual uint32_t getNumPartitions() {return numProcs;}$/;"	f	class:ProcessPartMapper
getNumPartitions	partitioner.h	/^        uint32_t getNumPartitions() const { return monitors.size(); }$/;"	f	class:UMonMonitor
getParentId	coherence_ctrls.cpp	/^uint32_t MESIBottomCC::getParentId(Address lineAddr) {$/;"	f	class:MESIBottomCC
getPartition	partition_mapper.cpp	/^uint32_t CorePartMapper::getPartition(const MemReq& req) {$/;"	f	class:CorePartMapper
getPartition	partition_mapper.cpp	/^uint32_t InstrDataCorePartMapper::getPartition(const MemReq& req) {$/;"	f	class:InstrDataCorePartMapper
getPartition	partition_mapper.cpp	/^uint32_t InstrDataPartMapper::getPartition(const MemReq& req) {$/;"	f	class:InstrDataPartMapper
getPartition	partition_mapper.cpp	/^uint32_t InstrDataProcessPartMapper::getPartition(const MemReq& req) {$/;"	f	class:InstrDataProcessPartMapper
getPartition	partition_mapper.cpp	/^uint32_t ProcessGroupPartMapper::getPartition(const MemReq& req) {$/;"	f	class:ProcessGroupPartMapper
getPartition	partition_mapper.cpp	/^uint32_t ProcessPartMapper::getPartition(const MemReq& req) {$/;"	f	class:ProcessPartMapper
getPatchRoot	process_tree.h	/^        const char* getPatchRoot() const {$/;"	f	class:ProcessTreeNode
getPeriod	event_queue.h	/^        uint64_t getPeriod() const {return period;}$/;"	f	class:Event
getPhaseCycles	null_core.cpp	/^uint64_t NullCore::getPhaseCycles() const {$/;"	f	class:NullCore
getPhaseCycles	ooo_core.cpp	/^uint64_t OOOCore::getPhaseCycles() const {return curCycle % zinfo->phaseLength;}$/;"	f	class:OOOCore
getPhaseCycles	simple_core.cpp	/^uint64_t SimpleCore::getPhaseCycles() const {$/;"	f	class:SimpleCore
getPhaseCycles	timing_core.cpp	/^uint64_t TimingCore::getPhaseCycles() const {$/;"	f	class:TimingCore
getPid	scheduler.h	/^        inline uint32_t getPid(uint32_t gid) const {return gid >> 16;}$/;"	f	class:Scheduler
getPinCmdArgs	pin_cmd.cpp	/^g_vector<g_string> PinCmd::getPinCmdArgs(uint32_t procIdx) {$/;"	f	class:PinCmd
getPortDomain	process_tree.h	/^        inline uint32_t getPortDomain() const {$/;"	f	class:ProcessTreeNode
getPostDelay	timing_event.h	/^        inline uint32_t getPostDelay() const {return postDelay;}$/;"	f	class:TimingEvent
getPreDelay	timing_event.h	/^        inline uint32_t getPreDelay() const {return preDelay;}$/;"	f	class:TimingEvent
getProcIdx	process_tree.h	/^        uint32_t getProcIdx() const {return procIdx;}$/;"	f	class:ProcessTreeNode
getProcessCycles	process_stats.cpp	/^uint64_t ProcessStats::getProcessCycles(uint32_t p) {$/;"	f	class:ProcessStats
getProcessInstrs	process_stats.cpp	/^uint64_t ProcessStats::getProcessInstrs(uint32_t p) {$/;"	f	class:ProcessStats
getRP	ideal_arrays.h	/^        ReplPolicy* getRP() const {return rp;}$/;"	f	class:IdealLRUArray
getRTT	network.cpp	/^uint32_t Network::getRTT(const char* src, const char* dst) {$/;"	f	class:Network
getRecord	event_recorder.h	/^        TimingRecord getRecord(size_t num) {$/;"	f	class:EventRecorder
getSType	config.cpp	/^template<> SType getSType<bool>() {return SType::TypeBoolean;}$/;"	f
getSType	config.cpp	/^template<> SType getSType<const char*>() {return SType::TypeString;}$/;"	f
getSType	config.cpp	/^template<> SType getSType<double>() {return SType::TypeFloat;}$/;"	f
getSType	config.cpp	/^template<> SType getSType<int>() {return SType::TypeInt;}$/;"	f
getSType	config.cpp	/^template<> SType getSType<lc_int64>() {return SType::TypeInt64;}$/;"	f
getScheduledPid	scheduler.h	/^        uint32_t getScheduledPid(uint32_t cid) const { return (contexts[cid].state == USED)? getPid(contexts[cid].curThread->gid) : (uint32_t)-1; }$/;"	f	class:Scheduler
getSlack	event_recorder.h	/^        inline uint64_t getSlack(uint64_t origStartCycle) const {$/;"	f	class:EventRecorder
getSourceId	event_recorder.h	/^        uint32_t getSourceId() const {return srcId;}$/;"	f	class:EventRecorder
getSrcDomainEvent	timing_event.h	/^        TimingEvent* getSrcDomainEvent() {return &cpe;}$/;"	f	class:CrossingEvent
getSyncedFastForward	process_tree.h	/^        inline bool getSyncedFastForward() const { return syncedFastForward; }$/;"	f	class:ProcessTreeNode
getSyscallBlacklistRegex	process_tree.h	/^        const g_string& getSyscallBlacklistRegex() const {$/;"	f	class:ProcessTreeNode
getTid	scheduler.h	/^        inline uint32_t getTid(uint32_t gid) const {return gid & 0x0FFFF;}$/;"	f	class:Scheduler
getTimeoutArg	virt/timeout.cpp	/^static int getTimeoutArg(int syscall) {$/;"	f	file:
getType	detailed_mem.h	/^        MemAccessType getType() const { return type; }$/;"	f	class:MemAccessEventBase
getTypeName	config.cpp	/^template<> const char* getTypeName<bool>() {return "bool";}$/;"	f
getTypeName	config.cpp	/^template<> const char* getTypeName<const char*>() {return "string";}$/;"	f
getTypeName	config.cpp	/^template<> const char* getTypeName<double>() {return "double";}$/;"	f
getTypeName	config.cpp	/^template<> const char* getTypeName<int>() {return "uint32";}$/;"	f
getTypeName	config.cpp	/^template<> const char* getTypeName<lc_int64>() {return "uint64";}$/;"	f
getUnhaltedCycles	core_recorder.cpp	/^uint64_t CoreRecorder::getUnhaltedCycles(uint64_t curCycle) const {$/;"	f	class:CoreRecorder
getUnhaltedCycles	ooo_core_recorder.cpp	/^uint64_t OOOCoreRecorder::getUnhaltedCycles(uint64_t curCycle) const {$/;"	f	class:OOOCoreRecorder
get_foot	g_heap/dlmalloc.h.c	2240;"	d	file:
get_mstate_for	g_heap/dlmalloc.h.c	3021;"	d	file:
gid	scheduler.h	/^            const uint32_t gid;$/;"	m	struct:Scheduler::ThreadInfo
gidMap	scheduler.h	/^        g_unordered_map<uint32_t, ThreadInfo*> gidMap;$/;"	m	class:Scheduler
globPhaseCycles	zsim.h	/^    uint64_t globPhaseCycles; \/\/just numPhases*phaseCycles. It behooves us to precompute it, since it is very frequently used in tracing code.$/;"	m	struct:GlobSimInfo
globalActiveProcs	zsim.h	/^    volatile uint32_t globalActiveProcs; \/\/used for termination$/;"	m	struct:GlobSimInfo
globalFFProcs	zsim.h	/^    volatile uint32_t globalFFProcs; \/\/count of processes that are in either synced or unsynced FF$/;"	m	struct:GlobSimInfo
globalPauseFlag	zsim.h	/^    volatile bool globalPauseFlag; \/\/if set, pauses simulation on phase end$/;"	m	struct:GlobSimInfo
globalSyncedFFProcs	zsim.h	/^    volatile uint32_t globalSyncedFFProcs; \/\/count of processes that are in synced FF$/;"	m	struct:GlobSimInfo
globzinfo	zsim_harness.cpp	/^GlobSimInfo* globzinfo = NULL; \/\/used very sparingly, only in sig handlers. Should probably promote to a global like in zsim processes.$/;"	v
gm	g_heap/dlmalloc.h.c	2590;"	d	file:
gm_attach	galloc.cpp	/^void gm_attach(int shmid) {$/;"	f
gm_calloc	galloc.h	/^template <typename T> T* gm_calloc() {return static_cast<T*>(__gm_calloc(1, sizeof(T)));}$/;"	f
gm_calloc	galloc.h	/^template <typename T> T* gm_calloc(size_t objs) {return static_cast<T*>(__gm_calloc(objs, sizeof(T)));}$/;"	f
gm_detach	galloc.cpp	/^void gm_detach() {$/;"	f
gm_dup	galloc.h	/^template <typename T> T* gm_dup(T* src, size_t objs) {$/;"	f
gm_free	galloc.cpp	/^void gm_free(void* ptr) {$/;"	f
gm_get_glob_ptr	galloc.cpp	/^void* gm_get_glob_ptr() {$/;"	f
gm_get_secondary_ptr	galloc.cpp	/^void* gm_get_secondary_ptr() {$/;"	f
gm_init	galloc.cpp	/^int gm_init(size_t segmentSize) {$/;"	f
gm_isready	galloc.cpp	/^bool gm_isready() {$/;"	f
gm_malloc	galloc.cpp	/^void* gm_malloc(size_t size) {$/;"	f
gm_malloc	galloc.h	/^template <typename T> T* gm_malloc() {return static_cast<T*>(gm_malloc(sizeof(T)));}$/;"	f
gm_malloc	galloc.h	/^template <typename T> T* gm_malloc(size_t objs) {return static_cast<T*>(gm_malloc(sizeof(T)*objs));}$/;"	f
gm_memalign	galloc.h	/^template <typename T> T* gm_memalign(size_t blocksize) {return static_cast<T*>(__gm_memalign(blocksize, sizeof(T)));}$/;"	f
gm_memalign	galloc.h	/^template <typename T> T* gm_memalign(size_t blocksize, size_t objs) {return static_cast<T*>(__gm_memalign(blocksize, sizeof(T)*objs));}$/;"	f
gm_segment	galloc.cpp	/^struct gm_segment {$/;"	s	file:
gm_set_glob_ptr	galloc.cpp	/^void gm_set_glob_ptr(void* ptr) {$/;"	f
gm_set_secondary_ptr	galloc.cpp	/^void gm_set_secondary_ptr(void* ptr) {$/;"	f
gm_shmid	galloc.cpp	/^static int gm_shmid = 0;$/;"	v	file:
gm_stats	galloc.cpp	/^void gm_stats() {$/;"	f
gm_strdup	galloc.cpp	/^char* gm_strdup(const char* str) {$/;"	f
granularity	g_heap/dlmalloc.h.c	/^  size_t granularity;$/;"	m	struct:malloc_params	file:
granularity_align	g_heap/dlmalloc.h.c	2622;"	d	file:
groupIdx	process_tree.h	/^        const uint32_t groupIdx;$/;"	m	class:ProcessTreeNode
hMatrix	hash.h	/^        uint64_t* hMatrix;$/;"	m	class:H3HashFamily
haltedCycles	simple_core.h	/^        uint64_t haltedCycles;$/;"	m	class:SimpleCore
handleCrossing	timing_event.cpp	/^TimingEvent* TimingEvent::handleCrossing(TimingEvent* childEv, EventRecorder* evRec, bool unlinkChild) {$/;"	f	class:TimingEvent
handoffEvents	scheduler.h	/^        Counter scheduleEvents, waitEvents, handoffEvents, sleepEvents;$/;"	m	class:Scheduler
handoffThread	scheduler.h	/^            volatile ThreadInfo* handoffThread; \/\/if at the end of a sync() this is not NULL, we need to transfer our current context to the thread pointed here.$/;"	m	struct:Scheduler::ThreadInfo
harnessPid	zsim.h	/^    int harnessPid; \/\/used for debugging purposes$/;"	m	struct:GlobSimInfo
hasCounterNames	stats.h	/^        inline bool hasCounterNames() {$/;"	f	class:VectorStat
has_segment_link	g_heap/dlmalloc.h.c	/^static int has_segment_link(mstate m, msegmentptr ss) {$/;"	f	file:
hash	hash.cpp	/^uint64_t H3HashFamily::hash(uint32_t id, uint64_t val) {$/;"	f	class:H3HashFamily
hash	hash.cpp	/^uint64_t SHA1HashFamily::hash(uint32_t id, uint64_t val) {$/;"	f	class:SHA1HashFamily
hash	hash.h	/^        inline uint64_t hash(uint32_t id, uint64_t val) {return val;}$/;"	f	class:IdHashFamily
hash	mtrand.h	/^inline uint64_t MTRand::hash(time_t t, clock_t c) {$/;"	f	class:MTRand
hblkhd	g_heap/dlmalloc.h.c	/^  MALLINFO_FIELD_TYPE hblkhd;   \/* space in mmapped regions *\/$/;"	m	struct:mallinfo	file:
hblks	g_heap/dlmalloc.h.c	/^  MALLINFO_FIELD_TYPE hblks;    \/* always 0 *\/$/;"	m	struct:mallinfo	file:
head	g_heap/dlmalloc.h.c	/^  size_t                    head;$/;"	m	struct:malloc_tree_chunk	file:
head	g_heap/dlmalloc.h.c	/^  size_t               head;       \/* Size and inuse bits. *\/$/;"	m	struct:malloc_chunk	file:
head	intrusive_list.h	/^        T* head;$/;"	m	class:InList
heads	utility_monitor.h	/^        Node** heads;$/;"	m	class:UMon
heartbeat	process_tree.cpp	/^void ProcessTreeNode::heartbeat() {$/;"	f	class:ProcessTreeNode
heartbeats	process_tree.h	/^        volatile uint64_t heartbeats;$/;"	m	class:ProcessTreeNode
hf	cache_arrays.h	/^        HashFamily* hf;$/;"	m	class:SetAssocArray
hf	cache_arrays.h	/^        HashFamily* hf;$/;"	m	class:ZArray
hf	utility_monitor.h	/^        HashFamily* hf;$/;"	m	class:UMon
hiBit	mtrand.h	/^        uint64_t hiBit(const uint64_t u) const { return u & 0x80000000UL; }$/;"	f	class:MTRand
highPrioAccess	timing_cache.cpp	/^uint64_t TimingCache::highPrioAccess(uint64_t cycle) {$/;"	f	class:TimingCache
hold	timing_event.h	/^        inline void hold() {$/;"	f	class:TimingEvent
ialloc	g_heap/dlmalloc.h.c	/^static void** ialloc(mstate m,$/;"	f	file:
id	detailed_mem.h	/^        uint32_t id;$/;"	m	class:MemSchedulerBase
id	ooo_core_recorder.cpp	/^        uint64_t id;$/;"	m	class:OOODispatchEvent	file:
id	ooo_core_recorder.cpp	/^        uint64_t id;$/;"	m	class:OOOIssueEvent	file:
id	ooo_core_recorder.cpp	/^        uint64_t id;$/;"	m	class:OOORespEvent	file:
idlePeriods	scheduler.h	/^        Counter idlePhases, idlePeriods;$/;"	m	class:Scheduler
idlePhases	scheduler.h	/^        Counter idlePhases, idlePeriods;$/;"	m	class:Scheduler
idlePowerDownCycle	detailed_mem.h	/^        uint64_t idlePowerDownCycle;$/;"	m	class:MemRankBase
idleStandbyCycle	detailed_mem.h	/^        uint64_t idleStandbyCycle;$/;"	m	class:MemRankBase
idx	ddr_mem.h	/^        uint32_t idx;$/;"	m	class:ActWindow
idx	ooo_core.h	/^        uint32_t idx;$/;"	m	class:CycleQueue
idx	ooo_core.h	/^        uint32_t idx;$/;"	m	class:ReorderBuffer
idx2bit	g_heap/dlmalloc.h.c	2865;"	d	file:
ignoreHooks	zsim.h	/^    bool ignoreHooks;$/;"	m	struct:GlobSimInfo
ilog2	bithacks.h	/^template<> uint32_t ilog2<uint32_t>(uint32_t val) {$/;"	f
ilog2	bithacks.h	/^template<> uint32_t ilog2<uint64_t>(uint64_t val) {$/;"	f
inCSim	contention_sim.h	/^        volatile bool inCSim; \/\/true when inside contention simulation$/;"	m	class:ContentionSim
inCfg	config.h	/^        libconfig::Config* inCfg;$/;"	m	class:Config
inFakeTimeoutMode	virt/timeout.cpp	/^static bool inFakeTimeoutMode[MAX_THREADS];$/;"	v	file:
inFastForward	process_tree.h	/^        volatile bool inFastForward;$/;"	m	class:ProcessTreeNode
inPause	process_tree.h	/^        volatile bool inPause;$/;"	m	class:ProcessTreeNode
inRegs	decoder.h	/^            uint32_t inRegs[MAX_INSTR_REG_READS];$/;"	m	struct:Decoder::Instr
inSyscall	zsim.cpp	/^bool inSyscall[MAX_THREADS];  \/\/ set in SyscallEnter, reset in SyscallExit, regardless of state. We MAY need this for ContextChange$/;"	v
inc	cache_arrays.h	/^        inline void inc() {x++;} \/\/overloading prefix\/postfix too messy$/;"	f	struct:SetAssocCands::iterator
inc	cache_arrays.h	/^        inline void inc() {x++;} \/\/overloading prefix\/postfix too messy$/;"	f	struct:ZCands::iterator
inc	ddr_mem.h	/^            inline void inc() {n = n->next;}  \/\/ overloading prefix\/postfix too messy$/;"	f	struct:RequestQueue::iterator
inc	ddr_mem.h	/^        inline uint32_t inc(uint32_t i) const { return (i < buf.size()-1)? i+1 : 0; }$/;"	f	class:ActWindow
inc	prefetcher.h	/^        void inc() { count = MIN(count + 1, M); }$/;"	f	class:SatCounter
inc	stats.h	/^        inline void inc() {$/;"	f	class:Counter
inc	stats.h	/^        inline void inc(uint32_t idx) {$/;"	f	class:VectorCounter
inc	stats.h	/^        inline void inc(uint32_t idx, uint64_t value) {$/;"	f	class:VectorCounter
inc	stats.h	/^        inline void inc(uint64_t delta) {$/;"	f	class:Counter
incomingLineAddr	part_repl_policies.h	/^        Address incomingLineAddr;$/;"	m	class:VantageReplPolicy
incomingLineAddr	part_repl_policies.h	/^        Address incomingLineAddr;$/;"	m	class:WayPartReplPolicy
incomingLinePart	part_repl_policies.h	/^        uint32_t incomingLinePart; \/\/to what partition does the incoming line belong?$/;"	m	class:WayPartReplPolicy
index	g_heap/dlmalloc.h.c	/^  bindex_t                  index;$/;"	m	struct:malloc_tree_chunk	file:
inflightRequests	dramsim_mem_ctrl.h	/^        std::multimap<uint64_t, DRAMSimAccEvent*> inflightRequests;$/;"	m	class:DRAMSimMemory
info	log.h	95;"	d
init	breakdown_stats.h	/^        virtual void init(const char* name, const char* desc, uint32_t size) {$/;"	f	class:CycleBreakdownStat
init	breakdown_stats.h	/^        virtual void init(const char* name, const char* desc, uint32_t size, const char** names) {$/;"	f	class:CycleBreakdownStat
init	coherence_ctrls.cpp	/^void MESIBottomCC::init(const g_vector<MemObject*>& _parents, Network* network, const char* name) {$/;"	f	class:MESIBottomCC
init	coherence_ctrls.cpp	/^void MESITopCC::init(const g_vector<BaseCache*>& _children, Network* network, const char* name) {$/;"	f	class:MESITopCC
init	ddr_mem.h	/^        void init(size_t size) {$/;"	f	class:RequestQueue
init	ddr_mem.h	/^        void init(uint32_t size) {$/;"	f	class:ActWindow
init	decoder.h	/^    void init(uint64_t _addr, uint32_t _uops, uint32_t _approxInstrs) {$/;"	f	struct:DynBbl
init	phase_slab_alloc.h	/^            void init(uint32_t sz) {$/;"	f	struct:PhaseSlabAlloc::Slab
init	profile_stats.h	/^        virtual void init(const char* name, const char* desc, uint32_t size) {$/;"	f	class:TimeBreakdownStat
init	profile_stats.h	/^        virtual void init(const char* name, const char* desc, uint32_t size, const char** names) {$/;"	f	class:TimeBreakdownStat
init	repl_policies.h	/^        void init(uint32_t numLines) {$/;"	f	class:ProfViolReplPolicy
init	stats.h	/^        virtual void init(const char* name, const char* desc) {$/;"	f	class:ScalarStat
init	stats.h	/^        virtual void init(const char* name, const char* desc) {$/;"	f	class:VectorStat
init	stats.h	/^        virtual void init(const char* name, const char* desc, uint32_t size) {$/;"	f	class:VectorCounter
init	stats.h	/^        virtual void init(const char* name, const char* desc, uint32_t size, const char** counterNames) {$/;"	f	class:VectorCounter
init	stats.h	/^        void init(const char* name, const char* desc) {$/;"	f	class:AggregateStat
init	stats.h	/^        void init(const char* name, const char* desc) {$/;"	f	class:Counter
init	stats.h	/^        void init(const char* name, const char* desc, uint64_t (*func)()) {$/;"	f	class:ProxyFuncStat
init	stats.h	/^        void init(const char* name, const char* desc, uint64_t* ptr) {$/;"	f	class:ProxyStat
initCacheStats	cache.cpp	/^void Cache::initCacheStats(AggregateStat* cacheStat) {$/;"	f	class:Cache
initStat	stats.h	/^        virtual void initStat(const char* name, const char* desc) {$/;"	f	class:Stat
initStats	cache.cpp	/^void Cache::initStats(AggregateStat* parentStat) {$/;"	f	class:Cache
initStats	cache_arrays.cpp	/^void ZArray::initStats(AggregateStat* parentStat) {$/;"	f	class:ZArray
initStats	cache_arrays.h	/^        virtual void initStats(AggregateStat* parent) {}$/;"	f	class:CacheArray
initStats	coherence_ctrls.h	/^        void initStats(AggregateStat* cacheStat) {$/;"	f	class:MESICC
initStats	coherence_ctrls.h	/^        void initStats(AggregateStat* cacheStat) {$/;"	f	class:MESITerminalCC
initStats	coherence_ctrls.h	/^        void initStats(AggregateStat* parentStat) {$/;"	f	class:MESIBottomCC
initStats	contention_sim.cpp	/^void ContentionSim::initStats(AggregateStat* parentStat) {$/;"	f	class:ContentionSim
initStats	ddr_mem.cpp	/^void DDRMemory::initStats(AggregateStat* parentStat) {$/;"	f	class:DDRMemory
initStats	detailed_mem.cpp	/^void MemControllerBase::initStats(AggregateStat* parentStat) {$/;"	f	class:MemControllerBase
initStats	dramsim_mem_ctrl.cpp	/^void DRAMSimMemory::initStats(AggregateStat* parentStat) { panic("???"); }$/;"	f	class:DRAMSimMemory
initStats	dramsim_mem_ctrl.cpp	/^void DRAMSimMemory::initStats(AggregateStat* parentStat) {$/;"	f	class:DRAMSimMemory
initStats	dramsim_mem_ctrl.h	/^        void initStats(AggregateStat* parentStat) {$/;"	f	class:SplitAddrMemory
initStats	filter_cache.h	/^        void initStats(AggregateStat* parentStat) {$/;"	f	class:FilterCache
initStats	ideal_arrays.h	/^                void initStats(AggregateStat* parent) {}$/;"	f	class:IdealLRUArray::ProxyReplPolicy
initStats	ideal_arrays.h	/^        void initStats(AggregateStat* parentStat) {$/;"	f	class:IdealLRUPartReplPolicy
initStats	mem_ctrls.h	/^        void initStats(AggregateStat* parentStat) {$/;"	f	class:MD1Memory
initStats	memory_hierarchy.h	/^        virtual void initStats(AggregateStat* parentStat) {}$/;"	f	class:MemObject
initStats	null_core.cpp	/^void NullCore::initStats(AggregateStat* parentStat) {$/;"	f	class:NullCore
initStats	ooo_core.cpp	/^void OOOCore::initStats(AggregateStat* parentStat) {$/;"	f	class:OOOCore
initStats	part_repl_policies.h	/^        void initStats(AggregateStat* parentStat) {$/;"	f	class:VantageReplPolicy
initStats	part_repl_policies.h	/^        void initStats(AggregateStat* parentStat) {$/;"	f	class:WayPartReplPolicy
initStats	prefetcher.cpp	/^void StreamPrefetcher::initStats(AggregateStat* parentStat) {$/;"	f	class:StreamPrefetcher
initStats	repl_policies.h	/^        virtual void initStats(AggregateStat* parent) {}$/;"	f	class:ReplPolicy
initStats	repl_policies.h	/^        void initStats(AggregateStat* parentStat) {$/;"	f	class:ProfViolReplPolicy
initStats	scheduler.h	/^        void initStats(AggregateStat* parentStat) {$/;"	f	class:Scheduler
initStats	simple_core.cpp	/^void SimpleCore::initStats(AggregateStat* parentStat) {$/;"	f	class:SimpleCore
initStats	timing_cache.cpp	/^void TimingCache::initStats(AggregateStat* parentStat) {$/;"	f	class:TimingCache
initStats	timing_core.cpp	/^void TimingCore::initStats(AggregateStat* parentStat) {$/;"	f	class:TimingCore
initStats	utility_monitor.cpp	/^void UMon::initStats(AggregateStat* parentStat) {$/;"	f	class:UMon
initTech	ddr_mem.cpp	/^void DDRMemory::initTech(const char* techName) {$/;"	f	class:DDRMemory
init_bins	g_heap/dlmalloc.h.c	/^static void init_bins(mstate m) {$/;"	f	file:
init_malloc_global_mutex	g_heap/dlmalloc.h.c	/^static void init_malloc_global_mutex() {$/;"	f	file:
init_mparams	g_heap/dlmalloc.h.c	/^static int init_mparams(void) {$/;"	f	file:
init_top	g_heap/dlmalloc.h.c	/^static void init_top(mstate m, mchunkptr p, size_t psize) {$/;"	f	file:
init_user_mstate	g_heap/dlmalloc.h.c	/^static mstate init_user_mstate(char* tbase, size_t tsize) {$/;"	f	file:
initialState	memory_hierarchy.h	/^    MESIState initialState;$/;"	m	struct:MemReq
initialize	mtrand.h	/^inline void MTRand::initialize(const uint64_t seed) {$/;"	f	class:MTRand
input	pin_cmd.h	/^            g_string input;$/;"	m	struct:PinCmd::ProcCmdInfo
ins	decoder.h	/^            INS ins;$/;"	m	struct:Decoder::Instr
insWindow	ooo_core.h	/^        WindowStructure<1024, 36 \/*size*\/> insWindow; \/\/NOTE: IW width is implicitly determined by the decoder, which sets the port masks according to uop type$/;"	m	class:OOOCore
insert	event_queue.h	/^        void insert(Event* ev, int64_t startDelay = -1) {$/;"	f	class:EventQueue
insertAfter	intrusive_list.h	/^        void insertAfter(T* prev, T* e) {$/;"	f	class:InList
insert_chunk	g_heap/dlmalloc.h.c	3723;"	d	file:
insert_large_chunk	g_heap/dlmalloc.h.c	3582;"	d	file:
insert_small_chunk	g_heap/dlmalloc.h.c	3509;"	d	file:
instrs	core.h	/^    uint32_t instrs;$/;"	m	struct:BblInfo
instrs	null_core.h	/^        uint64_t instrs;$/;"	m	class:NullCore
instrs	ooo_core.h	/^        uint64_t instrs, uops, bbls, approxInstrs, mispredBranches;$/;"	m	class:OOOCore
instrs	simple_core.h	/^        uint64_t instrs;$/;"	m	class:SimpleCore
instrs	timing_core.h	/^        uint64_t instrs;$/;"	m	class:TimingCore
interleaveType	detailed_mem_params.h	/^        uint32_t interleaveType;$/;"	m	class:MemParam
interlockedcompareexchange	g_heap/dlmalloc.h.c	1415;"	d	file:
interlockedexchange	g_heap/dlmalloc.h.c	1416;"	d	file:
internal_free	g_heap/dlmalloc.h.c	3736;"	d	file:
internal_free	g_heap/dlmalloc.h.c	3741;"	d	file:
internal_free	g_heap/dlmalloc.h.c	3745;"	d	file:
internal_mallinfo	g_heap/dlmalloc.h.c	/^static struct mallinfo internal_mallinfo(mstate m) {$/;"	f	file:
internal_malloc	g_heap/dlmalloc.h.c	3735;"	d	file:
internal_malloc	g_heap/dlmalloc.h.c	3739;"	d	file:
internal_malloc	g_heap/dlmalloc.h.c	3744;"	d	file:
internal_malloc_stats	g_heap/dlmalloc.h.c	/^static void internal_malloc_stats(mstate m) {$/;"	f	file:
internal_memalign	g_heap/dlmalloc.h.c	/^static void* internal_memalign(mstate m, size_t alignment, size_t bytes) {$/;"	f	file:
internal_realloc	g_heap/dlmalloc.h.c	/^static void* internal_realloc(mstate m, void* oldmem, size_t bytes) {$/;"	f	file:
invLat	cache.h	/^        uint32_t invLat; \/\/latency of an invalidation$/;"	m	class:Cache
invTypeNames	memory_hierarchy.cpp	/^static const char* invTypeNames[] = {"INV", "INVX"};$/;"	v	file:
invalidate	cache.cpp	/^uint64_t Cache::invalidate(Address lineAddr, InvType type, bool* reqWriteback, uint64_t reqCycle, uint32_t srcId) {$/;"	f	class:Cache
invalidate	filter_cache.h	/^        uint64_t invalidate(Address lineAddr, InvType type, bool* reqWriteback, uint64_t cycle, uint32_t srcId) {$/;"	f	class:FilterCache
invalidate	prefetcher.cpp	/^uint64_t StreamPrefetcher::invalidate(Address lineAddr, InvType type, bool* reqWriteback, uint64_t reqCycle, uint32_t srcId) {$/;"	f	class:StreamPrefetcher
is	memory_hierarchy.h	/^    inline bool is (Flag f) const {return flags & f;}$/;"	f	struct:MemReq
isEmpty	coherence_ctrls.h	/^            bool isEmpty() {$/;"	f	struct:MESITopCC::Entry
isExclusive	coherence_ctrls.h	/^            bool isExclusive() {$/;"	f	struct:MESITopCC::Entry
isExclusive	coherence_ctrls.h	/^        inline bool isExclusive(uint32_t lineId) {$/;"	f	class:MESIBottomCC
isFlagsReg	decoder.cpp	/^static inline bool isFlagsReg(uint32_t reg) {$/;"	f	file:
isFutexWaitOp	virt/timeout.cpp	/^static bool isFutexWaitOp(int op) {$/;"	f	file:
isFutexWakeOp	virt/timeout.cpp	/^static bool isFutexWakeOp(int op) {$/;"	f	file:
isInFastForward	process_tree.h	/^        inline bool isInFastForward() const { return inFastForward; }$/;"	f	class:ProcessTreeNode
isInPause	process_tree.h	/^        inline bool isInPause() const { return inPause; }$/;"	f	class:ProcessTreeNode
isNopThread	virt/common.h	/^    bool isNopThread;$/;"	m	struct:PrePatchArgs
isPow2	bithacks.h	/^static inline bool isPow2(T val) {$/;"	f
isRegular	stats.h	/^        bool isRegular() const {$/;"	f	class:AggregateStat
isSleeping	scheduler.h	/^        bool isSleeping(uint32_t pid, uint32_t tid) {$/;"	f	class:Scheduler
isValid	coherence_ctrls.h	/^        bool isValid(uint32_t lineId) {return bcc->isValid(lineId);}$/;"	f	class:MESICC
isValid	coherence_ctrls.h	/^        bool isValid(uint32_t lineId) {return bcc->isValid(lineId);}$/;"	f	class:MESITerminalCC
isValid	coherence_ctrls.h	/^        inline bool isValid(uint32_t lineId) {$/;"	f	class:MESIBottomCC
isWrite	ddr_mem.cpp	/^        bool isWrite() const {return write;}$/;"	f	class:DDRMemoryAccEvent
isWrite	dramsim_mem_ctrl.cpp	/^        bool isWrite() const {$/;"	f	class:DRAMSimAccEvent
is_aligned	g_heap/dlmalloc.h.c	1509;"	d	file:
is_current	g_heap/dlmalloc.h.c	/^    bool is_current() {return (getpid() == pid) && (pthread_self() == tid);}$/;"	f	struct:threadid_t
is_empty	g_heap/dlmalloc.h.c	/^    bool is_empty() {return (pid == 0) && (tid == 0);}$/;"	f	struct:threadid_t
is_extern_segment	g_heap/dlmalloc.h.c	2437;"	d	file:
is_global	g_heap/dlmalloc.h.c	2591;"	d	file:
is_granularity_aligned	g_heap/dlmalloc.h.c	2639;"	d	file:
is_initialized	g_heap/dlmalloc.h.c	2595;"	d	file:
is_inuse	g_heap/dlmalloc.h.c	2221;"	d	file:
is_mmapped	g_heap/dlmalloc.h.c	2222;"	d	file:
is_mmapped_segment	g_heap/dlmalloc.h.c	2436;"	d	file:
is_page_aligned	g_heap/dlmalloc.h.c	2637;"	d	file:
is_small	g_heap/dlmalloc.h.c	2773;"	d	file:
iterator	cache_arrays.h	/^        explicit inline iterator(ZWalkInfo* _x) : x(_x) {}$/;"	f	struct:ZCands::iterator
iterator	cache_arrays.h	/^        explicit inline iterator(uint32_t _x) : x(_x) {}$/;"	f	struct:SetAssocCands::iterator
iterator	cache_arrays.h	/^    struct iterator {$/;"	s	struct:SetAssocCands
iterator	cache_arrays.h	/^    struct iterator {$/;"	s	struct:ZCands
iterator	ddr_mem.h	/^            explicit inline iterator(Node* _n) : n(_n) {}$/;"	f	struct:RequestQueue::iterator
iterator	ddr_mem.h	/^        struct iterator {$/;"	s	class:RequestQueue
join	barrier.h	/^        void join(uint32_t tid, lock_t* schedLock) {$/;"	f	class:Barrier
join	core.h	/^        virtual void join() {}$/;"	f	class:Core
join	null_core.cpp	/^void NullCore::join() {$/;"	f	class:NullCore
join	ooo_core.cpp	/^void OOOCore::join() {$/;"	f	class:OOOCore
join	scheduler.h	/^        uint32_t join(uint32_t pid, uint32_t tid) {$/;"	f	class:Scheduler
join	simple_core.cpp	/^void SimpleCore::join() {$/;"	f	class:SimpleCore
join	timing_core.cpp	/^void TimingCore::join() {$/;"	f	class:TimingCore
joinPtrs	zsim.cpp	/^static const InstrFuncPtrs joinPtrs = {JoinAndLoadSingle, JoinAndStoreSingle, JoinAndBasicBlock, JoinAndRecordBranch, JoinAndPredLoadSingle, JoinAndPredStoreSingle, FPTR_JOIN};$/;"	v	file:
keepcost	g_heap/dlmalloc.h.c	/^  MALLINFO_FIELD_TYPE keepcost; \/* releasable (via malloc_trim) space *\/$/;"	m	struct:mallinfo	file:
l	g_heap/dlmalloc.h.c	/^  volatile long l;$/;"	m	struct:win32_mlock_t	file:
l	g_heap/dlmalloc.h.c	/^  volatile unsigned int l;$/;"	m	struct:pthread_mlock_t	file:
l1d	ooo_core.h	/^        FilterCache* l1d;$/;"	m	class:OOOCore
l1d	simple_core.h	/^        FilterCache* l1d;$/;"	m	class:SimpleCore
l1d	timing_core.h	/^        FilterCache* l1d;$/;"	m	class:TimingCore
l1i	ooo_core.h	/^        FilterCache* l1i;$/;"	m	class:OOOCore
l1i	simple_core.h	/^        FilterCache* l1i;$/;"	m	class:SimpleCore
l1i	timing_core.h	/^        FilterCache* l1i;$/;"	m	class:TimingCore
lastAccCycle	timing_cache.h	/^        uint64_t lastAccCycle, lastFreeCycle;$/;"	m	class:TimingCache
lastAccessCycle	detailed_mem.h	/^        uint64_t lastAccessCycle;$/;"	m	class:MemRankBase
lastAccessedCycle	detailed_mem.h	/^        uint64_t lastAccessedCycle;$/;"	m	class:MemControllerBase
lastAccesses	detailed_mem.h	/^        uint64_t lastAccesses;$/;"	m	class:MemControllerBase
lastActCycle	ddr_mem.h	/^            uint64_t lastActCycle;  \/\/ cycle of last ACT command$/;"	m	struct:DDRMemory::Bank
lastActCycle	detailed_mem.h	/^        uint64_t *lastActCycle;$/;"	m	class:MemRankBase
lastBank	detailed_mem.h	/^        uint32_t lastBank;$/;"	m	class:MemRankBase
lastCandIdx	cache_arrays.h	/^        uint32_t lastCandIdx;$/;"	m	class:ZArray
lastCmdCycle	ddr_mem.h	/^            uint64_t lastCmdCycle;  \/\/ RD\/WR command, used for refreshes only$/;"	m	struct:DDRMemory::Bank
lastCmdWasWrite	ddr_mem.h	/^        bool lastCmdWasWrite;$/;"	m	class:DDRMemory
lastCoreCycles	process_stats.h	/^        g_vector<uint64_t> lastCoreCycles, lastCoreInstrs;$/;"	m	class:ProcessStats
lastCoreInstrs	process_stats.h	/^        g_vector<uint64_t> lastCoreCycles, lastCoreInstrs;$/;"	m	class:ProcessStats
lastCrossing	contention_sim.h	/^        CrossingEventInfo* lastCrossing; \/\/indexed by [srcId*doms*doms + srcDom*doms + dstDom]$/;"	m	class:ContentionSim
lastCycle	breakdown_stats.h	/^        uint64_t lastCycle;$/;"	m	class:CycleBreakdownStat
lastCycle	prefetcher.h	/^            uint64_t lastCycle;  \/\/ updated on alloc and hit$/;"	m	struct:StreamPrefetcher::Entry
lastCycles	zsim_harness.cpp	/^static uint64_t lastCycles = 0;$/;"	v	file:
lastEvProduced	ooo_core_recorder.h	/^        OOOIssueEvent* lastEvProduced;$/;"	m	class:OOOCoreRecorder
lastEvSimulated	ooo_core_recorder.h	/^        OOOIssueEvent* lastEvSimulated;$/;"	m	class:OOOCoreRecorder
lastEventSimulated	core_recorder.h	/^        TimingCoreEvent* lastEventSimulated;$/;"	m	class:CoreRecorder
lastFreeCycle	timing_cache.h	/^        uint64_t lastAccCycle, lastFreeCycle;$/;"	m	class:TimingCache
lastGapCycles	event_recorder.h	/^        volatile uint64_t lastGapCycles;$/;"	m	class:EventRecorder
lastHeartbeatTime	zsim_harness.cpp	/^static time_t lastHeartbeatTime;$/;"	v	file:
lastIdx	barrier.h	/^            uint32_t lastIdx;$/;"	m	struct:Barrier::ThreadSyncInfo
lastLastPos	prefetcher.h	/^            uint32_t lastLastPos;$/;"	m	struct:StreamPrefetcher::Entry
lastLimit	contention_sim.h	/^        volatile uint64_t lastLimit;$/;"	m	class:ContentionSim
lastMemCycle	detailed_mem.h	/^        uint64_t lastMemCycle;$/;"	m	class:MemControllerBase
lastPhase	mem_ctrls.h	/^        uint64_t lastPhase;$/;"	m	class:MD1Memory
lastPhaseCycle	detailed_mem.h	/^        uint64_t lastPhaseCycle;$/;"	m	class:MemControllerBase
lastPort	ooo_core.h	/^        uint8_t lastPort;$/;"	m	class:WindowStructure
lastPos	prefetcher.h	/^            uint32_t lastPos;$/;"	m	struct:StreamPrefetcher::Entry
lastPower	detailed_mem.h	/^        powerValue lastPower;$/;"	m	class:MemControllerBase
lastPreCycle	detailed_mem.h	/^        uint64_t *lastPreCycle;$/;"	m	class:MemRankBase
lastPrefetchPos	prefetcher.h	/^            uint32_t lastPrefetchPos;$/;"	m	struct:StreamPrefetcher::Entry
lastRdWrCycle	detailed_mem.h	/^        uint64_t *lastRdWrCycle;$/;"	m	class:MemRankBase
lastRefreshCycle	detailed_mem.h	/^        uint64_t lastRefreshCycle;$/;"	m	class:MemRankBase
lastRow	detailed_mem.h	/^        uint32_t *lastRow;$/;"	m	class:MemRankBase
lastStartSlack	event_recorder.h	/^        volatile uint64_t lastStartSlack;$/;"	m	class:EventRecorder
lastStoreAddrCommitCycle	ooo_core.h	/^        uint64_t lastStoreAddrCommitCycle; \/\/tracks last store addr uop, all loads queue behind it$/;"	m	class:OOOCore
lastStoreCommitCycle	ooo_core.h	/^        uint64_t lastStoreCommitCycle;$/;"	m	class:OOOCore
lastType	detailed_mem.h	/^        MemAccessType* lastType;$/;"	m	class:MemRankBase
lastUnhaltedCycle	core_recorder.h	/^        uint64_t lastUnhaltedCycle; \/\/set on transition to HALTED$/;"	m	class:CoreRecorder
lastUnhaltedCycle	ooo_core_recorder.h	/^        uint64_t lastUnhaltedCycle; \/\/set on transition to HALTED$/;"	m	class:OOOCoreRecorder
lastUpdateCycle	part_repl_policies.h	/^        uint64_t lastUpdateCycle; \/\/for cumulative size counter updates; could be made event-driven$/;"	m	class:VantageReplPolicy
lastUpdateCycles	core.h	/^        uint64_t lastUpdateCycles;$/;"	m	class:Core
lastUpdateInstrs	core.h	/^        uint64_t lastUpdateInstrs;$/;"	m	class:Core
lastUpdatePhase	process_stats.h	/^        uint64_t lastUpdatePhase;$/;"	m	class:ProcessStats
lat	decoder.h	/^    uint16_t lat;$/;"	m	struct:DynUop
lat	weave_md1_mem.h	/^        uint32_t lat;$/;"	m	class:WeaveMemAccEvent
latency	mem_ctrls.h	/^        uint32_t latency;$/;"	m	class:SimpleMemory
latencyHist	ddr_mem.h	/^        VectorCounter latencyHist;$/;"	m	class:DDRMemory
latencyHist	detailed_mem.h	/^        VectorCounter latencyHist;$/;"	m	class:MemControllerBase
launchXtermDebugger	debug_harness.cpp	/^int launchXtermDebugger(int targetPid, LibInfo* libzsimAddrs) {$/;"	f
lc_int64	config.cpp	/^typedef long long lc_int64;  \/\/ NOLINT(runtime\/int)$/;"	t	file:
least_addr	g_heap/dlmalloc.h.c	/^  char*      least_addr;$/;"	m	struct:malloc_state	file:
least_bit	g_heap/dlmalloc.h.c	2877;"	d	file:
leave	barrier.h	/^        void leave(uint32_t tid) {$/;"	f	class:Barrier
leave	core.h	/^        virtual void leave() {}$/;"	f	class:Core
leave	ooo_core.cpp	/^void OOOCore::leave() {$/;"	f	class:OOOCore
leave	scheduler.h	/^        void leave(uint32_t pid, uint32_t tid, uint32_t cid) {$/;"	f	class:Scheduler
leave	timing_core.cpp	/^void TimingCore::leave() {$/;"	f	class:TimingCore
leaveLock	zsim.cpp	/^        lock_t leaveLock;$/;"	m	class:SyncEvent	file:
left	mtrand.h	/^        int left;          \/\/ number of values left before reload needed$/;"	m	class:MTRand
leftThreads	barrier.h	/^        uint32_t leftThreads; \/\/threads in LEFT state$/;"	m	class:Barrier
left_bits	g_heap/dlmalloc.h.c	2880;"	d	file:
leftmost_child	g_heap/dlmalloc.h.c	2370;"	d	file:
leftshift_for_tree_index	g_heap/dlmalloc.h.c	2852;"	d	file:
lessThan	repl_policies.h	/^            inline bool lessThan(const Rank& other, const uint64_t curTs) const {$/;"	f	struct:LFUReplPolicy::Rank
level	zsim.cpp	/^    uint32_t level;  \/\/ if 0, invalid. Used for VDSO-internal calls$/;"	m	struct:VdsoPatchData	file:
lfuInfo	repl_policies.h	/^            LFUInfo lfuInfo;$/;"	m	struct:LFUReplPolicy::Rank
lhBinSize	detailed_mem.h	/^        uint32_t lhBinSize;$/;"	m	class:MemControllerBase
lhNumBins	detailed_mem.h	/^        uint32_t lhNumBins;$/;"	m	class:MemControllerBase
libconfig	config.h	/^namespace libconfig {$/;"	n
libzsimAddrs	zsim.h	/^    struct LibInfo libzsimAddrs;$/;"	m	struct:GlobSimInfo	typeref:struct:GlobSimInfo::LibInfo
likely	log.h	48;"	d
limit	contention_sim.h	/^        volatile uint64_t limit;$/;"	m	class:ContentionSim
lineAddr	ideal_arrays.h	/^            Address lineAddr;$/;"	m	struct:IdealLRUArray::Entry
lineAddr	memory_hierarchy.h	/^    Address lineAddr;$/;"	m	struct:MemReq
lineAddrs	ideal_arrays.h	/^        Address* lineAddrs; \/\/lineId -> address, for replacements$/;"	m	class:IdealLRUPartArray
lineBits	zsim.cpp	/^uint32_t lineBits; \/\/process-local for performance, but logically global$/;"	v
lineId	cache_arrays.h	/^    uint32_t lineId;$/;"	m	struct:ZWalkInfo
lineId	ideal_arrays.h	/^            const uint32_t lineId;$/;"	m	struct:IdealLRUArray::Entry
lineId	ideal_arrays.h	/^            const uint32_t lineId;$/;"	m	struct:IdealLRUPartReplPolicy::Entry
lineMap	ideal_arrays.h	/^        g_unordered_map<Address, uint32_t> lineMap; \/\/address->lineId; if too slow, try an AATree, which does not alloc dynamically$/;"	m	class:IdealLRUArray
lineMap	ideal_arrays.h	/^        g_unordered_map<Address, uint32_t> lineMap; \/\/address->lineId; if too slow, try an AATree, which does not alloc dynamically$/;"	m	class:IdealLRUPartArray
lineSize	ddr_mem.h	/^        const uint32_t lineSize, ranksPerChannel, banksPerRank;$/;"	m	class:DDRMemory
lineSize	zsim.h	/^    uint32_t lineSize;$/;"	m	struct:GlobSimInfo
linkPrev	intrusive_list.h	/^    void linkPrev(T* p, InList<T>* lst) {$/;"	f	struct:InListNode
linuxPid	scheduler.h	/^            const uint32_t linuxPid;$/;"	m	struct:Scheduler::ThreadInfo
linuxTid	scheduler.h	/^            const uint32_t linuxTid;$/;"	m	struct:Scheduler::ThreadInfo
liveList	phase_slab_alloc.h	/^        g_list<std::pair<SlabList, uint64_t> > liveList;$/;"	m	class:PhaseSlabAlloc
loBit	mtrand.h	/^        uint64_t loBit(const uint64_t u) const { return u & 0x00000001UL; }$/;"	f	class:MTRand
loBits	mtrand.h	/^        uint64_t loBits(const uint64_t u) const { return u & 0x7fffffffUL; }$/;"	f	class:MTRand
load	filter_cache.h	/^        inline uint64_t load(Address vAddr, uint64_t curCycle) {$/;"	f	class:FilterCache
load	mtrand.h	/^inline void MTRand::load(uint64_t *const loadArray) {$/;"	f	class:MTRand
load	ooo_core.cpp	/^inline void OOOCore::load(Address addr) {$/;"	f	class:OOOCore
load	simple_core.cpp	/^void SimpleCore::load(Address addr) {$/;"	f	class:SimpleCore
loadAddrs	ooo_core.h	/^        Address loadAddrs[256];$/;"	m	class:OOOCore
loadAndRecord	timing_core.cpp	/^void TimingCore::loadAndRecord(Address addr) {$/;"	f	class:TimingCore
loadOps	decoder.h	/^            uint32_t loadOps[MAX_INSTR_LOADS];$/;"	m	struct:Decoder::Instr
loadPtr	core.h	/^    void (*loadPtr)(THREADID, ADDRINT);$/;"	m	struct:InstrFuncPtrs
loadQueue	ooo_core.h	/^        ReorderBuffer<32, 4> loadQueue;$/;"	m	class:OOOCore
loader	pin_cmd.h	/^            g_string loader;$/;"	m	struct:PinCmd::ProcCmdInfo
loads	ooo_core.h	/^        uint32_t loads;$/;"	m	class:OOOCore
loc	ddr_mem.h	/^            AddrLoc loc;$/;"	m	struct:DDRMemory::Request
lock	coherence_ctrls.h	/^        inline void lock() {$/;"	f	class:MESIBottomCC
lock	coherence_ctrls.h	/^        inline void lock() {$/;"	f	class:MESITopCC
lock	galloc.cpp	/^    lock_t lock;$/;"	m	struct:gm_segment	file:
lock	virt/port_virtualizer.h	/^        void lock() { futex_lock(&pvLock); }$/;"	f	class:PortVirtualizer
lock	zsim.h	/^    lock_t lock;$/;"	m	struct:ClockDomainInfo
lock_t	locks.h	/^typedef volatile uint32_t lock_t;$/;"	t
logFdErr	log.cpp	/^FILE* logFdErr = stderr;$/;"	v
logFdOut	log.cpp	/^FILE* logFdOut = stdout;$/;"	v
logHeader	log.cpp	/^const char* logHeader = "";$/;"	v
logTypeNames	log.cpp	/^const char* logTypeNames[] = {"Harness", "Config", "Process", "Cache", "Mem", "Sched", "FSVirt", "TimeVirt"};$/;"	v
logVec	contention_sim.h	/^            std::vector<std::pair<uint64_t, TimingEvent*> > logVec;$/;"	m	struct:ContentionSim::SimThreadData
log_lock	log.h	38;"	d
log_lock	log.h	41;"	d
log_printLock	log.cpp	/^static lock_t log_printLock;$/;"	v	file:
log_unlock	log.h	39;"	d
log_unlock	log.h	42;"	d
longAdvance	ooo_core.h	/^        void longAdvance(uint64_t& curCycle, uint64_t targetCycle) {$/;"	f	class:WindowStructure
longTermTargetSize	part_repl_policies.h	/^            uint64_t longTermTargetSize; \/\/in lines$/;"	m	struct:VantageReplPolicy::VantagePartInfo
lookahead	lookahead.cpp	/^namespace lookahead {$/;"	n	file:
lookahead	partitioner.h	/^namespace lookahead {$/;"	n
lookup	cache_arrays.cpp	/^int32_t SetAssocArray::lookup(const Address lineAddr, const MemReq* req, bool updateReplacement) {$/;"	f	class:SetAssocArray
lookup	cache_arrays.cpp	/^int32_t ZArray::lookup(const Address lineAddr, const MemReq* req, bool updateReplacement) {$/;"	f	class:ZArray
lookup	ideal_arrays.h	/^        int32_t lookup(const Address lineAddr, const MemReq* req, bool updateReplacement) {$/;"	f	class:IdealLRUArray
lookup	ideal_arrays.h	/^        int32_t lookup(const Address lineAddr, const MemReq* req, bool updateReplacement) {$/;"	f	class:IdealLRUPartArray
lookupArray	cache_arrays.h	/^        uint32_t* lookupArray; \/\/maps physical position to lineId$/;"	m	class:ZArray
lookupReal	virt/port_virtualizer.h	/^        int lookupReal(int virt) {$/;"	f	class:PortVirtualizer
lookupVirt	virt/port_virtualizer.h	/^        int lookupVirt(int real) {$/;"	f	class:PortVirtualizer
lruList	ideal_arrays.h	/^            InList<Entry> lruList;$/;"	m	struct:IdealLRUPartReplPolicy::IdPartInfo
lruList	ideal_arrays.h	/^        InList<Entry> lruList;$/;"	m	class:IdealLRUArray
mChnl	detailed_mem.h	/^        MemChannelBase* mChnl;$/;"	m	class:MemSchedulerBase
mParam	detailed_mem.h	/^        MemParam *mParam;$/;"	m	class:MemChannelBase
mParam	detailed_mem.h	/^        MemParam* mParam;$/;"	m	class:MemControllerBase
mParam	detailed_mem.h	/^        MemParam* mParam;$/;"	m	class:MemSchedulerBase
magic	g_heap/dlmalloc.h.c	/^  size_t     magic;$/;"	m	struct:malloc_state	file:
magic	g_heap/dlmalloc.h.c	/^  volatile size_t magic; \/\/dsm: Note that this is a fixed number now$/;"	m	struct:malloc_params	file:
magic	mtrand.h	/^        uint64_t magic(const uint64_t u) const { return loBit(u) ? 0x9908b0dfUL : 0x0UL; }$/;"	f	class:MTRand
main	fftoggle.cpp	/^int main(int argc, char *argv[]) {$/;"	f
main	zsim.cpp	/^int main(int argc, char *argv[]) {$/;"	f
main	zsim_harness.cpp	/^int main(int argc, char *argv[]) {$/;"	f
makeAdaptiveEvent	event_queue.h	/^AdaptiveEvent<G, F>* makeAdaptiveEvent(G get, F fire, uint64_t start, uint64_t target, uint64_t maxRate) {$/;"	f
makeImmutable	stats.h	/^        bool makeImmutable() {$/;"	f	class:AggregateStat
makeLambdaStat	stats.h	/^LambdaStat<F>* makeLambdaStat(F f) { return new LambdaStat<F>(f); }$/;"	f
makeLambdaVectorStat	stats.h	/^LambdaVectorStat<F>* makeLambdaVectorStat(F f, uint32_t size) { return new LambdaVectorStat<F>(f, size); }$/;"	f
mallinfo	g_heap/dlmalloc.h.c	/^struct mallinfo {$/;"	s	file:
malloc_chunk	g_heap/dlmalloc.h.c	/^struct malloc_chunk {$/;"	s	file:
malloc_corruption_error_count	g_heap/dlmalloc.h.c	/^int malloc_corruption_error_count;$/;"	v
malloc_getpagesize	g_heap/dlmalloc.h.c	1447;"	d	file:
malloc_getpagesize	g_heap/dlmalloc.h.c	1451;"	d	file:
malloc_getpagesize	g_heap/dlmalloc.h.c	1454;"	d	file:
malloc_getpagesize	g_heap/dlmalloc.h.c	1460;"	d	file:
malloc_getpagesize	g_heap/dlmalloc.h.c	1464;"	d	file:
malloc_getpagesize	g_heap/dlmalloc.h.c	1466;"	d	file:
malloc_getpagesize	g_heap/dlmalloc.h.c	1470;"	d	file:
malloc_getpagesize	g_heap/dlmalloc.h.c	1473;"	d	file:
malloc_getpagesize	g_heap/dlmalloc.h.c	1475;"	d	file:
malloc_global_mutex	g_heap/dlmalloc.h.c	/^static MLOCK_T malloc_global_mutex = PTHREAD_MUTEX_INITIALIZER;$/;"	v	file:
malloc_global_mutex	g_heap/dlmalloc.h.c	/^static MLOCK_T malloc_global_mutex = { 0, 0, 0};$/;"	v	file:
malloc_global_mutex	g_heap/dlmalloc.h.c	/^static MLOCK_T malloc_global_mutex = { 0, 0, NULL_THREAD};$/;"	v	file:
malloc_global_mutex	g_heap/dlmalloc.h.c	/^static MLOCK_T malloc_global_mutex;$/;"	v	file:
malloc_global_mutex_status	g_heap/dlmalloc.h.c	/^static volatile long malloc_global_mutex_status;$/;"	v	file:
malloc_params	g_heap/dlmalloc.h.c	/^struct malloc_params {$/;"	s	file:
malloc_segment	g_heap/dlmalloc.h.c	/^struct malloc_segment {$/;"	s	file:
malloc_state	g_heap/dlmalloc.h.c	/^struct malloc_state {$/;"	s	file:
malloc_tree_chunk	g_heap/dlmalloc.h.c	/^struct malloc_tree_chunk {$/;"	s	file:
mapLineAddr	ddr_mem.cpp	/^DDRMemory::AddrLoc DDRMemory::mapLineAddr(Address lineAddr) {$/;"	f	class:DDRMemory
mapper	part_repl_policies.h	/^        PartMapper* mapper;$/;"	m	class:PartReplPolicy
markForSleep	scheduler.h	/^        volatile uint32_t* markForSleep(uint32_t pid, uint32_t tid, uint64_t wakeupPhase) {$/;"	f	class:Scheduler
markLeave	ooo_core.h	/^        inline void markLeave(uint64_t leaveCycle) {$/;"	f	class:CycleQueue
markRetire	ooo_core.h	/^        inline void markRetire(uint64_t minRetireCycle) {$/;"	f	class:ReorderBuffer
markSrcEventDone	timing_event.cpp	/^void CrossingEvent::markSrcEventDone(uint64_t cycle) {$/;"	f	class:CrossingEvent
mark_inuse_foot	g_heap/dlmalloc.h.c	2997;"	d	file:
mark_inuse_foot	g_heap/dlmalloc.h.c	3018;"	d	file:
mark_smallmap	g_heap/dlmalloc.h.c	2868;"	d	file:
mark_treemap	g_heap/dlmalloc.h.c	2872;"	d	file:
markedForSleep	scheduler.h	/^            bool markedForSleep; \/\/if true, we will go to sleep on the next leave()$/;"	m	struct:Scheduler::ThreadInfo
mask	process_tree.h	/^        const g_vector<bool> mask;$/;"	m	class:ProcessTreeNode
mask	scheduler.h	/^            g_vector<bool> mask;$/;"	m	struct:Scheduler::ThreadInfo
matchingMemToSysCycle	ddr_mem.h	/^        inline uint64_t matchingMemToSysCycle(uint64_t memCycle) {$/;"	f	class:DDRMemory
maxAllowedFutexWakeups	scheduler.h	/^        volatile uint32_t maxAllowedFutexWakeups;$/;"	m	class:Scheduler
maxAperture	part_repl_policies.h	/^        double maxAperture; \/\/Maximum aperture allowed in each partition, must be < 1.0$/;"	m	class:VantageReplPolicy
maxBandwidth	detailed_mem.h	/^        uint64_t maxBandwidth;$/;"	m	class:MemControllerBase
maxMinInstrs	zsim.h	/^    uint64_t maxMinInstrs; \/\/terminate when all threads have reached this many instructions$/;"	m	struct:GlobSimInfo
maxN	bithacks.h	/^template <typename T, typename U, typename ... V> static inline T maxN(T a, U b, V... c) {$/;"	f
maxN	bithacks.h	/^template <typename T> static inline T maxN(T a) { return a; }$/;"	f
maxPhases	zsim.h	/^    uint64_t maxPhases; \/\/terminate when this many phases have been reached$/;"	m	struct:GlobSimInfo
maxProcEventualDumps	zsim.h	/^    uint64_t maxProcEventualDumps; \/\/term if the number of heartbeat-triggered process dumps reached this (MP\/MT)$/;"	m	struct:GlobSimInfo
maxRate	event_queue.h	/^        uint64_t maxRate;$/;"	m	class:AdaptiveEvent
maxRequestsPerCycle	mem_ctrls.h	/^        double maxRequestsPerCycle;$/;"	m	class:MD1Memory
maxSimTimeNs	zsim.h	/^    uint64_t maxSimTimeNs; \/\/terminate when the simulation time (bound+weave) exceeds this many ns$/;"	m	struct:GlobSimInfo
maxTotalInstrs	zsim.h	/^    uint64_t maxTotalInstrs; \/\/terminate when the aggregate number of instructions reaches this number$/;"	m	struct:GlobSimInfo
maxWakes	scheduler.h	/^            uint32_t maxWakes;$/;"	m	struct:Scheduler::FutexJoinInfo
max_footprint	g_heap/dlmalloc.h.c	/^  size_t     max_footprint;$/;"	m	struct:malloc_state	file:
max_size	g_std/stl_galloc.h	/^        size_type max_size() const { return size_t(-1); }$/;"	f	class:StlGlobAlloc
mchunk	g_heap/dlmalloc.h.c	/^typedef struct malloc_chunk  mchunk;$/;"	t	typeref:struct:malloc_chunk	file:
mchunkptr	g_heap/dlmalloc.h.c	/^typedef struct malloc_chunk* mchunkptr;$/;"	t	typeref:struct:malloc_chunk	file:
mem	ddr_mem.cpp	/^        DDRMemory* const mem;$/;"	m	class:SchedEvent	file:
mem	ddr_mem.cpp	/^        DDRMemory* mem;$/;"	m	class:DDRMemoryAccEvent	file:
mem	ddr_mem.cpp	/^        DDRMemory* mem;$/;"	m	class:RefreshEvent	file:
mem2chunk	g_heap/dlmalloc.h.c	2182;"	d	file:
memFreqKHz	ddr_mem.h	/^        uint64_t sysFreqKHz, memFreqKHz;$/;"	m	class:DDRMemory
memFreqKHz	detailed_mem.h	/^        uint64_t memFreqKHz;$/;"	m	class:MemControllerBase
memMinLatency	detailed_mem.h	/^        uint32_t memMinLatency[NUM_ACCESS_TYPES];$/;"	m	class:MemControllerBase
memToMicroSec	detailed_mem.h	/^        inline uint64_t memToMicroSec(uint64_t memCycle) { return memCycle*1000\/memFreqKHz; }$/;"	f	class:MemControllerBase
memToSysCycle	ddr_mem.h	/^        inline uint64_t memToSysCycle(uint64_t memCycle) { return (memCycle+1)*sysFreqKHz\/memFreqKHz; }$/;"	f	class:DDRMemory
memToSysCycle	detailed_mem.h	/^        inline uint64_t memToSysCycle(uint64_t memCycle) { return memCycle*sysFreqKHz\/memFreqKHz; }$/;"	f	class:MemControllerBase
memoizedHashes	hash.h	/^        uint32_t* memoizedHashes;$/;"	m	class:SHA1HashFamily
memoizedVal	hash.h	/^        uint64_t memoizedVal;$/;"	m	class:SHA1HashFamily
mems	dramsim_mem_ctrl.h	/^        const g_vector<MemObject*> mems;$/;"	m	class:SplitAddrMemory
mergeContinuous	detailed_mem_params.h	/^        bool mergeContinuous;$/;"	m	class:MemParam
mesiStateNames	memory_hierarchy.cpp	/^static const char* mesiStateNames[] = {"I", "S", "E", "M"};$/;"	v	file:
mflags	g_heap/dlmalloc.h.c	/^  flag_t     mflags;$/;"	m	struct:malloc_state	file:
min	config.cpp	/^    int32_t min;$/;"	m	struct:Range	file:
minActCycle	ddr_mem.h	/^        inline uint64_t minActCycle() const {$/;"	f	class:ActWindow
minAlloc	partitioner.h	/^        uint32_t minAlloc;$/;"	m	class:Partitioner
minAllocCycle	ooo_core.h	/^        inline uint64_t minAllocCycle() {$/;"	f	class:CycleQueue
minAllocCycle	ooo_core.h	/^        inline uint64_t minAllocCycle() {$/;"	f	class:ReorderBuffer
minBandwidth	detailed_mem.h	/^        uint64_t minBandwidth;$/;"	m	class:MemControllerBase
minLatency	detailed_mem.h	/^        uint32_t minLatency[NUM_ACCESS_TYPES];$/;"	m	class:MemControllerBase
minLatency	dramsim_mem_ctrl.h	/^        uint32_t minLatency;$/;"	m	class:DRAMSimMemory
minN	bithacks.h	/^template <typename T, typename U, typename ... V> static inline T minN(T a, U b, V... c) {$/;"	f
minN	bithacks.h	/^template <typename T> static inline T minN(T a) { return a; }$/;"	f
minPreCycle	ddr_mem.h	/^            uint64_t minPreCycle;   \/\/ if !open, time of last PRE; if open, min cycle PRE can be issued$/;"	m	struct:DDRMemory::Bank
minRdLatency	ddr_mem.h	/^        uint32_t minRdLatency;$/;"	m	class:DDRMemory
minRespCycle	ddr_mem.h	/^        uint64_t minRespCycle;$/;"	m	class:DDRMemory
minSchedCycle	ddr_mem.h	/^        uint64_t minSchedCycle; \/\/ TODO: delayed commands still not implemented$/;"	m	class:DDRMemory
minStartCycle	timing_event.h	/^        uint64_t minStartCycle;$/;"	m	class:TimingEvent
minWrLatency	ddr_mem.h	/^        uint32_t minWrLatency;$/;"	m	class:DDRMemory
minsize_for_tree_index	g_heap/dlmalloc.h.c	2857;"	d	file:
mispredBranches	ooo_core.h	/^        uint64_t instrs, uops, bbls, approxInstrs, mispredBranches;$/;"	m	class:OOOCore
missCache	partitioner.h	/^        mutable uint32_t* missCache;$/;"	m	class:UMonMonitor
missCacheValid	partitioner.h	/^        mutable bool missCacheValid;$/;"	m	class:UMonMonitor
mixBits	mtrand.h	/^        uint64_t mixBits(const uint64_t u, const uint64_t v) const { return hiBit(u) | loBits(v); }$/;"	f	class:MTRand
mmap_align	g_heap/dlmalloc.h.c	2629;"	d	file:
mmap_align	g_heap/dlmalloc.h.c	2631;"	d	file:
mmap_alloc	g_heap/dlmalloc.h.c	/^static void* mmap_alloc(mstate m, size_t nb) {$/;"	f	file:
mmap_resize	g_heap/dlmalloc.h.c	/^static mchunkptr mmap_resize(mstate m, mchunkptr oldp, size_t nb) {$/;"	f	file:
mmap_threshold	g_heap/dlmalloc.h.c	/^  size_t mmap_threshold;$/;"	m	struct:malloc_params	file:
monitor	part_repl_policies.h	/^        PartitionMonitor* monitor;$/;"	m	class:PartReplPolicy
monitors	partitioner.h	/^        g_vector<UMon*> monitors;       \/\/ individual monitors per partition$/;"	m	class:UMonMonitor
monotonicOffsetNs	zsim.h	/^    uint64_t monotonicOffsetNs;$/;"	m	struct:ClockDomainInfo
mparams	g_heap/dlmalloc.h.c	/^static struct malloc_params mparams;$/;"	v	typeref:struct:malloc_params	file:
mse	timing_cache.cpp	/^        MissStartEvent* mse;$/;"	m	class:MissResponseEvent	file:
mse	timing_cache.cpp	/^        MissStartEvent* mse;$/;"	m	class:MissWritebackEvent	file:
msegment	g_heap/dlmalloc.h.c	/^typedef struct malloc_segment  msegment;$/;"	t	typeref:struct:malloc_segment	file:
msegmentptr	g_heap/dlmalloc.h.c	/^typedef struct malloc_segment* msegmentptr;$/;"	t	typeref:struct:malloc_segment	file:
mspace	g_heap/dlmalloc.h.c	/^typedef void* mspace;$/;"	t	file:
mspace_calloc	g_heap/dlmalloc.h.c	/^void* mspace_calloc(mspace msp, size_t n_elements, size_t elem_size) {$/;"	f
mspace_footprint	g_heap/dlmalloc.h.c	/^size_t mspace_footprint(mspace msp) {$/;"	f
mspace_free	g_heap/dlmalloc.h.c	/^void mspace_free(mspace msp, void* mem) {$/;"	f
mspace_independent_calloc	g_heap/dlmalloc.h.c	/^void** mspace_independent_calloc(mspace msp, size_t n_elements,$/;"	f
mspace_independent_comalloc	g_heap/dlmalloc.h.c	/^void** mspace_independent_comalloc(mspace msp, size_t n_elements,$/;"	f
mspace_mallinfo	g_heap/dlmalloc.h.c	/^struct mallinfo mspace_mallinfo(mspace msp) {$/;"	f
mspace_malloc	g_heap/dlmalloc.h.c	/^void* mspace_malloc(mspace msp, size_t bytes) {$/;"	f
mspace_malloc_stats	g_heap/dlmalloc.h.c	/^void mspace_malloc_stats(mspace msp) {$/;"	f
mspace_mallopt	g_heap/dlmalloc.h.c	/^int mspace_mallopt(int param_number, int value) {$/;"	f
mspace_max_footprint	g_heap/dlmalloc.h.c	/^size_t mspace_max_footprint(mspace msp) {$/;"	f
mspace_memalign	g_heap/dlmalloc.h.c	/^void* mspace_memalign(mspace msp, size_t alignment, size_t bytes) {$/;"	f
mspace_ptr	galloc.cpp	/^    mspace mspace_ptr;$/;"	m	struct:gm_segment	file:
mspace_realloc	g_heap/dlmalloc.h.c	/^void* mspace_realloc(mspace msp, void* oldmem, size_t bytes) {$/;"	f
mspace_track_large_chunks	g_heap/dlmalloc.h.c	/^int mspace_track_large_chunks(mspace msp, int enable) {$/;"	f
mspace_trim	g_heap/dlmalloc.h.c	/^int mspace_trim(mspace msp, size_t pad) {$/;"	f
mspace_usable_size	g_heap/dlmalloc.h.c	/^size_t mspace_usable_size(void* mem) {$/;"	f
mstate	g_heap/dlmalloc.h.c	/^typedef struct malloc_state*    mstate;$/;"	t	typeref:struct:malloc_state	file:
mutex	g_heap/dlmalloc.h.c	/^  MLOCK_T    mutex;     \/* locate lock among fields that rarely change *\/$/;"	m	struct:malloc_state	file:
myId	detailed_mem.h	/^        uint32_t myId;$/;"	m	class:MemChannelBase
myId	detailed_mem.h	/^        uint32_t myId;$/;"	m	class:MemRankBase
n	ddr_mem.h	/^            Node* n;$/;"	m	struct:RequestQueue::iterator
name	cache.h	/^        g_string name;$/;"	m	class:Cache
name	coherence_ctrls.h	/^        g_string name;$/;"	m	class:MESICC
name	coherence_ctrls.h	/^        g_string name;$/;"	m	class:MESITerminalCC
name	core.h	/^        g_string name;$/;"	m	class:Core
name	core_recorder.h	/^        g_string name;$/;"	m	class:CoreRecorder
name	ddr_mem.h	/^        const g_string name;$/;"	m	class:DDRMemory
name	detailed_mem.h	/^        g_string name;$/;"	m	class:MemControllerBase
name	dramsim_mem_ctrl.h	/^        const g_string name;$/;"	m	class:SplitAddrMemory
name	dramsim_mem_ctrl.h	/^        g_string name;$/;"	m	class:DRAMSimMemory
name	mem_ctrls.h	/^        g_string name; \/\/barely used$/;"	m	class:MD1Memory
name	mem_ctrls.h	/^        g_string name;$/;"	m	class:SimpleMemory
name	ooo_core_recorder.h	/^        g_string name;$/;"	m	class:OOOCoreRecorder
name	prefetcher.h	/^        g_string name;$/;"	m	class:StreamPrefetcher
name	stats.h	/^        const char* name() const {$/;"	f	class:Stat
needsJoin	scheduler.h	/^            volatile bool needsJoin; \/\/after waiting on the scheduler, should we join the barrier, or is our cid good to go already?$/;"	m	struct:Scheduler::ThreadInfo
next	ddr_mem.cpp	/^        SchedEvent* next;  \/\/ for event freelist$/;"	m	class:SchedEvent	file:
next	g_heap/dlmalloc.h.c	/^  struct malloc_segment* next;   \/* ptr to next segment *\/$/;"	m	struct:malloc_segment	typeref:struct:malloc_segment::malloc_segment	file:
next	intrusive_list.h	/^    T* next;$/;"	m	struct:InListNode
next	phase_slab_alloc.h	/^            Slab* next;$/;"	m	struct:PhaseSlabAlloc::Slab
next	timing_event.h	/^        TimingEvent* next; \/\/used by PrioQueue --- PRIVATE$/;"	m	class:TimingEvent
next	timing_event.h	/^    TimingEventBlock* next;$/;"	m	struct:TimingEventBlock
next	utility_monitor.h	/^            struct Node* next;$/;"	m	struct:UMon::Node	typeref:struct:UMon::Node::Node
nextSchedCycle	ddr_mem.h	/^        uint64_t nextSchedCycle;$/;"	m	class:DDRMemory
nextSchedEvent	ddr_mem.h	/^        SchedEvent* nextSchedEvent;$/;"	m	class:DDRMemory
nextSysTick	detailed_mem.h	/^        uint64_t nextSysTick;$/;"	m	class:MemControllerBase
nextWin	ooo_core.h	/^        WinCycle* nextWin;$/;"	m	class:WindowStructure
next_chunk	g_heap/dlmalloc.h.c	2233;"	d	file:
next_pinuse	g_heap/dlmalloc.h.c	2237;"	d	file:
nonInclusiveHack	coherence_ctrls.h	/^        bool nonInclusiveHack;$/;"	m	class:MESIBottomCC
nonInclusiveHack	coherence_ctrls.h	/^        bool nonInclusiveHack;$/;"	m	class:MESICC
nonInclusiveHack	coherence_ctrls.h	/^        bool nonInclusiveHack;$/;"	m	class:MESITopCC
nopPtrs	zsim.cpp	/^static const InstrFuncPtrs nopPtrs = {NOPLoadStoreSingle, NOPLoadStoreSingle, NOPBasicBlock, NOPRecordBranch, NOPPredLoadStoreSingle, NOPPredLoadStoreSingle, FPTR_NOP};$/;"	v	file:
notifyDeschedule	process_stats.cpp	/^void ProcessStats::notifyDeschedule(uint32_t cid, uint32_t outgoingPid) {$/;"	f	class:ProcessStats
notifyEnd	process_tree.cpp	/^bool ProcessTreeNode::notifyEnd() {$/;"	f	class:ProcessTreeNode
notifyFutexWaitWoken	scheduler.cpp	/^void Scheduler::notifyFutexWaitWoken(uint32_t pid, uint32_t tid) {$/;"	f	class:Scheduler
notifyFutexWakeEnd	scheduler.cpp	/^void Scheduler::notifyFutexWakeEnd(uint32_t pid, uint32_t tid, uint32_t wokenUp) {$/;"	f	class:Scheduler
notifyFutexWakeStart	scheduler.cpp	/^void Scheduler::notifyFutexWakeStart(uint32_t pid, uint32_t tid, uint32_t maxWakes) {$/;"	f	class:Scheduler
notifyHarnessForDebugger	debug_zsim.cpp	/^void notifyHarnessForDebugger(int harnessPid) {$/;"	f
notifyJoin	core_recorder.cpp	/^uint64_t CoreRecorder::notifyJoin(uint64_t curCycle) {$/;"	f	class:CoreRecorder
notifyJoin	ooo_core_recorder.cpp	/^uint64_t OOOCoreRecorder::notifyJoin(uint64_t curCycle) {$/;"	f	class:OOOCoreRecorder
notifyLeave	core_recorder.cpp	/^void CoreRecorder::notifyLeave(uint64_t curCycle) {$/;"	f	class:CoreRecorder
notifyLeave	ooo_core_recorder.cpp	/^void OOOCoreRecorder::notifyLeave(uint64_t curCycle) {$/;"	f	class:OOOCoreRecorder
notifySleepEnd	scheduler.h	/^        void notifySleepEnd(uint32_t pid, uint32_t tid) {$/;"	f	class:Scheduler
notifyStart	process_tree.cpp	/^bool ProcessTreeNode::notifyStart() {$/;"	f	class:ProcessTreeNode
notifyTermination	scheduler.h	/^        void notifyTermination() {$/;"	f	class:Scheduler
nsToCycles	virt/time_conv.h	/^static inline uint64_t nsToCycles(uint64_t cycles) {$/;"	f
nsToTimespec	virt/time_conv.h	/^static inline struct timespec nsToTimespec(uint64_t ns) {$/;"	f
nsToTimeval	virt/time_conv.h	/^static inline struct timeval nsToTimeval(uint64_t ns) {$/;"	f
numBuckets	ideal_arrays.h	/^        uint32_t numBuckets;$/;"	m	class:IdealLRUPartReplPolicy
numCands	cache_arrays.h	/^    inline uint32_t numCands() const { return e-b; }$/;"	f	struct:SetAssocCands
numCands	cache_arrays.h	/^    inline uint32_t numCands() const { return e-b; }$/;"	f	struct:ZCands
numCands	repl_policies.h	/^        uint32_t numCands;$/;"	m	class:NRUReplPolicy
numCands	repl_policies.h	/^        uint32_t numCands;$/;"	m	class:RandReplPolicy
numCands	repl_policies.h	/^        uint32_t numCands;$/;"	m	class:TreeLRUReplPolicy
numChildren	timing_event.h	/^        uint32_t numChildren;$/;"	m	class:TimingEvent
numCores	partition_mapper.h	/^        uint32_t numCores;$/;"	m	class:CorePartMapper
numCores	partition_mapper.h	/^        uint32_t numCores;$/;"	m	class:InstrDataCorePartMapper
numCores	scheduler.h	/^        uint32_t numCores;$/;"	m	class:Scheduler
numCores	zsim.h	/^    uint32_t numCores;$/;"	m	struct:GlobSimInfo
numDomains	contention_sim.h	/^        uint32_t numDomains;$/;"	m	class:ContentionSim
numDomains	zsim.h	/^    uint32_t numDomains;$/;"	m	struct:GlobSimInfo
numFuncs	hash.h	/^        int numFuncs;$/;"	m	class:SHA1HashFamily
numFuncs	hash.h	/^        uint32_t numFuncs;$/;"	m	class:H3HashFamily
numInRegs	decoder.h	/^            uint32_t numInRegs;$/;"	m	struct:Decoder::Instr
numLines	cache.h	/^        uint32_t numLines;$/;"	m	class:Cache
numLines	cache_arrays.h	/^        uint32_t numLines;$/;"	m	class:SetAssocArray
numLines	cache_arrays.h	/^        uint32_t numLines;$/;"	m	class:ZArray
numLines	coherence_ctrls.h	/^        uint32_t numLines;$/;"	m	class:MESIBottomCC
numLines	coherence_ctrls.h	/^        uint32_t numLines;$/;"	m	class:MESICC
numLines	coherence_ctrls.h	/^        uint32_t numLines;$/;"	m	class:MESITerminalCC
numLines	coherence_ctrls.h	/^        uint32_t numLines;$/;"	m	class:MESITopCC
numLines	ideal_arrays.h	/^        uint32_t numLines;$/;"	m	class:IdealLRUArray
numLines	ideal_arrays.h	/^        uint32_t numLines;$/;"	m	class:IdealLRUPartArray
numLines	ideal_arrays.h	/^        uint32_t numLines;$/;"	m	class:IdealLRUPartReplPolicy
numLines	repl_policies.h	/^        uint32_t numLines;$/;"	m	class:LFUReplPolicy
numLines	repl_policies.h	/^        uint32_t numLines;$/;"	m	class:LRUReplPolicy
numLines	repl_policies.h	/^        uint32_t numLines;$/;"	m	class:NRUReplPolicy
numLoads	decoder.h	/^            uint32_t numLoads;$/;"	m	struct:Decoder::Instr
numMSHRs	timing_cache.h	/^        uint32_t numMSHRs, activeMisses;$/;"	m	class:TimingCache
numOutRegs	decoder.h	/^            uint32_t numOutRegs;$/;"	m	struct:Decoder::Instr
numParents	timing_event.h	/^        uint32_t numParents;$/;"	m	class:TimingEvent
numPartitions	partitioner.h	/^        uint32_t numPartitions;$/;"	m	class:LookaheadPartitioner
numPasses	hash.h	/^        int numPasses;$/;"	m	class:SHA1HashFamily
numPhases	zsim.h	/^    uint64_t numPhases;$/;"	m	struct:GlobSimInfo
numProcGroups	zsim.h	/^    uint32_t numProcGroups;$/;"	m	struct:GlobSimInfo
numProcs	partition_mapper.h	/^        uint32_t numProcs;$/;"	m	class:InstrDataProcessPartMapper
numProcs	partition_mapper.h	/^        uint32_t numProcs;$/;"	m	class:ProcessPartMapper
numProcs	zsim.h	/^    uint32_t numProcs;$/;"	m	struct:GlobSimInfo
numRecords	event_recorder.h	/^        inline size_t numRecords() const {$/;"	f	class:EventRecorder
numSets	cache_arrays.h	/^        uint32_t numSets;$/;"	m	class:SetAssocArray
numSets	cache_arrays.h	/^        uint32_t numSets;$/;"	m	class:ZArray
numSets	filter_cache.h	/^        uint32_t numSets;$/;"	m	class:FilterCache
numSharers	coherence_ctrls.h	/^            uint32_t numSharers;$/;"	m	struct:MESITopCC::Entry
numSharers	coherence_ctrls.h	/^        inline uint32_t numSharers(uint32_t lineId) {$/;"	f	class:MESITopCC
numSharers	coherence_ctrls.h	/^        uint32_t numSharers(uint32_t lineId) {return 0;} \/\/no sharers$/;"	f	class:MESITerminalCC
numSharers	coherence_ctrls.h	/^        uint32_t numSharers(uint32_t lineId) {return tcc->numSharers(lineId);}$/;"	f	class:MESICC
numSimThreads	contention_sim.h	/^        uint32_t numSimThreads;$/;"	m	class:ContentionSim
numStores	decoder.h	/^            uint32_t numStores;$/;"	m	struct:Decoder::Instr
obj	tick_event.h	/^        T* obj;$/;"	m	class:TickEvent
occ	prio_queue.h	/^        uint64_t occ; \/\/ bit i is 1 if array[i] is populated$/;"	m	struct:PrioQueue::PQBlock
occHist	scheduler.h	/^        VectorCounter occHist, runQueueHist;$/;"	m	class:Scheduler
occUnits	ooo_core.h	/^            uint8_t occUnits;$/;"	m	struct:WindowStructure::WinCycle
occupancy	ooo_core.h	/^        uint32_t occupancy;  \/\/ elements scheduled in the future$/;"	m	class:WindowStructure
ok_address	g_heap/dlmalloc.h.c	2959;"	d	file:
ok_address	g_heap/dlmalloc.h.c	2968;"	d	file:
ok_inuse	g_heap/dlmalloc.h.c	2963;"	d	file:
ok_inuse	g_heap/dlmalloc.h.c	2970;"	d	file:
ok_magic	g_heap/dlmalloc.h.c	2976;"	d	file:
ok_magic	g_heap/dlmalloc.h.c	2978;"	d	file:
ok_next	g_heap/dlmalloc.h.c	2961;"	d	file:
ok_next	g_heap/dlmalloc.h.c	2969;"	d	file:
ok_pinuse	g_heap/dlmalloc.h.c	2965;"	d	file:
ok_pinuse	g_heap/dlmalloc.h.c	2971;"	d	file:
oooBbl	core.h	/^    DynBbl oooBbl[0]; \/\/0 bytes, but will be 1-sized when we have an element (and that element has variable size as well)$/;"	m	struct:BblInfo
oooDecode	zsim.h	/^    bool oooDecode; \/\/if true, Decoder does OOO (instr->uop) decoding$/;"	m	struct:GlobSimInfo
op	part_repl_policies.h	/^            uint32_t op; \/\/original partition id: same as partition id when in partition, but does not change when moved to FFA (unmanaged region)$/;"	m	struct:VantageReplPolicy::LineInfo
op	virt/timeout.cpp	/^    int op;$/;"	m	struct:FutexInfo	file:
open	ddr_mem.h	/^            bool open;  \/\/ false indicates a PRE has been issued$/;"	m	struct:DDRMemory::Bank
openRow	ddr_mem.h	/^            uint64_t openRow;$/;"	m	struct:DDRMemory::Bank
operator !=	cache_arrays.h	/^        inline bool operator!=(const iterator& it) const { return it.x != x; }$/;"	f	struct:SetAssocCands::iterator
operator !=	cache_arrays.h	/^        inline bool operator!=(const iterator& it) const { return it.x != x; }$/;"	f	struct:ZCands::iterator
operator !=	ddr_mem.h	/^            inline bool operator!=(const iterator& it) const { return it.n != n; }$/;"	f	struct:RequestQueue::iterator
operator !=	g_std/stl_galloc.h	/^        template <class U> bool operator!=(const StlGlobAlloc<U>&) const { return false; }$/;"	f	class:StlGlobAlloc
operator ()	contention_sim.cpp	/^bool ContentionSim::CompareDomains::operator()(DomainData* d1, DomainData* d2) const {$/;"	f	class:ContentionSim::CompareDomains
operator ()	contention_sim.cpp	/^bool ContentionSim::CompareEvents::operator()(TimingEvent* lhs, TimingEvent* rhs) const {$/;"	f	class:ContentionSim::CompareEvents
operator ()	mtrand.h	/^inline double MTRand::operator()() {$/;"	f	class:MTRand
operator ()	ooo_core_recorder.cpp	/^bool OOOCoreRecorder::CompareRespEvents::operator()(OOORespEvent* e1, OOORespEvent* e2) const {$/;"	f	class:OOOCoreRecorder::CompareRespEvents
operator *	cache_arrays.h	/^        inline uint32_t operator*() const { return x->lineId; }$/;"	f	struct:ZCands::iterator
operator *	cache_arrays.h	/^        inline uint32_t operator*() const { return x; }$/;"	f	struct:SetAssocCands::iterator
operator *	ddr_mem.h	/^            inline T* operator*() const { return &(n->elem); }$/;"	f	struct:RequestQueue::iterator
operator <	cpuid.h	/^    bool operator< (const CpuIdRecord& other) const {$/;"	f	struct:CpuIdRecord
operator <<	mtrand.h	/^inline std::ostream& operator<<(std::ostream& os, const MTRand& mtrand) {$/;"	f
operator =	g_std/stl_galloc.h	/^        StlGlobAlloc<T>& operator=(const StlGlobAlloc&) { return *this; }$/;"	f	class:StlGlobAlloc
operator =	g_std/stl_galloc.h	/^        template <class U> StlGlobAlloc& operator=(const StlGlobAlloc<U>&) { return *this; }$/;"	f	class:StlGlobAlloc
operator =	mtrand.h	/^inline MTRand& MTRand::operator=(const MTRand& o) {$/;"	f	class:MTRand
operator ==	cache_arrays.h	/^        inline bool operator==(const iterator& it) const { return it.x == x; }$/;"	f	struct:SetAssocCands::iterator
operator ==	cache_arrays.h	/^        inline bool operator==(const iterator& it) const { return it.x == x; }$/;"	f	struct:ZCands::iterator
operator ==	ddr_mem.h	/^            inline bool operator==(const iterator& it) const { return it.n == n; }$/;"	f	struct:RequestQueue::iterator
operator ==	g_std/stl_galloc.h	/^        template <class U> bool operator==(const StlGlobAlloc<U>&) const { return true; }$/;"	f	class:StlGlobAlloc
operator >>	mtrand.h	/^inline std::istream& operator>>(std::istream& is, MTRand& mtrand) {$/;"	f
operator delete	galloc.h	/^        inline void operator delete(void *p, size_t sz) {$/;"	f	class:GlobAlloc
operator delete	galloc.h	/^        void operator delete (void* p, void* ptr) {}$/;"	f	class:GlobAlloc
operator delete	timing_event.h	/^        void operator delete (void* p, EventRecorder& evRec) {$/;"	f	class:TimingEvent
operator delete	timing_event.h	/^        void operator delete (void* p, EventRecorder* evRec) {$/;"	f	class:TimingEvent
operator delete	timing_event.h	/^        void operator delete(void*, size_t) {$/;"	f	class:TimingEvent
operator delete	timing_event.h	/^    void operator delete (void* p, EventRecorder* evRec) {$/;"	f	struct:TimingEventBlock
operator delete	timing_event.h	/^    void operator delete(void*, size_t) {$/;"	f	struct:TimingEventBlock
operator new	galloc.h	/^        inline void* operator new (size_t sz) {$/;"	f	class:GlobAlloc
operator new	galloc.h	/^        inline void* operator new (size_t sz, void* ptr) {$/;"	f	class:GlobAlloc
operator new	timing_event.h	/^        void* operator new (size_t sz, EventRecorder& evRec) {$/;"	f	class:TimingEvent
operator new	timing_event.h	/^        void* operator new (size_t sz, EventRecorder* evRec) {$/;"	f	class:TimingEvent
operator new	timing_event.h	/^    void* operator new (size_t sz, EventRecorder* evRec) {$/;"	f	struct:TimingEventBlock
ordblks	g_heap/dlmalloc.h.c	/^  MALLINFO_FIELD_TYPE ordblks;  \/* number of free chunks *\/$/;"	m	struct:mallinfo	file:
origStartCycle	core_recorder.cpp	/^        uint64_t origStartCycle;$/;"	m	class:TimingCoreEvent	file:
origStartCycle	timing_event.h	/^        uint64_t origStartCycle;$/;"	m	class:CrossingEvent
other	g_std/stl_galloc.h	/^        template <class U> struct rebind { typedef StlGlobAlloc<U> other; };$/;"	t	struct:StlGlobAlloc::rebind
outCfg	config.h	/^        libconfig::Config* outCfg;$/;"	m	class:Config
outQueue	scheduler.h	/^        InList<ThreadInfo> outQueue;$/;"	m	class:Scheduler
outRegs	decoder.h	/^            uint32_t outRegs[MAX_INSTR_REG_WRITES];$/;"	m	struct:Decoder::Instr
outputDir	zsim.h	/^    const char* outputDir; \/\/all the output files mst be dumped here. Stored because complex workloads often change dir, then spawn...$/;"	m	struct:GlobSimInfo
overflowQueue	ddr_mem.h	/^        std::deque<Request> overflowQueue;$/;"	m	class:DDRMemory
overhead_for	g_heap/dlmalloc.h.c	2252;"	d	file:
owner	intrusive_list.h	/^    InList<T>* owner;$/;"	m	struct:InListNode
p	ideal_arrays.h	/^            uint32_t p;$/;"	m	struct:IdealLRUPartReplPolicy::Entry
p	part_repl_policies.h	/^            uint32_t p; \/\/partition ID$/;"	m	struct:VantageReplPolicy::LineInfo
p	part_repl_policies.h	/^            uint32_t p;$/;"	m	struct:WayPartReplPolicy::WayPartInfo
pNext	mtrand.h	/^        uint64_t *pNext;     \/\/ next value to get from state$/;"	m	class:MTRand
pad	barrier.h	/^            uint32_t pad;$/;"	m	struct:Barrier::ThreadSyncInfo
pad	barrier.h	/^        uint32_t pad[16];$/;"	m	class:Barrier
pad	core.h	/^    uint64_t pad[1];$/;"	m	struct:InstrFuncPtrs
pad	decoder.h	/^    uint8_t pad; \/\/pad to 4-byte multiple$/;"	m	struct:DynUop
pad_request	g_heap/dlmalloc.h.c	2191;"	d	file:
page_align	g_heap/dlmalloc.h.c	2618;"	d	file:
page_size	g_heap/dlmalloc.h.c	/^  size_t page_size;$/;"	m	struct:malloc_params	file:
panic	log.h	75;"	d
parallelThreads	barrier.h	/^        uint32_t parallelThreads;$/;"	m	class:Barrier
parent	g_heap/dlmalloc.h.c	/^  struct malloc_tree_chunk* parent;$/;"	m	struct:malloc_tree_chunk	typeref:struct:malloc_tree_chunk::malloc_tree_chunk	file:
parent	prefetcher.h	/^        MemObject* parent;$/;"	m	class:StreamPrefetcher
parentDone	ddr_mem.cpp	/^        void parentDone(uint64_t startCycle) {$/;"	f	class:RefreshEvent
parentDone	ddr_mem.cpp	/^        void parentDone(uint64_t startCycle) {$/;"	f	class:SchedEvent
parentDone	tick_event.h	/^        void parentDone(uint64_t startCycle) {$/;"	f	class:TickEvent
parentDone	timing_event.cpp	/^void CrossingEvent::parentDone(uint64_t startCycle) {$/;"	f	class:CrossingEvent
parentDone	timing_event.cpp	/^void TimingEvent::parentDone(uint64_t startCycle) {$/;"	f	class:TimingEvent
parentDone	timing_event.h	/^                virtual void parentDone(uint64_t startCycle) {$/;"	f	class:CrossingEvent::CrossingSrcEvent
parentDone	timing_event.h	/^        virtual void parentDone(uint64_t startCycle) {$/;"	f	class:DelayEvent
parentEv	timing_event.h	/^        TimingEvent* parentEv; \/\/stored exclusively for resp-req xing chaining$/;"	m	class:CrossingEvent
parentId	detailed_mem.h	/^        uint32_t parentId;$/;"	m	class:MemRankBase
parentIdx	cache_arrays.h	/^    int32_t parentIdx;$/;"	m	struct:ZWalkInfo
parentRTTs	coherence_ctrls.h	/^        g_vector<uint32_t> parentRTTs;$/;"	m	class:MESIBottomCC
parents	coherence_ctrls.h	/^        g_vector<MemObject*> parents;$/;"	m	class:MESIBottomCC
part	partitioner.h	/^                Partitioner* part;$/;"	m	class:Partitioner::PartitionEvent
partGranularity	part_repl_policies.h	/^        uint32_t partGranularity; \/\/number of partitions that UMON\/LookaheadPartitioner expects$/;"	m	class:VantageReplPolicy
partInfo	ideal_arrays.h	/^        IdPartInfo* partInfo;$/;"	m	class:IdealLRUPartReplPolicy
partInfo	part_repl_policies.h	/^        PartInfo* partInfo;$/;"	m	class:WayPartReplPolicy
partInfo	part_repl_policies.h	/^        VantagePartInfo* partInfo;$/;"	m	class:VantageReplPolicy
partPortion	part_repl_policies.h	/^        double partPortion; \/\/how much of the cache do we devote to the partition's target sizes?$/;"	m	class:VantageReplPolicy
partSlack	part_repl_policies.h	/^        double partSlack; \/\/how much the aperture curve reacts to "cushion" the load. partSlack+targetSize sets aperture to 1.0$/;"	m	class:VantageReplPolicy
partition	lookahead.cpp	/^void LookaheadPartitioner::partition() {$/;"	f	class:LookaheadPartitioner
partitions	ideal_arrays.h	/^        uint32_t partitions;$/;"	m	class:IdealLRUPartReplPolicy
partitions	part_repl_policies.h	/^        uint32_t partitions;$/;"	m	class:VantageReplPolicy
partitions	part_repl_policies.h	/^        uint32_t partitions;$/;"	m	class:WayPartReplPolicy
patchRoot	process_tree.h	/^        const char* patchRoot; \/\/used in syscall patching$/;"	m	class:ProcessTreeNode
patchRoot	virt/common.h	/^    const char* patchRoot;$/;"	m	struct:PrePatchArgs
pauseLocks	zsim.h	/^    lock_t pauseLocks[256]; \/\/per-process pauses$/;"	m	struct:GlobSimInfo
pc	scheduler.h	/^            const uint64_t pc;$/;"	m	struct:Scheduler::FakeLeaveInfo
pendingPidCleanups	scheduler.h	/^        g_vector<std::pair<uint32_t, uint32_t>> pendingPidCleanups; \/\/(pid, osPid) pairs of abruptly terminated processes$/;"	m	class:Scheduler
pendingQueue	timing_cache.h	/^        g_vector<TimingEvent*> pendingQueue;$/;"	m	class:TimingCache
perProcessCpuEnum	zsim.h	/^    bool perProcessCpuEnum; \/\/if true, cpus are enumerated according to per-process masks (e.g., a 16-core mask in a 64-core sim sees 16 cores)$/;"	m	struct:GlobSimInfo
perProcessDir	zsim_harness.cpp	/^bool perProcessDir, aslr;$/;"	v
perProcessEndFlag	zsim.cpp	/^volatile uint32_t perProcessEndFlag;$/;"	v
period	event_queue.h	/^        uint64_t period;$/;"	m	class:Event
periodicStatsBackend	zsim.h	/^    StatsBackend* periodicStatsBackend;$/;"	m	struct:GlobSimInfo
phaseCount	barrier.h	/^        uint32_t phaseCount; \/\/INTERNAL, for LEFT->OFFLINE bookkeeping overhead reduction purposes$/;"	m	class:Barrier
phaseEndCycle	null_core.h	/^        uint64_t phaseEndCycle; \/\/next stopping point$/;"	m	class:NullCore
phaseEndCycle	ooo_core.h	/^        uint64_t phaseEndCycle; \/\/next stopping point$/;"	m	class:OOOCore
phaseEndCycle	simple_core.h	/^        uint64_t phaseEndCycle; \/\/next stopping point$/;"	m	class:SimpleCore
phaseEndCycle	timing_core.h	/^        uint64_t phaseEndCycle; \/\/phase 1 end clock$/;"	m	class:TimingCore
phaseLength	zsim.h	/^    uint32_t phaseLength;$/;"	m	struct:GlobSimInfo
pht	ooo_core.h	/^        uint8_t pht[1 << LB];$/;"	m	class:BranchPredictorPAg
pid	g_heap/dlmalloc.h.c	/^    pid_t pid;$/;"	m	struct:threadid_t	file:
pid	zsim_harness.cpp	/^    int pid;$/;"	m	struct:ProcInfo	file:
pinCmd	zsim.h	/^    PinCmd* pinCmd; \/\/enables calls to exec() to modify Pin's calling arguments, see zsim.cpp$/;"	m	struct:GlobSimInfo
pinCmd	zsim_harness.cpp	/^PinCmd* pinCmd;$/;"	v
pinuse	g_heap/dlmalloc.h.c	2220;"	d	file:
pointer	g_std/stl_galloc.h	/^        typedef T* pointer;$/;"	t	class:StlGlobAlloc
poisonRange	ooo_core.h	/^        void poisonRange(uint64_t curCycle, uint64_t targetCycle, uint8_t portMask) {$/;"	f	class:WindowStructure
popRecord	event_recorder.h	/^        void popRecord() {$/;"	f	class:EventRecorder
pop_back	intrusive_list.h	/^        void pop_back() {$/;"	f	class:InList
pop_front	intrusive_list.h	/^        void pop_front() {$/;"	f	class:InList
pop_front	phase_slab_alloc.h	/^            Slab* pop_front() {$/;"	f	class:PhaseSlabAlloc::SlabList
populateRegArrays	decoder.cpp	/^void Decoder::populateRegArrays(Instr& instr, uint32_t* srcRegs, uint32_t* dstRegs) {$/;"	f	class:Decoder
portDomain	process_tree.h	/^        const uint32_t portDomain;$/;"	m	class:ProcessTreeNode
portMask	decoder.h	/^    uint8_t portMask;$/;"	m	struct:DynUop
portVirt	zsim.h	/^    PortVirtualizer* portVirt[MAX_PORT_DOMAINS];$/;"	m	struct:GlobSimInfo
pos	cache_arrays.h	/^    uint32_t pos;$/;"	m	struct:ZWalkInfo
postDelay	detailed_mem.h	/^        uint32_t postDelay[NUM_ACCESS_TYPES];$/;"	m	class:MemControllerBase
postDelay	timing_event.h	/^        uint32_t postDelay; \/\/we could get by with one delay, but pre\/post makes it easier to code$/;"	m	class:TimingEvent
postDelay	weave_md1_mem.h	/^        uint32_t preDelay, postDelay;$/;"	m	class:WeaveMD1Memory
postDelay	weave_md1_mem.h	/^        uint32_t preDelay, postDelay;$/;"	m	class:WeaveSimpleMemory
postDelayRd	ddr_mem.h	/^        uint32_t preDelay, postDelayRd, postDelayWr;$/;"	m	class:DDRMemory
postDelayWr	ddr_mem.h	/^        uint32_t preDelay, postDelayRd, postDelayWr;$/;"	m	class:DDRMemory
postInit	contention_sim.cpp	/^void ContentionSim::postInit() {$/;"	f	class:ContentionSim
postMortemLock	contention_sim.h	/^        lock_t postMortemLock;$/;"	m	class:ContentionSim
postPatchFunctions	virt/virt.cpp	/^PostPatchFn postPatchFunctions[MAX_THREADS];$/;"	v
postSlack	timing_event.h	/^        uint32_t preSlack, postSlack;$/;"	m	class:CrossingEvent
postinsert	cache_arrays.cpp	/^void SetAssocArray::postinsert(const Address lineAddr, const MemReq* req, uint32_t candidate) {$/;"	f	class:SetAssocArray
postinsert	cache_arrays.cpp	/^void ZArray::postinsert(const Address lineAddr, const MemReq* req, uint32_t candidate) {$/;"	f	class:ZArray
postinsert	ideal_arrays.h	/^        void postinsert(const Address lineAddr, const MemReq* req, uint32_t lineId) {$/;"	f	class:IdealLRUArray
postinsert	ideal_arrays.h	/^        void postinsert(const Address lineAddr, const MemReq* req, uint32_t lineId) {$/;"	f	class:IdealLRUPartArray
powerDownCycle	detailed_mem_params.h	/^        uint32_t powerDownCycle;$/;"	m	class:MemParam
powerValue	detailed_mem.h	/^        struct powerValue {$/;"	s	class:MemControllerBase
pp_callback	debug_zsim.cpp	/^static int pp_callback(dl_phdr_info* info, size_t size, void* data) {$/;"	f	file:
pq	contention_sim.h	/^            PrioQueue<TimingEvent, PQ_BLOCKS> pq;$/;"	m	struct:ContentionSim::DomainData
pqLock	contention_sim.h	/^            lock_t pqLock; \/\/used on phase 1 enqueues$/;"	m	struct:ContentionSim::DomainData
preDelay	ddr_mem.h	/^        uint32_t preDelay, postDelayRd, postDelayWr;$/;"	m	class:DDRMemory
preDelay	detailed_mem.h	/^        uint32_t preDelay[NUM_ACCESS_TYPES];$/;"	m	class:MemControllerBase
preDelay	timing_event.h	/^        uint32_t preDelay;$/;"	m	class:TimingEvent
preDelay	weave_md1_mem.h	/^        uint32_t preDelay, postDelay;$/;"	m	class:WeaveMD1Memory
preDelay	weave_md1_mem.h	/^        uint32_t preDelay, postDelay;$/;"	m	class:WeaveSimpleMemory
prePatchFunctions	virt/virt.cpp	/^PrePatchFn prePatchFunctions[MAX_SYSCALLS];$/;"	v
preSlack	timing_event.h	/^        uint32_t preSlack, postSlack;$/;"	m	class:CrossingEvent
prechargeCount	detailed_mem.h	/^        uint64_t prechargeCount;$/;"	m	class:MemRankBase
pred	prefetcher.h	/^        bool pred() const { return count >= T; }$/;"	f	class:SatCounter
predFalseMemOp	ooo_core.cpp	/^void OOOCore::predFalseMemOp() {$/;"	f	class:OOOCore
predLoadPtr	core.h	/^    void (*predLoadPtr)(THREADID, ADDRINT, BOOL);$/;"	m	struct:InstrFuncPtrs
predStorePtr	core.h	/^    void (*predStorePtr)(THREADID, ADDRINT, BOOL);$/;"	m	struct:InstrFuncPtrs
predict	ooo_core.h	/^        inline bool predict(Address branchPc, bool taken) {$/;"	f	class:BranchPredictorPAg
preinsert	cache_arrays.cpp	/^uint32_t SetAssocArray::preinsert(const Address lineAddr, const MemReq* req, Address* wbLineAddr) { \/\/TODO: Give out valid bit of wb cand?$/;"	f	class:SetAssocArray
preinsert	cache_arrays.cpp	/^uint32_t ZArray::preinsert(const Address lineAddr, const MemReq* req, Address* wbLineAddr) {$/;"	f	class:ZArray
preinsert	ideal_arrays.h	/^        uint32_t preinsert(const Address lineAddr, const MemReq* req, Address* wbLineAddr) {$/;"	f	class:IdealLRUArray
preinsert	ideal_arrays.h	/^        uint32_t preinsert(const Address lineAddr, const MemReq* req, Address* wbLineAddr) {$/;"	f	class:IdealLRUPartArray
prepend	phase_slab_alloc.h	/^            void prepend(SlabList& lst) {$/;"	f	class:PhaseSlabAlloc::SlabList
prepend_alloc	g_heap/dlmalloc.h.c	/^static void* prepend_alloc(mstate m, char* newbase, char* oldbase,$/;"	f	file:
prev	intrusive_list.h	/^    T* prev;$/;"	m	struct:InListNode
prevActvPowerDownCycle	detailed_mem.h	/^        uint64_t prevActvPowerDownCycle;$/;"	m	class:MemRankBase
prevBbl	ooo_core.h	/^        BblInfo* prevBbl;$/;"	m	class:OOOCore
prevIdlePowerDownCycle	detailed_mem.h	/^        uint64_t prevIdlePowerDownCycle;$/;"	m	class:MemRankBase
prevIdleStandbyCycle	detailed_mem.h	/^        uint64_t prevIdleStandbyCycle;$/;"	m	class:MemRankBase
prevRespCycle	core_recorder.h	/^        uint64_t prevRespCycle;$/;"	m	class:CoreRecorder
prevRespEvent	core_recorder.h	/^        TimingEvent* prevRespEvent;$/;"	m	class:CoreRecorder
prev_chunk	g_heap/dlmalloc.h.c	2234;"	d	file:
prev_foot	g_heap/dlmalloc.h.c	/^  size_t                    prev_foot;$/;"	m	struct:malloc_tree_chunk	file:
prev_foot	g_heap/dlmalloc.h.c	/^  size_t               prev_foot;  \/* Size of previous chunk (if free).  *\/$/;"	m	struct:malloc_chunk	file:
printHeartbeat	zsim_harness.cpp	/^static void printHeartbeat(GlobSimInfo* zinfo) {$/;"	f	file:
printState	scheduler.h	/^        void printState() {$/;"	f	class:Scheduler
printThreadState	scheduler.h	/^        void printThreadState(uint32_t pid, uint32_t tid) {$/;"	f	class:Scheduler
prio	contention_sim.h	/^            uint32_t prio;$/;"	m	struct:ContentionSim::DomainData
prioritizedAccessType	detailed_mem.h	/^        MemAccessType prioritizedAccessType;$/;"	m	class:MemSchedulerDefault
privCycle	timing_event.h	/^        uint64_t privCycle; \/\/only touched by ContentionSim$/;"	m	class:TimingEvent
procArray	zsim.h	/^    ProcessTreeNode** procArray; \/\/a flat view of the process tree, where each process is indexed by procIdx$/;"	m	struct:GlobSimInfo
procEventualDumps	zsim.h	/^    uint64_t procEventualDumps;$/;"	m	struct:GlobSimInfo
procExited	zsim.h	/^    ProcExitStatus* procExited; \/\/starts with all set to PROC_RUNNING, each process sets to PROC_EXITED or PROC_RESTARTME on exit. Used to detect untimely deaths (that don;t go thropugh SimEnd) in the harness and abort.$/;"	m	struct:GlobSimInfo
procIdx	process_tree.h	/^        uint32_t procIdx;$/;"	m	class:ProcessTreeNode
procIdx	zsim.cpp	/^uint32_t procIdx;$/;"	v
procInfo	pin_cmd.h	/^        g_vector<ProcCmdInfo> procInfo; \/\/one entry for each process that the harness launches (not for child procs)$/;"	m	class:PinCmd
procMask	zsim.cpp	/^Address procMask;$/;"	v
procTree	zsim.h	/^    ProcessTreeNode* procTree;$/;"	m	struct:GlobSimInfo
procTreeNode	zsim.cpp	/^static ProcessTreeNode* procTreeNode;$/;"	v	file:
processAccess	coherence_ctrls.cpp	/^uint64_t MESIBottomCC::processAccess(Address lineAddr, uint32_t lineId, AccessType type, uint64_t cycle, uint32_t srcId, uint32_t flags) {$/;"	f	class:MESIBottomCC
processAccess	coherence_ctrls.cpp	/^uint64_t MESITopCC::processAccess(Address lineAddr, uint32_t lineId, AccessType type, uint32_t childId, bool haveExclusive,$/;"	f	class:MESITopCC
processAccess	coherence_ctrls.h	/^        uint64_t processAccess(const MemReq& req, int32_t lineId, uint64_t startCycle,  uint64_t* getDoneCycle = NULL) {$/;"	f	class:MESITerminalCC
processAccess	coherence_ctrls.h	/^        uint64_t processAccess(const MemReq& req, int32_t lineId, uint64_t startCycle, uint64_t* getDoneCycle = NULL) {$/;"	f	class:MESICC
processCleanup	scheduler.h	/^        void processCleanup(uint32_t pid) {$/;"	f	class:Scheduler
processCycles	process_stats.h	/^        g_vector<uint64_t> processCycles, processInstrs;$/;"	m	class:ProcessStats
processEviction	coherence_ctrls.cpp	/^uint64_t MESIBottomCC::processEviction(Address wbLineAddr, uint32_t lineId, bool lowerLevelWriteback, uint64_t cycle, uint32_t srcId) {$/;"	f	class:MESIBottomCC
processEviction	coherence_ctrls.cpp	/^uint64_t MESITopCC::processEviction(Address wbLineAddr, uint32_t lineId, bool* reqWriteback, uint64_t cycle, uint32_t srcId) {$/;"	f	class:MESITopCC
processEviction	coherence_ctrls.h	/^        uint64_t processEviction(const MemReq& triggerReq, Address wbLineAddr, int32_t lineId, uint64_t startCycle) {$/;"	f	class:MESICC
processEviction	coherence_ctrls.h	/^        uint64_t processEviction(const MemReq& triggerReq, Address wbLineAddr, int32_t lineId, uint64_t startCycle) {$/;"	f	class:MESITerminalCC
processInstrs	process_stats.h	/^        g_vector<uint64_t> processCycles, processInstrs;$/;"	m	class:ProcessStats
processInv	coherence_ctrls.h	/^        uint64_t processInv(Address lineAddr, int32_t lineId, InvType type, bool* reqWriteback, uint64_t startCycle, uint32_t srcId) {$/;"	f	class:MESICC
processInv	coherence_ctrls.h	/^        uint64_t processInv(Address lineAddr, int32_t lineId, InvType type, bool* reqWriteback, uint64_t startCycle, uint32_t srcId) {$/;"	f	class:MESITerminalCC
processInval	coherence_ctrls.cpp	/^uint64_t MESITopCC::processInval(Address lineAddr, uint32_t lineId, InvType type, bool* reqWriteback, uint64_t cycle, uint32_t srcId) {$/;"	f	class:MESITopCC
processInval	coherence_ctrls.cpp	/^void MESIBottomCC::processInval(Address lineAddr, uint32_t lineId, InvType type, bool* reqWriteback) {$/;"	f	class:MESIBottomCC
processNonInclusiveWriteback	coherence_ctrls.cpp	/^uint64_t MESIBottomCC::processNonInclusiveWriteback(Address lineAddr, AccessType type, uint64_t cycle, MESIState* state, uint32_t srcId, uint32_t flags) {$/;"	f	class:MESIBottomCC
processOffsetNs	zsim.h	/^    uint64_t processOffsetNs;$/;"	m	struct:ClockDomainInfo
processStats	zsim.h	/^    ProcessStats* processStats;$/;"	m	struct:GlobSimInfo
processWritebackOnAccess	coherence_ctrls.cpp	/^void MESIBottomCC::processWritebackOnAccess(Address lineAddr, uint32_t lineId, AccessType type) {$/;"	f	class:MESIBottomCC
produceCrossings	timing_event.cpp	/^void TimingEvent::produceCrossings(EventRecorder* evRec) {$/;"	f	class:TimingEvent
profAAE	repl_policies.h	/^        Counter profAAE, profNoViolEv; \/\/access after eviction violation$/;"	m	class:ProfViolReplPolicy
profAccAvgPower	detailed_mem.h	/^        Counter profAccAvgPower[pwCounterNum];$/;"	m	class:MemControllerBase
profAccesses	prefetcher.h	/^        Counter profAccesses, profPrefetches, profDoublePrefetches, profPageHits, profHits, profShortHits, profStrideSwitches, profLowConfAccs;$/;"	m	class:StreamPrefetcher
profActivate	detailed_mem.h	/^        Counter profActivate;$/;"	m	class:MemControllerBase
profBandwidth	detailed_mem.h	/^        Counter profBandwidth[bwCounterNum];$/;"	m	class:MemControllerBase
profClampedLoads	mem_ctrls.h	/^        Counter profClampedLoads;$/;"	m	class:MD1Memory
profCurAvgPower	detailed_mem.h	/^        Counter profCurAvgPower[pwCounterNum];$/;"	m	class:MemControllerBase
profDecodeStalls	ooo_core.h	/^        Counter profFetchStalls, profDecodeStalls, profIssueStalls;$/;"	m	class:OOOCore
profDemotions	part_repl_policies.h	/^            Counter profDemotions;$/;"	m	struct:VantageReplPolicy::VantagePartInfo
profDoublePrefetches	prefetcher.h	/^        Counter profAccesses, profPrefetches, profDoublePrefetches, profPageHits, profHits, profShortHits, profStrideSwitches, profLowConfAccs;$/;"	m	class:StreamPrefetcher
profEvictions	part_repl_policies.h	/^            Counter profEvictions;$/;"	m	struct:VantageReplPolicy::VantagePartInfo
profExtEvictions	part_repl_policies.h	/^    Counter profExtEvictions; \/\/ from other partitions (if too large, we're probably doing something wrong, e.g., too small an adjustment period)$/;"	m	struct:PartInfo
profExtendedSizeCycles	part_repl_policies.h	/^            Counter profExtendedSizeCycles;$/;"	m	struct:VantageReplPolicy::VantagePartInfo
profFWD	coherence_ctrls.h	/^        Counter profINV, profINVX, profFWD \/*received from upstream*\/;$/;"	m	class:MESIBottomCC
profFetchStalls	ooo_core.h	/^        Counter profFetchStalls, profDecodeStalls, profIssueStalls;$/;"	m	class:OOOCore
profGETNetLat	coherence_ctrls.h	/^        Counter profGETNextLevelLat, profGETNetLat;$/;"	m	class:MESIBottomCC
profGETNextLevelLat	coherence_ctrls.h	/^        Counter profGETNextLevelLat, profGETNetLat;$/;"	m	class:MESIBottomCC
profGETSHit	coherence_ctrls.h	/^        Counter profGETSHit, profGETSMiss, profGETXHit, profGETXMissIM \/*from invalid*\/, profGETXMissSM \/*from S, i.e. upgrade misses*\/;$/;"	m	class:MESIBottomCC
profGETSMiss	coherence_ctrls.h	/^        Counter profGETSHit, profGETSMiss, profGETXHit, profGETXMissIM \/*from invalid*\/, profGETXMissSM \/*from S, i.e. upgrade misses*\/;$/;"	m	class:MESIBottomCC
profGETXHit	coherence_ctrls.h	/^        Counter profGETSHit, profGETSMiss, profGETXHit, profGETXMissIM \/*from invalid*\/, profGETXMissSM \/*from S, i.e. upgrade misses*\/;$/;"	m	class:MESIBottomCC
profGETXMissIM	coherence_ctrls.h	/^        Counter profGETSHit, profGETSMiss, profGETXHit, profGETXMissIM \/*from invalid*\/, profGETXMissSM \/*from S, i.e. upgrade misses*\/;$/;"	m	class:MESIBottomCC
profGETXMissSM	coherence_ctrls.h	/^        Counter profGETSHit, profGETSMiss, profGETXHit, profGETXMissIM \/*from invalid*\/, profGETXMissSM \/*from S, i.e. upgrade misses*\/;$/;"	m	class:MESIBottomCC
profHeartbeats	zsim.h	/^    VectorCounter* profHeartbeats; \/\/global b\/c number of processes cannot be inferred at init time; we just size to max$/;"	m	struct:GlobSimInfo
profHitLat	timing_cache.h	/^        Counter profHitLat, profMissRespLat, profMissLat;$/;"	m	class:TimingCache
profHits	part_repl_policies.h	/^    Counter profHits;$/;"	m	struct:PartInfo
profHits	prefetcher.h	/^        Counter profAccesses, profPrefetches, profDoublePrefetches, profPageHits, profHits, profShortHits, profStrideSwitches, profLowConfAccs;$/;"	m	class:StreamPrefetcher
profHits	utility_monitor.h	/^        Counter profHits;$/;"	m	class:UMon
profINV	coherence_ctrls.h	/^        Counter profINV, profINVX, profFWD \/*received from upstream*\/;$/;"	m	class:MESIBottomCC
profINVX	coherence_ctrls.h	/^        Counter profINV, profINVX, profFWD \/*received from upstream*\/;$/;"	m	class:MESIBottomCC
profIncomingCrossingHist	contention_sim.h	/^            VectorCounter profIncomingCrossingHist;$/;"	m	struct:ContentionSim::DomainData
profIncomingCrossingSims	contention_sim.h	/^            VectorCounter profIncomingCrossingSims;$/;"	m	struct:ContentionSim::DomainData
profIncomingCrossings	contention_sim.h	/^            VectorCounter profIncomingCrossings;$/;"	m	struct:ContentionSim::DomainData
profIssueStalls	ooo_core.h	/^        Counter profFetchStalls, profDecodeStalls, profIssueStalls;$/;"	m	class:OOOCore
profLoad	mem_ctrls.h	/^        Counter profLoad;$/;"	m	class:MD1Memory
profLowConfAccs	prefetcher.h	/^        Counter profAccesses, profPrefetches, profDoublePrefetches, profPageHits, profHits, profShortHits, profStrideSwitches, profLowConfAccs;$/;"	m	class:StreamPrefetcher
profMissLat	timing_cache.h	/^        Counter profHitLat, profMissRespLat, profMissLat;$/;"	m	class:TimingCache
profMissRespLat	timing_cache.h	/^        Counter profHitLat, profMissRespLat, profMissLat;$/;"	m	class:TimingCache
profMisses	part_repl_policies.h	/^    Counter profMisses;$/;"	m	struct:PartInfo
profMisses	utility_monitor.h	/^        Counter profMisses;$/;"	m	class:UMon
profNoViolAcc	repl_policies.h	/^        Counter profRAW, profWAR, profRAR, profWAW, profNoViolAcc;$/;"	m	class:ProfViolReplPolicy
profNoViolEv	repl_policies.h	/^        Counter profAAE, profNoViolEv; \/\/access after eviction violation$/;"	m	class:ProfViolReplPolicy
profOccHist	timing_cache.h	/^        CycleBreakdownStat profOccHist;$/;"	m	class:TimingCache
profPUTS	coherence_ctrls.h	/^        Counter profPUTS, profPUTX \/*received from downstream*\/;$/;"	m	class:MESIBottomCC
profPUTX	coherence_ctrls.h	/^        Counter profPUTS, profPUTX \/*received from downstream*\/;$/;"	m	class:MESIBottomCC
profPageHits	prefetcher.h	/^        Counter profAccesses, profPrefetches, profDoublePrefetches, profPageHits, profHits, profShortHits, profStrideSwitches, profLowConfAccs;$/;"	m	class:StreamPrefetcher
profPrecharge	detailed_mem.h	/^        Counter profPrecharge;$/;"	m	class:MemControllerBase
profPrefetches	prefetcher.h	/^        Counter profAccesses, profPrefetches, profDoublePrefetches, profPageHits, profHits, profShortHits, profStrideSwitches, profLowConfAccs;$/;"	m	class:StreamPrefetcher
profPromotions	part_repl_policies.h	/^        Counter profPromotions;$/;"	m	class:VantageReplPolicy
profRAR	repl_policies.h	/^        Counter profRAW, profWAR, profRAR, profWAW, profNoViolAcc;$/;"	m	class:ProfViolReplPolicy
profRAW	repl_policies.h	/^        Counter profRAW, profWAR, profRAR, profWAW, profNoViolAcc;$/;"	m	class:ProfViolReplPolicy
profReadHits	ddr_mem.h	/^        Counter profReadHits, profWriteHits;  \/\/ row buffer hits$/;"	m	class:DDRMemory
profReads	ddr_mem.h	/^        Counter profReads, profWrites;$/;"	m	class:DDRMemory
profReads	detailed_mem.h	/^        Counter profReads;$/;"	m	class:MemControllerBase
profReads	dramsim_mem_ctrl.h	/^        Counter profReads;$/;"	m	class:DRAMSimMemory
profReads	mem_ctrls.h	/^        Counter profReads;$/;"	m	class:MD1Memory
profRefresh	detailed_mem.h	/^        Counter profRefresh;$/;"	m	class:MemControllerBase
profSelfEvictions	part_repl_policies.h	/^    Counter profSelfEvictions; \/\/ from our same partition$/;"	m	struct:PartInfo
profShortHits	prefetcher.h	/^        Counter profAccesses, profPrefetches, profDoublePrefetches, profPageHits, profHits, profShortHits, profStrideSwitches, profLowConfAccs;$/;"	m	class:StreamPrefetcher
profSimTime	zsim.h	/^    TimeBreakdownStat* profSimTime;$/;"	m	struct:GlobSimInfo
profSizeCycles	part_repl_policies.h	/^            Counter profSizeCycles;$/;"	m	struct:VantageReplPolicy::VantagePartInfo
profStrideSwitches	prefetcher.h	/^        Counter profAccesses, profPrefetches, profDoublePrefetches, profPageHits, profHits, profShortHits, profStrideSwitches, profLowConfAccs;$/;"	m	class:StreamPrefetcher
profTime	contention_sim.h	/^            ClockStat profTime;$/;"	m	struct:ContentionSim::DomainData
profTotalRdLat	ddr_mem.h	/^        Counter profTotalRdLat, profTotalWrLat;$/;"	m	class:DDRMemory
profTotalRdLat	detailed_mem.h	/^        Counter profTotalRdLat;$/;"	m	class:MemControllerBase
profTotalRdLat	dramsim_mem_ctrl.h	/^        Counter profTotalRdLat;$/;"	m	class:DRAMSimMemory
profTotalRdLat	mem_ctrls.h	/^        Counter profTotalRdLat;$/;"	m	class:MD1Memory
profTotalWrLat	ddr_mem.h	/^        Counter profTotalRdLat, profTotalWrLat;$/;"	m	class:DDRMemory
profTotalWrLat	detailed_mem.h	/^        Counter profTotalWrLat;$/;"	m	class:MemControllerBase
profTotalWrLat	dramsim_mem_ctrl.h	/^        Counter profTotalWrLat;$/;"	m	class:DRAMSimMemory
profTotalWrLat	mem_ctrls.h	/^        Counter profTotalWrLat;$/;"	m	class:MD1Memory
profUpdateCycles	part_repl_policies.h	/^        Counter profUpdateCycles;$/;"	m	class:VantageReplPolicy
profUpdates	mem_ctrls.h	/^        Counter profUpdates;$/;"	m	class:MD1Memory
profWAR	repl_policies.h	/^        Counter profRAW, profWAR, profRAR, profWAW, profNoViolAcc;$/;"	m	class:ProfViolReplPolicy
profWAW	repl_policies.h	/^        Counter profRAW, profWAR, profRAR, profWAW, profNoViolAcc;$/;"	m	class:ProfViolReplPolicy
profWayHits	utility_monitor.h	/^        VectorCounter profWayHits;$/;"	m	class:UMon
profWriteHits	ddr_mem.h	/^        Counter profReadHits, profWriteHits;  \/\/ row buffer hits$/;"	m	class:DDRMemory
profWrites	ddr_mem.h	/^        Counter profReads, profWrites;$/;"	m	class:DDRMemory
profWrites	detailed_mem.h	/^        Counter profWrites;$/;"	m	class:MemControllerBase
profWrites	dramsim_mem_ctrl.h	/^        Counter profWrites;$/;"	m	class:DRAMSimMemory
profWrites	mem_ctrls.h	/^        Counter profWrites;$/;"	m	class:MD1Memory
profileBbl	decoder.cpp	/^void Decoder::profileBbl(uint64_t bblIdx) {$/;"	f	class:Decoder
profileCrossing	contention_sim.h	/^        void profileCrossing(uint32_t srcDomain, uint32_t dstDomain, uint32_t count) {$/;"	f	class:ContentionSim
propagateDomain	timing_event.h	/^        void propagateDomain(int32_t dom) {$/;"	f	class:TimingEvent
pthread_acquire_lock	g_heap/dlmalloc.h.c	/^static FORCEINLINE int pthread_acquire_lock (MLOCK_T *sl) {$/;"	f	file:
pthread_init_lock	g_heap/dlmalloc.h.c	/^static int pthread_init_lock (MLOCK_T *sl) {$/;"	f	file:
pthread_mlock_t	g_heap/dlmalloc.h.c	/^struct pthread_mlock_t {$/;"	s	file:
pthread_mutexattr_settype	g_heap/dlmalloc.h.c	1929;"	d	file:
pthread_release_lock	g_heap/dlmalloc.h.c	/^static FORCEINLINE void pthread_release_lock (MLOCK_T *sl) {$/;"	f	file:
pthread_try_lock	g_heap/dlmalloc.h.c	/^static FORCEINLINE int pthread_try_lock (MLOCK_T *sl) {$/;"	f	file:
pushRecord	event_recorder.h	/^        void pushRecord(const TimingRecord& tr) {$/;"	f	class:EventRecorder
push_back	intrusive_list.h	/^        void push_back(T* e) {$/;"	f	class:InList
push_front	intrusive_list.h	/^        void push_front(T* e) {$/;"	f	class:InList
push_front	phase_slab_alloc.h	/^            void push_front(Slab* s) {$/;"	f	class:PhaseSlabAlloc::SlabList
pvLock	virt/port_virtualizer.h	/^        lock_t pvLock;$/;"	m	class:PortVirtualizer
pwCounterNum	detailed_mem.h	/^        static const uint32_t pwCounterNum = 7;$/;"	m	class:MemControllerBase
qLock	event_queue.h	/^        lock_t qLock;$/;"	m	class:EventQueue
queue	ddr_mem.cpp	/^void DDRMemory::queue(Request* req, uint64_t memCycle) {    $/;"	f	class:DDRMemory
queue	tick_event.h	/^        void queue(uint64_t startCycle) {$/;"	f	class:TickEvent
queue	timing_event.cpp	/^void TimingEvent::queue(uint64_t nextCycle) {$/;"	f	class:TimingEvent
queueDepth	ddr_mem.h	/^        const uint32_t queueDepth;$/;"	m	class:DDRMemory
queuePrio	contention_sim.h	/^            uint64_t queuePrio;$/;"	m	struct:ContentionSim::DomainData
queueProcessCleanup	scheduler.h	/^        void queueProcessCleanup(uint32_t pid, uint32_t osPid) {$/;"	f	class:Scheduler
rand	mtrand.h	/^inline double MTRand::rand() { return double(randInt()) * (1.0\/4294967295.0); }$/;"	f	class:MTRand
rand	mtrand.h	/^inline double MTRand::rand(const double n) { return rand() * n; }$/;"	f	class:MTRand
rand53	mtrand.h	/^inline double MTRand::rand53() {$/;"	f	class:MTRand
randDblExc	mtrand.h	/^inline double MTRand::randDblExc() { return (double(randInt()) + 0.5) * (1.0\/4294967296.0); }$/;"	f	class:MTRand
randDblExc	mtrand.h	/^inline double MTRand::randDblExc(const double n) { return randDblExc() * n; }$/;"	f	class:MTRand
randExc	mtrand.h	/^inline double MTRand::randExc() { return double(randInt()) * (1.0\/4294967296.0); }$/;"	f	class:MTRand
randExc	mtrand.h	/^inline double MTRand::randExc(const double n) { return randExc() * n; }$/;"	f	class:MTRand
randInt	mtrand.h	/^inline uint64_t MTRand::randInt() {$/;"	f	class:MTRand
randInt	mtrand.h	/^inline uint64_t MTRand::randInt(const uint64_t n) {$/;"	f	class:MTRand
randNorm	mtrand.h	/^inline double MTRand::randNorm(const double mean, const double stddev) {$/;"	f	class:MTRand
rank	ddr_mem.h	/^            uint32_t rank;$/;"	m	struct:DDRMemory::AddrLoc
rank	ideal_arrays.h	/^                template <typename C> uint32_t rank(const MemReq* req, C cands) {panic("!!!");}$/;"	f	class:IdealLRUArray::ProxyReplPolicy
rank	ideal_arrays.h	/^        template <typename C> uint32_t rank(const MemReq* req, C cands) {panic("!!");}$/;"	f	class:IdealLRUPartReplPolicy
rank	ideal_arrays.h	/^        uint32_t rank(const MemReq* req) {$/;"	f	class:IdealLRUPartReplPolicy
rank	repl_policies.h	/^        template <typename C> inline uint32_t rank(const MemReq* req, C cands) {$/;"	f	class:LRUReplPolicy
rank	repl_policies.h	/^        template <typename C> inline uint32_t rank(const MemReq* req, C cands) {$/;"	f	class:LegacyReplPolicy
rankActWindows	ddr_mem.h	/^        g_vector<ActWindow> rankActWindows;$/;"	m	class:DDRMemory
rankCount	detailed_mem_params.h	/^        uint32_t rankCount;$/;"	m	class:MemParam
rankMask	ddr_mem.h	/^        uint32_t rankShift, rankMask;$/;"	m	class:DDRMemory
rankShift	ddr_mem.h	/^        uint32_t rankShift, rankMask;$/;"	m	class:DDRMemory
rankWidth	detailed_mem_params.h	/^        uint32_t rankWidth;$/;"	m	class:MemParam
ranks	detailed_mem.h	/^        g_vector <MemRankBase*> ranks;$/;"	m	class:MemChannelBase
ranksPerChannel	ddr_mem.h	/^        const uint32_t lineSize, ranksPerChannel, banksPerRank;$/;"	m	class:DDRMemory
rd	decoder.h	/^    uint16_t rd[MAX_UOP_DST_REGS];$/;"	m	struct:DynUop
rdAddr	filter_cache.h	/^            volatile Address rdAddr;$/;"	m	struct:FilterCache::FilterEntry
rdQueue	ddr_mem.h	/^        RequestQueue<Request> rdQueue, wrQueue;$/;"	m	class:DDRMemory
rdQueue	detailed_mem.h	/^        g_vector <MemSchedQueueElem> rdQueue;$/;"	m	class:MemSchedulerDefault
rdReqs	ddr_mem.h	/^            InList<Request> rdReqs;$/;"	m	struct:DDRMemory::Bank
rdtsc	rdtsc.h	/^static inline uint64_t rdtsc() {$/;"	f
rdtscOffset	zsim.h	/^    uint64_t rdtscOffset;$/;"	m	struct:ClockDomainInfo
read	repl_policies.h	/^            uint64_t read;$/;"	m	struct:ProfViolReplPolicy::AccTimes
readBurstCount	detailed_mem.h	/^        uint64_t readBurstCount;$/;"	m	class:MemRankBase
readDqPin	detailed_mem_params.h	/^        uint32_t readDqPin;$/;"	m	class:MemParam
readTermPin	detailed_mem_params.h	/^        uint32_t readTermPin;$/;"	m	class:MemParam
realToVirt	virt/port_virtualizer.h	/^        g_unordered_map<int, int> realToVirt;$/;"	m	class:PortVirtualizer
realtimeOffsetNs	zsim.h	/^    uint64_t realtimeOffsetNs;$/;"	m	struct:ClockDomainInfo
rebind	g_std/stl_galloc.h	/^        template <class U> struct rebind { typedef StlGlobAlloc<U> other; };$/;"	s	class:StlGlobAlloc
record	core_recorder.h	/^        inline void record(uint64_t startCycle) {$/;"	f	class:CoreRecorder
record	ooo_core_recorder.h	/^        inline void record(uint64_t curCycle, uint64_t dispatchCycle, uint64_t respCycle) {$/;"	f	class:OOOCoreRecorder
recordAccess	core_recorder.cpp	/^void CoreRecorder::recordAccess(uint64_t startCycle) {$/;"	f	class:CoreRecorder
recordAccess	ooo_core_recorder.cpp	/^void OOOCoreRecorder::recordAccess(uint64_t curCycle, uint64_t dispatchCycle, uint64_t respCycle) {$/;"	f	class:OOOCoreRecorder
recordCandidate	part_repl_policies.h	/^        void recordCandidate(uint32_t id) {$/;"	f	class:VantageReplPolicy
recordCandidate	part_repl_policies.h	/^        void recordCandidate(uint32_t id) {$/;"	f	class:WayPartReplPolicy
recordCandidate	repl_policies.h	/^        void recordCandidate(uint32_t id) {$/;"	f	class:LFUReplPolicy
recordCandidate	repl_policies.h	/^        void recordCandidate(uint32_t id) {$/;"	f	class:NRUReplPolicy
recordCandidate	repl_policies.h	/^        void recordCandidate(uint32_t id) {$/;"	f	class:RandReplPolicy
recordCandidate	repl_policies.h	/^        void recordCandidate(uint32_t id) {$/;"	f	class:TreeLRUReplPolicy
recordSize	hdf5_stats.cpp	/^        uint64_t recordSize; \/\/ in bytes$/;"	m	class:HDF5BackendImpl	file:
recordsPerWrite	hdf5_stats.cpp	/^        uint32_t recordsPerWrite; \/\/how many records to buffer; determines chunk size as well$/;"	m	class:HDF5BackendImpl	file:
recycleEvent	ddr_mem.cpp	/^void DDRMemory::recycleEvent(SchedEvent* ev) {$/;"	f	class:DDRMemory
refInterval	ddr_mem.cpp	/^        uint32_t refInterval;  \/\/ in sysCycles$/;"	m	class:RefreshEvent	file:
reference	g_std/stl_galloc.h	/^        typedef T& reference;$/;"	t	class:StlGlobAlloc
refresh	ddr_mem.cpp	/^void DDRMemory::refresh(uint64_t sysCycle) {$/;"	f	class:DDRMemory
refresh	detailed_mem.cpp	/^void MemRankBase::refresh(uint64_t lastCycle) {$/;"	f	class:MemRankBase
refresh	detailed_mem.h	/^            uint64_t refresh;$/;"	m	struct:MemControllerBase::powerValue
refreshNum	detailed_mem.h	/^        uint32_t refreshNum;$/;"	m	class:MemRankBase
regScoreboard	ooo_core.h	/^        uint64_t regScoreboard[MAX_REGISTERS]; \/\/contains timestamp of next issue cycles where each reg can be sourced$/;"	m	class:OOOCore
registerBind	virt/port_virtualizer.h	/^        void registerBind(int virt, int real) {$/;"	f	class:PortVirtualizer
registerThreads	zsim.h	/^    bool registerThreads;$/;"	m	struct:GlobSimInfo
regsToString	decoder.cpp	/^static std::string regsToString(uint32_t* regs, uint32_t numRegs) {$/;"	f	file:
release	timing_event.h	/^        inline void release() {$/;"	f	class:TimingEvent
release_checks	g_heap/dlmalloc.h.c	/^  size_t     release_checks;$/;"	m	struct:malloc_state	file:
release_unused_segments	g_heap/dlmalloc.h.c	/^static size_t release_unused_segments(mstate m) {$/;"	f	file:
reload	mtrand.h	/^inline void MTRand::reload() {$/;"	f	class:MTRand
remove	ddr_mem.h	/^        inline void remove(iterator i) {$/;"	f	class:RequestQueue
remove	intrusive_list.h	/^        void remove(T* e) {$/;"	f	class:InList
reorderRegs	decoder.cpp	/^void Decoder::Instr::reorderRegs(uint32_t* array, uint32_t regs) {$/;"	f	class:Decoder::Instr
repl	partitioner.h	/^        PartReplPolicy* repl;$/;"	m	class:LookaheadPartitioner
replCycle	repl_policies.h	/^        uint64_t replCycle;$/;"	m	class:ProfViolReplPolicy
replace	filter_cache.h	/^        uint64_t replace(Address vLineAddr, uint32_t idx, bool isLoad, uint64_t curCycle) {$/;"	f	class:FilterCache
replace_dv	g_heap/dlmalloc.h.c	3568;"	d	file:
replaced	ideal_arrays.h	/^                void replaced(uint32_t id) {panic("!!");}$/;"	f	class:IdealLRUArray::ProxyReplPolicy
replaced	ideal_arrays.h	/^        void replaced(uint32_t id) {$/;"	f	class:IdealLRUPartReplPolicy
replaced	part_repl_policies.h	/^        void replaced(uint32_t id) {$/;"	f	class:VantageReplPolicy
replaced	part_repl_policies.h	/^        void replaced(uint32_t id) {$/;"	f	class:WayPartReplPolicy
replaced	repl_policies.h	/^        void replaced(uint32_t id) {$/;"	f	class:LFUReplPolicy
replaced	repl_policies.h	/^        void replaced(uint32_t id) {$/;"	f	class:LRUReplPolicy
replaced	repl_policies.h	/^        void replaced(uint32_t id) {$/;"	f	class:NRUReplPolicy
replaced	repl_policies.h	/^        void replaced(uint32_t id) {$/;"	f	class:ProfViolReplPolicy
replaced	repl_policies.h	/^        void replaced(uint32_t id) {$/;"	f	class:RandReplPolicy
replaced	repl_policies.h	/^        void replaced(uint32_t id) {$/;"	f	class:TreeLRUReplPolicy
reportEventSimulated	core_recorder.cpp	/^void CoreRecorder::reportEventSimulated(TimingCoreEvent* ev) {$/;"	f	class:CoreRecorder
reportFinish	detailed_mem_params.h	/^        uint64_t reportFinish;$/;"	m	class:MemParam
reportIssueEventSimulated	ooo_core_recorder.cpp	/^void OOOCoreRecorder::reportIssueEventSimulated(OOOIssueEvent* ev) {$/;"	f	class:OOOCoreRecorder
reportPeriodCycle	detailed_mem.h	/^        uint64_t reportPeriodCycle;$/;"	m	class:MemControllerBase
reportPhase	detailed_mem_params.h	/^        uint32_t reportPhase;$/;"	m	class:MemParam
reportStart	detailed_mem_params.h	/^        uint64_t reportStart;$/;"	m	class:MemParam
reportUnhandledCase	decoder.cpp	/^void Decoder::reportUnhandledCase(Instr& instr, const char* desc) {$/;"	f	class:Decoder
reqCycle	event_recorder.h	/^    uint64_t reqCycle;$/;"	m	struct:TimingRecord
reqFlags	filter_cache.h	/^        uint32_t reqFlags;$/;"	m	class:FilterCache
reqList	ddr_mem.h	/^        InList<Node> reqList;  \/\/ FIFO$/;"	m	class:RequestQueue
request2size	g_heap/dlmalloc.h.c	2195;"	d	file:
requeue	timing_event.cpp	/^void TimingEvent::requeue(uint64_t nextCycle) {$/;"	f	class:TimingEvent
resShift	hash.h	/^        uint32_t resShift;$/;"	m	class:H3HashFamily
reset	monitor.cpp	/^void UMonMonitor::reset() {$/;"	f	class:UMonMonitor
reset	prefetcher.h	/^        void reset() { count = I; }$/;"	f	class:SatCounter
reset	repl_policies.h	/^            void reset() {$/;"	f	struct:LFUReplPolicy::Rank
reset_on_error	g_heap/dlmalloc.h.c	/^static void reset_on_error(mstate m) {$/;"	f	file:
respCycle	event_recorder.h	/^    uint64_t respCycle;$/;"	m	struct:TimingRecord
respCycle	prefetcher.h	/^                uint64_t respCycle;$/;"	m	struct:StreamPrefetcher::Entry::AccessTimes
restartsLeft	process_tree.h	/^        uint32_t restartsLeft;$/;"	m	class:ProcessTreeNode
rnd	barrier.h	/^        MTRand rnd;$/;"	m	class:Barrier
rnd	repl_policies.h	/^        MTRand rnd;$/;"	m	class:RandReplPolicy
rnd	scheduler.h	/^        MTRand rnd;$/;"	m	class:Scheduler
rng	part_repl_policies.h	/^        MTRand rng;$/;"	m	class:VantageReplPolicy
rob	ooo_core.h	/^        ReorderBuffer<128, 4> rob;$/;"	m	class:OOOCore
rootStat	hdf5_stats.cpp	/^        AggregateStat* rootStat;$/;"	m	class:HDF5BackendImpl	file:
rootStat	text_stats.cpp	/^        AggregateStat* rootStat;$/;"	m	class:TextBackendImpl	file:
rootStat	zsim.h	/^    AggregateStat* rootStat;$/;"	m	struct:GlobSimInfo
row	ddr_mem.h	/^            uint64_t row;$/;"	m	struct:DDRMemory::AddrLoc
rowAddrWidth	detailed_mem_params.h	/^        uint32_t rowAddrWidth;$/;"	m	class:MemParam
rowBufferPolicy	detailed_mem_params.h	/^        uint32_t rowBufferPolicy;$/;"	m	class:MemParam
rowHitLimit	ddr_mem.h	/^        const uint32_t rowHitLimit; \/\/ row hits not prioritized in FR-FCFS beyond this point$/;"	m	class:DDRMemory
rowHitSeq	ddr_mem.h	/^            uint64_t rowHitSeq; \/\/ sequence number used to throttle max # row hits$/;"	m	struct:DDRMemory::Request
rowShift	ddr_mem.h	/^        uint64_t rowShift;  \/\/ row's always top$/;"	m	class:DDRMemory
rp	cache.h	/^        ReplPolicy* rp;$/;"	m	class:Cache
rp	cache_arrays.h	/^        ReplPolicy* rp;$/;"	m	class:SetAssocArray
rp	cache_arrays.h	/^        ReplPolicy* rp;$/;"	m	class:ZArray
rp	ideal_arrays.h	/^        IdealLRUPartReplPolicy* rp;$/;"	m	class:IdealLRUPartArray
rp	ideal_arrays.h	/^        ProxyReplPolicy* rp;$/;"	m	class:IdealLRUArray
rs	decoder.h	/^    uint16_t rs[MAX_UOP_SRC_REGS];$/;"	m	struct:DynUop
run	timing_event.h	/^        inline void run(uint64_t startCycle) {$/;"	f	class:TimingEvent
runList	barrier.h	/^        uint32_t* runList;$/;"	m	class:Barrier
runListSize	barrier.h	/^        uint32_t runListSize;$/;"	m	class:Barrier
runQueue	scheduler.h	/^        InList<ThreadInfo> runQueue;$/;"	m	class:Scheduler
runQueueHist	scheduler.h	/^        VectorCounter occHist, runQueueHist;$/;"	m	class:Scheduler
runningThreads	barrier.h	/^        uint32_t runningThreads; \/\/threads in RUNNING state$/;"	m	class:Barrier
s	stats.h	/^        uint32_t s;$/;"	m	class:LambdaVectorStat
sCycle	dramsim_mem_ctrl.cpp	/^        uint64_t sCycle;$/;"	m	class:DRAMSimAccEvent	file:
safeCopy	virt/common.h	/^static inline bool safeCopy(const T* src, T* dst, const char* file = __FILE__, int line = __LINE__) {$/;"	f
same_or_left_bits	g_heap/dlmalloc.h.c	2883;"	d	file:
samplingFactor	utility_monitor.h	/^        uint32_t samplingFactor; \/\/Size of sampled cache (lines)\/size of umon. Should be power of 2$/;"	m	class:UMon
samplingFactorBits	utility_monitor.h	/^        uint64_t samplingFactorBits;$/;"	m	class:UMon
save	mtrand.h	/^inline void MTRand::save(uint64_t* saveArray) const {$/;"	f	class:MTRand
sbinptr	g_heap/dlmalloc.h.c	/^typedef struct malloc_chunk* sbinptr;  \/* The type of bins of chunks *\/$/;"	t	typeref:struct:malloc_chunk	file:
sched	barrier.h	/^        Callee* sched; \/\/FIXME: I don't like this organization, but don't have time to refactor the barrier code, this is used for a callback when the phase is done$/;"	m	class:Barrier
sched	zsim.h	/^    Scheduler* sched;$/;"	m	struct:GlobSimInfo
schedContext	scheduler.h	/^        ThreadInfo* schedContext(ContextInfo* ctx) {$/;"	f	class:Scheduler
schedLock	scheduler.h	/^        lock_t schedLock;$/;"	m	class:Scheduler
schedQuantum	scheduler.h	/^        uint32_t schedQuantum; \/\/in phases$/;"	m	class:Scheduler
schedThread	scheduler.h	/^        ContextInfo* schedThread(ThreadInfo* th) {$/;"	f	class:Scheduler
schedTick	scheduler.h	/^        void schedTick() {$/;"	f	class:Scheduler
schedule	ooo_core.h	/^        void schedule(uint64_t& curCycle, uint64_t& schedCycle, uint8_t portMask, uint32_t extraSlots = 0) {$/;"	f	class:WindowStructure
schedule	scheduler.h	/^        void schedule(ThreadInfo* th, ContextInfo* ctx) {$/;"	f	class:Scheduler
scheduleEvents	scheduler.h	/^        Counter scheduleEvents, waitEvents, handoffEvents, sleepEvents;$/;"	m	class:Scheduler
scheduleInternal	ooo_core.h	/^        void scheduleInternal(uint64_t& curCycle, uint64_t& schedCycle, uint8_t portMask) {$/;"	f	class:WindowStructure
scheduledThreads	scheduler.h	/^        uint32_t scheduledThreads;$/;"	m	class:Scheduler
schedulerQueueCount	detailed_mem_params.h	/^        uint32_t schedulerQueueCount;$/;"	m	class:MemParam
sches	detailed_mem.h	/^        g_vector <MemSchedulerBase*> sches;$/;"	m	class:MemControllerBase
score	repl_policies.h	/^        inline uint64_t score(uint32_t id) { \/\/higher is least evictable$/;"	f	class:LRUReplPolicy
secondary_regp	galloc.cpp	/^    volatile void* secondary_regp; \/\/secondary data structure, used to exchange information between harness and initializing process$/;"	m	struct:gm_segment	file:
seed	mtrand.h	/^inline void MTRand::seed() {$/;"	f	class:MTRand
seed	mtrand.h	/^inline void MTRand::seed(const uint64_t oneSeed) {$/;"	f	class:MTRand
seed	mtrand.h	/^inline void MTRand::seed(uint64_t *const bigSeed, const uint64_t seedLength) {$/;"	f	class:MTRand
seg	g_heap/dlmalloc.h.c	/^  msegment   seg;$/;"	m	struct:malloc_state	file:
segment_holding	g_heap/dlmalloc.h.c	/^static msegmentptr segment_holding(mstate m, char* addr) {$/;"	f	file:
segment_holds	g_heap/dlmalloc.h.c	2643;"	d	file:
selfId	coherence_ctrls.h	/^        uint32_t selfId;$/;"	m	class:MESIBottomCC
sendInvalidates	coherence_ctrls.cpp	/^uint64_t MESITopCC::sendInvalidates(Address lineAddr, uint32_t lineId, InvType type, bool* reqWriteback, uint64_t cycle, uint32_t srcId) {$/;"	f	class:MESITopCC
set	cache_arrays.h	/^    inline void set(uint32_t p, uint32_t i, int32_t x) {pos = p; lineId = i; parentIdx = x;}$/;"	f	struct:ZWalkInfo
set	memory_hierarchy.h	/^    inline void set(Flag f) {flags |= f;}$/;"	f	struct:MemReq
set	ooo_core.h	/^            inline void set(uint8_t o, uint8_t c) {occUnits = o; count = c;}$/;"	f	struct:WindowStructure::WinCycle
set	ooo_core.h	/^            void set(Address a, uint64_t c) {addr = a; storeCycle = c;}$/;"	f	struct:OOOCore::FwdEntry
set	stats.h	/^        inline void set(uint64_t data) {$/;"	f	class:Counter
setCC	ideal_arrays.h	/^                void setCC(CC* _cc) {a->setCC(cc);}$/;"	f	class:IdealLRUArray::ProxyReplPolicy
setCC	ideal_arrays.h	/^        void setCC(CC* _cc) {cc = _cc;}$/;"	f	class:IdealLRUArray
setCC	repl_policies.h	/^        virtual void setCC(CC* _cc) {cc = _cc;}$/;"	f	class:ReplPolicy
setChildren	cache.cpp	/^void Cache::setChildren(const g_vector<BaseCache*>& children, Network* network) {$/;"	f	class:Cache
setChildren	coherence_ctrls.h	/^        void setChildren(const g_vector<BaseCache*>& children, Network* network) {$/;"	f	class:MESICC
setChildren	coherence_ctrls.h	/^        void setChildren(const g_vector<BaseCache*>& children, Network* network) {$/;"	f	class:MESITerminalCC
setChildren	prefetcher.cpp	/^void StreamPrefetcher::setChildren(const g_vector<BaseCache*>& children, Network* network) {$/;"	f	class:StreamPrefetcher
setCid	zsim.cpp	/^static inline void setCid(uint32_t tid, uint32_t cid) {$/;"	f	file:
setEnvVars	pin_cmd.cpp	/^void PinCmd::setEnvVars(uint32_t procIdx) {$/;"	f	class:PinCmd
setFlags	filter_cache.h	/^        void setFlags(uint32_t flags) {$/;"	f	class:FilterCache
setGapCycles	event_recorder.h	/^        void setGapCycles(uint64_t gapCycles) {$/;"	f	class:EventRecorder
setMask	cache_arrays.h	/^        uint32_t setMask;$/;"	m	class:SetAssocArray
setMask	cache_arrays.h	/^        uint32_t setMask;$/;"	m	class:ZArray
setMask	filter_cache.h	/^        Address setMask;$/;"	m	class:FilterCache
setMinStartCycle	timing_event.h	/^        inline void setMinStartCycle(uint64_t c) {minStartCycle = c;}$/;"	f	class:TimingEvent
setParents	cache.cpp	/^void Cache::setParents(uint32_t childId, const g_vector<MemObject*>& parents, Network* network) {$/;"	f	class:Cache
setParents	coherence_ctrls.h	/^        void setParents(uint32_t childId, const g_vector<MemObject*>& parents, Network* network) {$/;"	f	class:MESICC
setParents	coherence_ctrls.h	/^        void setParents(uint32_t childId, const g_vector<MemObject*>& parents, Network* network) {$/;"	f	class:MESITerminalCC
setParents	prefetcher.cpp	/^void StreamPrefetcher::setParents(uint32_t _childId, const g_vector<MemObject*>& parents, Network* network) {$/;"	f	class:StreamPrefetcher
setPartitionSizes	ideal_arrays.h	/^        void setPartitionSizes(const uint32_t* sizes) {$/;"	f	class:IdealLRUPartReplPolicy
setPartitionSizes	part_repl_policies.h	/^        void setPartitionSizes(const uint32_t* sizes) {$/;"	f	class:VantageReplPolicy
setPartitionSizes	part_repl_policies.h	/^        void setPartitionSizes(const uint32_t* waysPart) {$/;"	f	class:WayPartReplPolicy
setPostDelay	timing_event.h	/^        inline void setPostDelay(uint32_t d) {postDelay = d;}$/;"	f	class:TimingEvent
setPreDelay	timing_event.h	/^        inline void setPreDelay(uint32_t d) {preDelay = d;}$/;"	f	class:TimingEvent
setPrio	contention_sim.h	/^        void setPrio(uint32_t domain, uint32_t prio) {domains[domain].prio = prio;}$/;"	f	class:ContentionSim
setRunning	timing_event.h	/^        void setRunning() {$/;"	f	class:TimingEvent
setSourceId	event_recorder.h	/^        void setSourceId(uint32_t i) {srcId = i;}$/;"	f	class:EventRecorder
setSourceId	filter_cache.h	/^        void setSourceId(uint32_t id) {$/;"	f	class:FilterCache
setStartSlack	event_recorder.h	/^        inline void setStartSlack(uint64_t startSlack) {$/;"	f	class:EventRecorder
set_foot	g_heap/dlmalloc.h.c	2241;"	d	file:
set_free_with_pinuse	g_heap/dlmalloc.h.c	2248;"	d	file:
set_inuse	g_heap/dlmalloc.h.c	3002;"	d	file:
set_inuse	g_heap/dlmalloc.h.c	3025;"	d	file:
set_inuse_and_pinuse	g_heap/dlmalloc.h.c	3007;"	d	file:
set_inuse_and_pinuse	g_heap/dlmalloc.h.c	3030;"	d	file:
set_lock	g_heap/dlmalloc.h.c	2612;"	d	file:
set_size_and_pinuse_of_free_chunk	g_heap/dlmalloc.h.c	2244;"	d	file:
set_size_and_pinuse_of_inuse_chunk	g_heap/dlmalloc.h.c	3012;"	d	file:
set_size_and_pinuse_of_inuse_chunk	g_heap/dlmalloc.h.c	3035;"	d	file:
setpointAdjs	part_repl_policies.h	/^            uint64_t setpointAdjs; \/\/ setpoint adjustments so far, just for profiling purposes$/;"	m	struct:VantageReplPolicy::VantagePartInfo
setpointBts	part_repl_policies.h	/^            uint64_t setpointBts; \/\/ setpoint coarse-grain timestamp (SetpointTS in paper)$/;"	m	struct:VantageReplPolicy::VantagePartInfo
sets	utility_monitor.h	/^        uint32_t sets; \/\/umon sets. Should be power of 2.$/;"	m	class:UMon
setsBits	utility_monitor.h	/^        uint64_t setsBits;$/;"	m	class:UMon
sflags	g_heap/dlmalloc.h.c	/^  flag_t       sflags;           \/* mmap and extern flag *\/$/;"	m	struct:malloc_segment	file:
sharers	coherence_ctrls.h	/^            std::bitset<MAX_CACHE_CHILDREN> sharers;$/;"	m	struct:MESITopCC::Entry
sharers	repl_policies.h	/^            uint32_t sharers;$/;"	m	struct:LFUReplPolicy::Rank
shouldAllocate	coherence_ctrls.h	/^        bool shouldAllocate(const MemReq& req) {$/;"	f	class:MESICC
shouldAllocate	coherence_ctrls.h	/^        bool shouldAllocate(const MemReq& req) {$/;"	f	class:MESITerminalCC
should_trim	g_heap/dlmalloc.h.c	2669;"	d	file:
should_trim	g_heap/dlmalloc.h.c	2671;"	d	file:
sigHandler	zsim_harness.cpp	/^void sigHandler(int sig) {$/;"	f
signal	zsim.cpp	/^        void signal() {$/;"	f	class:SyncEvent
simCount	timing_event.h	/^        uint64_t simCount;$/;"	m	class:CrossingEvent
simThreadLoop	contention_sim.cpp	/^void ContentionSim::simThreadLoop(uint32_t thid) {$/;"	f	class:ContentionSim
simThreads	contention_sim.h	/^        SimThreadData* simThreads;$/;"	m	class:ContentionSim
simulate	core_recorder.cpp	/^        void simulate(uint64_t _startCycle) {$/;"	f	class:TimingCoreEvent
simulate	ddr_mem.cpp	/^        void simulate(uint64_t startCycle) {$/;"	f	class:DDRMemoryAccEvent
simulate	ddr_mem.cpp	/^        void simulate(uint64_t startCycle) {$/;"	f	class:RefreshEvent
simulate	ddr_mem.cpp	/^        void simulate(uint64_t startCycle) {$/;"	f	class:SchedEvent
simulate	detailed_mem.h	/^        void simulate(uint64_t startCycle) { dram->enqueue(this, startCycle); }$/;"	f	class:MemAccessEventBase
simulate	dramsim_mem_ctrl.cpp	/^        void simulate(uint64_t startCycle) {$/;"	f	class:DRAMSimAccEvent
simulate	ooo_core_recorder.cpp	/^        void simulate(uint64_t _startCycle) {$/;"	f	class:OOOIssueEvent
simulate	ooo_core_recorder.cpp	/^        void simulate(uint64_t _startCycle) {$/;"	f	class:OOORespEvent
simulate	ooo_core_recorder.cpp	/^        void simulate(uint64_t startCycle) {$/;"	f	class:OOODispatchEvent
simulate	tick_event.h	/^        void simulate(uint64_t startCycle) {$/;"	f	class:TickEvent
simulate	timing_cache.cpp	/^        void simulate(uint64_t startCycle) {$/;"	f	class:HitEvent
simulate	timing_cache.cpp	/^        void simulate(uint64_t startCycle) {cache->simulateMissResponse(this, startCycle, mse);}$/;"	f	class:MissResponseEvent
simulate	timing_cache.cpp	/^        void simulate(uint64_t startCycle) {cache->simulateMissStart(this, startCycle);}$/;"	f	class:MissStartEvent
simulate	timing_cache.cpp	/^        void simulate(uint64_t startCycle) {cache->simulateMissWriteback(this, startCycle, mse);}$/;"	f	class:MissWritebackEvent
simulate	timing_cache.cpp	/^        void simulate(uint64_t startCycle) {cache->simulateReplAccess(this, startCycle);}$/;"	f	class:ReplAccessEvent
simulate	timing_event.cpp	/^void CrossingEvent::simulate(uint64_t simCycle) {$/;"	f	class:CrossingEvent
simulate	timing_event.h	/^                virtual void simulate(uint64_t simCycle) {$/;"	f	class:CrossingEvent::CrossingSrcEvent
simulate	timing_event.h	/^        virtual void simulate(uint64_t simCycle) {$/;"	f	class:DelayEvent
simulate	weave_md1_mem.h	/^        void simulate(uint64_t startCycle) {$/;"	f	class:WeaveMemAccEvent
simulateHit	timing_cache.cpp	/^void TimingCache::simulateHit(HitEvent* ev, uint64_t cycle) {$/;"	f	class:TimingCache
simulateMissResponse	timing_cache.cpp	/^void TimingCache::simulateMissResponse(MissResponseEvent* ev, uint64_t cycle, MissStartEvent* mse) {$/;"	f	class:TimingCache
simulateMissStart	timing_cache.cpp	/^void TimingCache::simulateMissStart(MissStartEvent* ev, uint64_t cycle) {$/;"	f	class:TimingCache
simulateMissWriteback	timing_cache.cpp	/^void TimingCache::simulateMissWriteback(MissWritebackEvent* ev, uint64_t cycle, MissStartEvent* mse) {$/;"	f	class:TimingCache
simulatePhase	contention_sim.cpp	/^void ContentionSim::simulatePhase(uint64_t limit) {$/;"	f	class:ContentionSim
simulatePhaseThread	contention_sim.cpp	/^void ContentionSim::simulatePhaseThread(uint32_t thid) {$/;"	f	class:ContentionSim
simulateReplAccess	timing_cache.cpp	/^void TimingCache::simulateReplAccess(ReplAccessEvent* ev, uint64_t cycle) {$/;"	f	class:TimingCache
size	ddr_mem.h	/^        inline size_t size() const { return reqList.size(); }$/;"	f	class:RequestQueue
size	g_heap/dlmalloc.h.c	/^  size_t       size;             \/* allocated size *\/$/;"	m	struct:malloc_segment	file:
size	intrusive_list.h	/^        size_t size() const {$/;"	f	class:InList
size	part_repl_policies.h	/^    uint64_t size; \/\/in lines$/;"	m	struct:PartInfo
size	phase_slab_alloc.h	/^            uint32_t size;$/;"	m	struct:PhaseSlabAlloc::Slab
size	prio_queue.h	/^        inline uint64_t size() const {$/;"	f	class:PrioQueue
size	stats.h	/^        inline uint32_t size() const {$/;"	f	class:VectorCounter
size	stats.h	/^        uint32_t size() const { return s; }$/;"	f	class:LambdaVectorStat
size	stats.h	/^        uint32_t size() const {$/;"	f	class:AggregateStat
size_type	g_std/stl_galloc.h	/^        typedef size_t size_type;$/;"	t	class:StlGlobAlloc
skipContention	contention_sim.h	/^        bool skipContention;$/;"	m	class:ContentionSim
skipStat	hdf5_stats.cpp	/^        bool skipStat(Stat* s) {$/;"	f	class:HDF5BackendImpl	file:
skipStatsVectors	zsim.h	/^    bool skipStatsVectors;$/;"	m	struct:GlobSimInfo
skipVectors	hdf5_stats.cpp	/^        bool skipVectors;$/;"	m	class:HDF5BackendImpl	file:
slabAlloc	event_recorder.h	/^        PhaseSlabAlloc slabAlloc;$/;"	m	class:EventRecorder
slabSize	phase_slab_alloc.h	/^        uint32_t slabSize;$/;"	m	class:PhaseSlabAlloc
sleepEvents	scheduler.h	/^        Counter scheduleEvents, waitEvents, handoffEvents, sleepEvents;$/;"	m	class:Scheduler
sleepQueue	scheduler.h	/^        InList<ThreadInfo> sleepQueue; \/\/contains all the sleeping threads, it is ORDERED by wakeup time$/;"	m	class:Scheduler
small_index	g_heap/dlmalloc.h.c	2774;"	d	file:
small_index2size	g_heap/dlmalloc.h.c	2775;"	d	file:
smallbin_at	g_heap/dlmalloc.h.c	2779;"	d	file:
smallbins	g_heap/dlmalloc.h.c	/^  mchunkptr  smallbins[(NSMALLBINS+1)*2];$/;"	m	struct:malloc_state	file:
smallmap	g_heap/dlmalloc.h.c	/^  binmap_t   smallmap;$/;"	m	struct:malloc_state	file:
smallmap_is_marked	g_heap/dlmalloc.h.c	2870;"	d	file:
smblks	g_heap/dlmalloc.h.c	/^  MALLINFO_FIELD_TYPE smblks;   \/* always 0 *\/$/;"	m	struct:mallinfo	file:
smoothTransients	part_repl_policies.h	/^        bool smoothTransients; \/\/if set, keeps all growing partitions at targetSz = actualSz + 1 until they reach their actual target; takes space away slowly from the shrinking partitions instead of aggressively demoting them to the unmanaged region, which turns the whole thing into a shared cache if transients are frequent$/;"	m	class:VantageReplPolicy
smoothedPhaseAccesses	mem_ctrls.h	/^        double smoothedPhaseAccesses;$/;"	m	class:MD1Memory
spin_destroy	locks.h	/^static inline void spin_destroy(volatile uint32_t* lock) {}$/;"	f
spin_init	locks.h	/^static inline void spin_init(volatile uint32_t* lock) {$/;"	f
spin_lock	locks.h	/^static inline void spin_lock(volatile uint32_t* lock) {$/;"	f
spin_trylock	locks.h	/^static inline int spin_trylock(volatile uint32_t* lock) {$/;"	f
spin_unlock	locks.h	/^static inline void spin_unlock(volatile uint32_t* lock) {$/;"	f
srcDomain	timing_event.h	/^        uint32_t srcDomain;$/;"	m	class:CrossingEvent
srcDomainCycleAtDone	timing_event.h	/^        volatile uint64_t srcDomainCycleAtDone;$/;"	m	class:CrossingEvent
srcId	event_recorder.h	/^        uint32_t srcId;$/;"	m	class:EventRecorder
srcId	filter_cache.h	/^        uint32_t srcId; \/\/should match the core$/;"	m	class:FilterCache
srcId	memory_hierarchy.h	/^    uint32_t srcId;$/;"	m	struct:MemReq
start	phase_slab_alloc.h	/^                Slab* start;$/;"	m	class:PhaseSlabAlloc::SlabList
start	profile_stats.h	/^        void start() {$/;"	f	class:ClockStat
start	scheduler.h	/^        void start(uint32_t pid, uint32_t tid, const g_vector<bool>& mask) {$/;"	f	class:Scheduler
start	zsim.cpp	/^    uintptr_t start;$/;"	m	struct:Section	file:
startAccess	coherence_ctrls.h	/^        bool startAccess(MemReq& req) {$/;"	f	class:MESICC
startAccess	coherence_ctrls.h	/^        bool startAccess(MemReq& req) {$/;"	f	class:MESITerminalCC
startCycle	core_recorder.cpp	/^        uint64_t startCycle;$/;"	m	class:TimingCoreEvent	file:
startCycle	ooo_core_recorder.cpp	/^        uint64_t startCycle; \/\/not set up to simulate$/;"	m	class:OOOIssueEvent	file:
startCycle	ooo_core_recorder.cpp	/^        volatile uint64_t startCycle;$/;"	m	class:OOORespEvent	file:
startCycle	prefetcher.h	/^                uint64_t startCycle;  \/\/ FIXME: Dead for now, we should use it for profiling$/;"	m	struct:StreamPrefetcher::Entry::AccessTimes
startCycle	timing_cache.cpp	/^        uint64_t startCycle; \/\/for profiling purposes$/;"	m	class:MissStartEvent	file:
startEvent	event_recorder.h	/^    TimingEvent* startEvent;$/;"	m	struct:TimingRecord
startInv	coherence_ctrls.h	/^        void startInv() {$/;"	f	class:MESICC
startInv	coherence_ctrls.h	/^        void startInv() {$/;"	f	class:MESITerminalCC
startNextInterval	utility_monitor.cpp	/^void UMon::startNextInterval() {$/;"	f	class:UMon
startNs	profile_stats.h	/^        uint64_t startNs;$/;"	m	class:ClockStat
startNs	profile_stats.h	/^        uint64_t startNs;$/;"	m	class:TimeBreakdownStat
startReplacement	part_repl_policies.h	/^        void startReplacement(const MemReq* req) {$/;"	f	class:VantageReplPolicy
startReplacement	part_repl_policies.h	/^        void startReplacement(const MemReq* req) {$/;"	f	class:WayPartReplPolicy
startReplacement	repl_policies.h	/^        virtual void startReplacement(const MemReq* req) {} \/\/many policies don't need it$/;"	f	class:LegacyReplPolicy
startReplacement	repl_policies.h	/^        void startReplacement(const MemReq* req) {$/;"	f	class:ProfViolReplPolicy
startSysCycle	ddr_mem.h	/^            uint64_t startSysCycle;  \/\/ in sysCycles$/;"	m	struct:DDRMemory::Request
startTime	zsim_harness.cpp	/^static time_t startTime;$/;"	v	file:
startWatchdogThread	scheduler.cpp	/^void Scheduler::startWatchdogThread() {$/;"	f	class:Scheduler
started	process_tree.h	/^        bool started;$/;"	m	class:ProcessTreeNode
stat	stats.h	/^        inline uint64_t stat() const {$/;"	f	class:ProxyFuncStat
stat	stats.h	/^        inline uint64_t stat() const {$/;"	f	class:ProxyStat
statSwaps	cache_arrays.h	/^        Counter statSwaps;$/;"	m	class:ZArray
state	barrier.h	/^            volatile State state;$/;"	m	struct:Barrier::ThreadSyncInfo
state	core_recorder.h	/^        State state;$/;"	m	class:CoreRecorder
state	ddr_mem.cpp	/^        State state;$/;"	m	class:SchedEvent	file:
state	memory_hierarchy.h	/^    MESIState* state;$/;"	m	struct:MemReq
state	mtrand.h	/^        uint64_t state[N];   \/\/ internal state$/;"	m	class:MTRand
state	ooo_core_recorder.h	/^        State state;$/;"	m	class:OOOCoreRecorder
state	scheduler.h	/^            ContextState state;$/;"	m	struct:Scheduler::ContextInfo
state	scheduler.h	/^            ThreadState state;$/;"	m	struct:Scheduler::ThreadInfo
state	timing_event.h	/^        EventState state;$/;"	m	class:TimingEvent
statsBackend	zsim.h	/^    StatsBackend* statsBackend; \/\/end-of-sim backend$/;"	m	struct:GlobSimInfo
statsPhaseInterval	zsim.h	/^    uint32_t statsPhaseInterval;$/;"	m	struct:GlobSimInfo
status	zsim_harness.cpp	/^    volatile ProcStatus status;$/;"	m	struct:ProcInfo	file:
std	virt/common.h	/^    SYSCALL_STANDARD std;$/;"	m	struct:PostPatchArgs
std	virt/common.h	/^    SYSCALL_STANDARD std;$/;"	m	struct:PrePatchArgs
step	config.cpp	/^    int32_t step;$/;"	m	struct:Range	file:
store	filter_cache.h	/^        inline uint64_t store(Address vAddr, uint64_t curCycle) {$/;"	f	class:FilterCache
store	ooo_core.cpp	/^void OOOCore::store(Address addr) {$/;"	f	class:OOOCore
store	simple_core.cpp	/^void SimpleCore::store(Address addr) {$/;"	f	class:SimpleCore
storeAddrs	ooo_core.h	/^        Address storeAddrs[256];$/;"	m	class:OOOCore
storeAndRecord	timing_core.cpp	/^void TimingCore::storeAndRecord(Address addr) {$/;"	f	class:TimingCore
storeCycle	ooo_core.h	/^            uint64_t storeCycle;$/;"	m	struct:OOOCore::FwdEntry
storeOps	decoder.h	/^            uint32_t storeOps[MAX_INSTR_STORES];$/;"	m	struct:Decoder::Instr
storePtr	core.h	/^    void (*storePtr)(THREADID, ADDRINT);$/;"	m	struct:InstrFuncPtrs
storeQueue	ooo_core.h	/^        ReorderBuffer<32, 4> storeQueue;$/;"	m	class:OOOCore
stores	ooo_core.h	/^        uint32_t stores;$/;"	m	class:OOOCore
str	ooo_core_recorder.cpp	/^        virtual std::string str() {$/;"	f	class:OOOIssueEvent
str	timing_event.h	/^        virtual std::string str() { std::string res; return res; }$/;"	f	class:TimingEvent
stride	prefetcher.h	/^            int32_t stride;$/;"	m	struct:StreamPrefetcher::Entry
subgroups	config.cpp	/^void Config::subgroups(const char* key, std::vector<const char*>& grps) {$/;"	f	class:Config
subgroups	config.h	/^        void subgroups(const std::string& key, std::vector<const char*>& grps) {subgroups(key.c_str(), grps);}$/;"	f	class:Config
sumRegularAggregates	hdf5_stats.cpp	/^        bool sumRegularAggregates;$/;"	m	class:HDF5BackendImpl	file:
sup	config.cpp	/^    int32_t sup;$/;"	m	struct:Range	file:
supDomain	contention_sim.h	/^            uint32_t supDomain; \/\/supreme, ie first not included$/;"	m	struct:ContentionSim::SimThreadData
swapArray	cache_arrays.h	/^        uint32_t* swapArray; \/\/contains physical positions$/;"	m	class:ZArray
swapArrayLen	cache_arrays.h	/^        uint32_t swapArrayLen; \/\/set in preinsert()$/;"	m	class:ZArray
sync	barrier.h	/^        void sync(uint32_t tid, lock_t* schedLock) {$/;"	f	class:Barrier
sync	scheduler.h	/^        uint32_t sync(uint32_t pid, uint32_t tid, uint32_t cid) {$/;"	f	class:Scheduler
syncedFastForward	process_tree.h	/^        const bool syncedFastForward; \/\/if true, make sim wait when fast-forwarding$/;"	m	class:ProcessTreeNode
sysFreqKHz	ddr_mem.h	/^        uint64_t sysFreqKHz, memFreqKHz;$/;"	m	class:DDRMemory
sysFreqKHz	detailed_mem.h	/^        uint64_t sysFreqKHz;$/;"	m	class:MemControllerBase
sysToMemCycle	ddr_mem.h	/^        inline uint64_t sysToMemCycle(uint64_t sysCycle) { return sysCycle*memFreqKHz\/sysFreqKHz+1; }$/;"	f	class:DDRMemory
sysToMemCycle	detailed_mem.h	/^        inline uint64_t sysToMemCycle(uint64_t sysCycle) { return sysCycle*memFreqKHz\/sysFreqKHz; }$/;"	f	class:MemControllerBase
sysToMicroSec	detailed_mem.h	/^        inline uint64_t sysToMicroSec(uint64_t sysCycle) { return sysCycle*1000\/sysFreqKHz; }$/;"	f	class:MemControllerBase
sys_alloc	g_heap/dlmalloc.h.c	/^static void* sys_alloc(mstate m, size_t nb) {$/;"	f	file:
sys_trim	g_heap/dlmalloc.h.c	/^static int sys_trim(mstate m, size_t pad) {$/;"	f	file:
syscallBlacklistRegex	process_tree.h	/^        const g_string syscallBlacklistRegex;$/;"	m	class:ProcessTreeNode
syscallLeave	scheduler.cpp	/^void Scheduler::syscallLeave(uint32_t pid, uint32_t tid, uint32_t cid, uint64_t pc, int syscallNumber, uint64_t arg0, uint64_t arg1) {$/;"	f	class:Scheduler
syscallNames	virt/syscall_name.cpp	/^static const char* syscallNames[] = {$/;"	v	file:
syscallNumber	scheduler.h	/^            const int syscallNumber;$/;"	m	struct:Scheduler::FakeLeaveInfo
tBL	ddr_mem.h	/^        uint32_t tBL;    \/\/ burst length (== tTrans)$/;"	m	class:DDRMemory
tCAS	detailed_mem_params.h	/^        uint32_t tCAS;$/;"	m	class:MemParam
tCCD	detailed_mem_params.h	/^        uint32_t tCCD;$/;"	m	class:MemParam
tCK	detailed_mem_params.h	/^        double tCK;$/;"	m	class:MemParam
tCL	ddr_mem.h	/^        uint32_t tCL;    \/\/ CAS latency$/;"	m	class:DDRMemory
tCMD	detailed_mem_params.h	/^        uint32_t tCMD;$/;"	m	class:MemParam
tCWD	detailed_mem_params.h	/^        uint32_t tCWD;$/;"	m	class:MemParam
tFAW	ddr_mem.h	/^        uint32_t tFAW;   \/\/ No more than 4 ACTs per rank in this window$/;"	m	class:DDRMemory
tFAW	detailed_mem_params.h	/^        uint32_t tFAW;$/;"	m	class:MemParam
tFAWCycle	detailed_mem.h	/^        uint64_t *tFAWCycle;$/;"	m	class:MemRankBase
tFAWIndex	detailed_mem.h	/^        uint32_t tFAWIndex;$/;"	m	class:MemRankBase
tRAS	ddr_mem.h	/^        uint32_t tRAS;   \/\/ ACT to PRE$/;"	m	class:DDRMemory
tRAS	detailed_mem_params.h	/^        uint32_t tRAS;$/;"	m	class:MemParam
tRC	detailed_mem_params.h	/^        uint32_t tRC;$/;"	m	class:MemParam
tRCD	ddr_mem.h	/^        uint32_t tRCD;   \/\/ ACT to CAS$/;"	m	class:DDRMemory
tRCD	detailed_mem_params.h	/^        uint32_t tRCD;$/;"	m	class:MemParam
tREFI	ddr_mem.h	/^        uint32_t tREFI;  \/\/ Refresh interval$/;"	m	class:DDRMemory
tREFI	detailed_mem_params.h	/^        uint32_t tREFI;$/;"	m	class:MemParam
tRFC	ddr_mem.h	/^        uint32_t tRFC;   \/\/ Refresh to ACT (refresh leaves rows closed)$/;"	m	class:DDRMemory
tRFC	detailed_mem_params.h	/^        uint32_t tRFC;$/;"	m	class:MemParam
tRP	ddr_mem.h	/^        uint32_t tRP;    \/\/ PRE to ACT$/;"	m	class:DDRMemory
tRP	detailed_mem_params.h	/^        uint32_t tRP;$/;"	m	class:MemParam
tRPab	detailed_mem_params.h	/^        uint32_t tRPab;$/;"	m	class:MemParam
tRRD	ddr_mem.h	/^        uint32_t tRRD;   \/\/ ACT to ACT$/;"	m	class:DDRMemory
tRRD	detailed_mem_params.h	/^        uint32_t tRRD;$/;"	m	class:MemParam
tRTP	ddr_mem.h	/^        uint32_t tRTP;   \/\/ RD to PRE$/;"	m	class:DDRMemory
tRTP	detailed_mem_params.h	/^        uint32_t tRTP;$/;"	m	class:MemParam
tRTRS	detailed_mem_params.h	/^        uint32_t tRTRS;$/;"	m	class:MemParam
tTrans	detailed_mem_params.h	/^        uint32_t tTrans;$/;"	m	class:MemParam
tTransCrit	detailed_mem_params.h	/^        uint32_t tTransCrit;$/;"	m	class:MemParam
tWR	ddr_mem.h	/^        uint32_t tWR;    \/\/ end of WR burst to PRE$/;"	m	class:DDRMemory
tWR	detailed_mem_params.h	/^        uint32_t tWR;$/;"	m	class:MemParam
tWTR	ddr_mem.h	/^        uint32_t tWTR;   \/\/ end of WR burst to RD command$/;"	m	class:DDRMemory
tWTR	detailed_mem_params.h	/^        uint32_t tWTR;$/;"	m	class:MemParam
tXP	detailed_mem_params.h	/^        uint32_t tXP;$/;"	m	class:MemParam
tag	prefetcher.h	/^        Address tag[16];$/;"	m	class:StreamPrefetcher
tagLat	timing_cache.h	/^        uint32_t tagLat, ways, cands;$/;"	m	class:TimingCache
tail	intrusive_list.h	/^        T* tail;$/;"	m	class:InList
takeOneLine	part_repl_policies.h	/^        void takeOneLine() {$/;"	f	class:VantageReplPolicy
target	event_queue.h	/^        uint64_t target;$/;"	m	class:AdaptiveEvent
targetSize	part_repl_policies.h	/^    uint64_t targetSize; \/\/in lines$/;"	m	struct:PartInfo
tbinptr	g_heap/dlmalloc.h.c	/^typedef struct malloc_tree_chunk* tbinptr; \/* The type of bins of trees *\/$/;"	t	typeref:struct:malloc_tree_chunk	file:
tcc	coherence_ctrls.h	/^        MESITopCC* tcc;$/;"	m	class:MESICC
tchunk	g_heap/dlmalloc.h.c	/^typedef struct malloc_tree_chunk  tchunk;$/;"	t	typeref:struct:malloc_tree_chunk	file:
tchunkptr	g_heap/dlmalloc.h.c	/^typedef struct malloc_tree_chunk* tchunkptr;$/;"	t	typeref:struct:malloc_tree_chunk	file:
termStatus	zsim_harness.cpp	/^TerminationStatus termStatus = OK;$/;"	v
terminate	contention_sim.h	/^        volatile bool terminate;$/;"	m	class:ContentionSim
terminate	detailed_mem.h	/^            uint64_t terminate;$/;"	m	struct:MemControllerBase::powerValue
terminateWatchdogThread	scheduler.h	/^        volatile bool terminateWatchdogThread;$/;"	m	class:Scheduler
terminationConditionMet	zsim.h	/^    volatile bool terminationConditionMet;$/;"	m	struct:GlobSimInfo
testMode	part_repl_policies.h	/^        bool testMode;$/;"	m	class:WayPartReplPolicy
textAddr	debug.h	/^    void* textAddr;$/;"	m	struct:LibInfo
th	scheduler.h	/^            ThreadInfo* const th;$/;"	m	struct:Scheduler::FakeLeaveInfo
threadList	barrier.h	/^        ThreadSyncInfo threadList[MAX_THREADS];$/;"	m	class:Barrier
threadTicket	contention_sim.h	/^        volatile uint32_t threadTicket; \/\/used only at init$/;"	m	class:ContentionSim
threadTrampoline	scheduler.cpp	/^void Scheduler::threadTrampoline(void* arg) {$/;"	f	class:Scheduler
threadid	g_heap/dlmalloc.h.c	/^  long threadid;$/;"	m	struct:win32_mlock_t	file:
threadid	g_heap/dlmalloc.h.c	/^  threadid_t threadid;$/;"	m	struct:pthread_mlock_t	file:
threadid_t	g_heap/dlmalloc.h.c	/^struct threadid_t {$/;"	s	file:
threadsCreated	scheduler.h	/^        Counter threadsCreated, threadsFinished;$/;"	m	class:Scheduler
threadsDone	contention_sim.h	/^        volatile uint32_t threadsDone;$/;"	m	class:ContentionSim
threadsFinished	scheduler.h	/^        Counter threadsCreated, threadsFinished;$/;"	m	class:Scheduler
tick	ddr_mem.cpp	/^uint64_t DDRMemory::tick(uint64_t sysCycle) {$/;"	f	class:DDRMemory
tick	detailed_mem.cpp	/^uint32_t MemControllerBase::tick(uint64_t sysCycle) {$/;"	f	class:MemControllerBase
tick	dramsim_mem_ctrl.cpp	/^uint32_t DRAMSimMemory::tick(uint64_t cycle) { panic("???"); return 0; }$/;"	f	class:DRAMSimMemory
tick	dramsim_mem_ctrl.cpp	/^uint32_t DRAMSimMemory::tick(uint64_t cycle) {$/;"	f	class:DRAMSimMemory
tick	event_queue.h	/^        void tick() {$/;"	f	class:EventQueue
ticket_destroy	locks.h	/^static inline void ticket_destroy(volatile uint32_t* lock) {}$/;"	f
ticket_init	locks.h	/^static inline void ticket_init(volatile uint32_t* lock) {$/;"	f
ticket_lock	locks.h	/^static inline void ticket_lock(volatile uint32_t* lock) {$/;"	f
ticket_trylock	locks.h	/^static inline int ticket_trylock(volatile uint32_t* lock) {$/;"	f
ticket_unlock	locks.h	/^static inline void ticket_unlock(volatile uint32_t* lock) {$/;"	f
tid	g_heap/dlmalloc.h.c	/^    pthread_t tid;$/;"	m	struct:threadid_t	file:
tid	virt/common.h	/^    uint32_t tid;$/;"	m	struct:PostPatchArgs
tid	virt/common.h	/^    uint32_t tid;$/;"	m	struct:PrePatchArgs
times	prefetcher.h	/^            AccessTimes times[64];$/;"	m	struct:StreamPrefetcher::Entry
timespecToNs	virt/time_conv.h	/^static inline uint64_t timespecToNs(struct timespec ts) {$/;"	f
timestamp	part_repl_policies.h	/^        uint64_t timestamp;$/;"	m	class:VantageReplPolicy
timestamp	part_repl_policies.h	/^        uint64_t timestamp;$/;"	m	class:WayPartReplPolicy
timestamp	prefetcher.h	/^        uint64_t timestamp;  \/\/ for LRU$/;"	m	class:StreamPrefetcher
timestamp	repl_policies.h	/^        uint64_t timestamp; \/\/ incremented on each access$/;"	m	class:LFUReplPolicy
timestamp	repl_policies.h	/^        uint64_t timestamp; \/\/ incremented on each access$/;"	m	class:LRUReplPolicy
timevalToNs	virt/time_conv.h	/^static inline uint64_t timevalToNs(struct timeval tv) {$/;"	f
tmalloc_large	g_heap/dlmalloc.h.c	/^static void* tmalloc_large(mstate m, size_t nb) {$/;"	f	file:
tmalloc_small	g_heap/dlmalloc.h.c	/^static void* tmalloc_small(mstate m, size_t nb) {$/;"	f	file:
top	g_heap/dlmalloc.h.c	/^  mchunkptr  top;$/;"	m	struct:malloc_state	file:
topLock	timing_cache.h	/^        lock_t topLock;$/;"	m	class:TimingCache
topsize	g_heap/dlmalloc.h.c	/^  size_t     topsize;$/;"	m	struct:malloc_state	file:
total	detailed_mem.h	/^            uint64_t total;$/;"	m	struct:MemControllerBase::powerValue
totalCapacity	detailed_mem_params.h	/^        uint32_t totalCapacity; \/\/ mega byte$/;"	m	class:MemParam
totalGapCycles	core_recorder.h	/^        uint64_t totalGapCycles; \/\/does not include gapCycles$/;"	m	class:CoreRecorder
totalGapCycles	ooo_core_recorder.h	/^        uint64_t totalGapCycles; \/\/does not include gapCycles$/;"	m	class:OOOCoreRecorder
totalHaltedCycles	core_recorder.h	/^        uint64_t totalHaltedCycles; \/\/does not include cycles since last transition to HALTED$/;"	m	class:CoreRecorder
totalHaltedCycles	ooo_core_recorder.h	/^        uint64_t totalHaltedCycles; \/\/does not include cycles since last transition to HALTED$/;"	m	class:OOOCoreRecorder
totalNs	profile_stats.h	/^        uint64_t totalNs;$/;"	m	class:ClockStat
totalSize	part_repl_policies.h	/^        uint32_t totalSize;$/;"	m	class:VantageReplPolicy
totalSize	part_repl_policies.h	/^        uint32_t totalSize;$/;"	m	class:WayPartReplPolicy
trStack	event_recorder.h	/^        g_vector<TimingRecord> trStack;$/;"	m	class:EventRecorder
trace	log.h	110;"	d
trace	log.h	122;"	d
transition	breakdown_stats.h	/^        void transition(uint32_t newState, uint64_t cycle) {$/;"	f	class:CycleBreakdownStat
transition	profile_stats.h	/^        void transition(uint32_t newState) {$/;"	f	class:TimeBreakdownStat
traverse_and_check	g_heap/dlmalloc.h.c	/^static size_t traverse_and_check(mstate m) {$/;"	f	file:
treebin_at	g_heap/dlmalloc.h.c	2780;"	d	file:
treebins	g_heap/dlmalloc.h.c	/^  tbinptr    treebins[NTREEBINS];$/;"	m	struct:malloc_state	file:
treemap	g_heap/dlmalloc.h.c	/^  binmap_t   treemap;$/;"	m	struct:malloc_state	file:
treemap_is_marked	g_heap/dlmalloc.h.c	2874;"	d	file:
trigger	zsim.h	/^    uint64_t trigger; \/\/code with what triggered the current stats dump$/;"	m	struct:GlobSimInfo
trim_check	g_heap/dlmalloc.h.c	/^  size_t     trim_check;$/;"	m	struct:malloc_state	file:
trim_threshold	g_heap/dlmalloc.h.c	/^  size_t trim_threshold;$/;"	m	struct:malloc_params	file:
tryLowPrioAccess	timing_cache.cpp	/^uint64_t TimingCache::tryLowPrioAccess(uint64_t cycle) {$/;"	f	class:TimingCache
trySchedule	ddr_mem.cpp	/^uint64_t DDRMemory::trySchedule(uint64_t curCycle, uint64_t sysCycle) {$/;"	f	class:DDRMemory
trySchedule	ooo_core.h	/^        inline uint8_t trySchedule(WinCycle& wc, uint8_t portMask) {$/;"	f	class:WindowStructure
tryWakeNext	barrier.h	/^        void tryWakeNext(uint32_t tid) {$/;"	f	class:Barrier
ts	part_repl_policies.h	/^            uint64_t ts; \/\/timestamp, >0 if in the cache, == 0 if line is empty (little significance otherwise)$/;"	m	struct:VantageReplPolicy::LineInfo
ts	part_repl_policies.h	/^            uint64_t ts; \/\/timestamp, >0 if in the cache, == 0 if line is empty$/;"	m	struct:WayPartReplPolicy::WayPartInfo
ts	prefetcher.h	/^            uint64_t ts;$/;"	m	struct:StreamPrefetcher::Entry
ts	repl_policies.h	/^            uint64_t ts;$/;"	m	struct:LFUReplPolicy::LFUInfo
twist	mtrand.h	/^        uint64_t twist(const uint64_t m, const uint64_t s0, const uint64_t s1) const {$/;"	f	class:MTRand
type	core.h	/^    uint64_t type;$/;"	m	struct:InstrFuncPtrs
type	decoder.h	/^    UopType type; \/\/1 byte$/;"	m	struct:DynUop
type	detailed_mem.h	/^        MemAccessType type;$/;"	m	class:MemAccessEventBase
type	event_recorder.h	/^    AccessType type;$/;"	m	struct:TimingRecord
type	memory_hierarchy.h	/^    AccessType type;$/;"	m	struct:MemReq
ubWin	ooo_core.h	/^        UBWin ubWin;$/;"	m	class:WindowStructure
uint8_t	decoder.h	/^enum UopType : uint8_t {UOP_GENERAL, UOP_LOAD, UOP_STORE, UOP_STORE_ADDR, UOP_FENCE};$/;"	g
umonLines	utility_monitor.h	/^        uint32_t umonLines;$/;"	m	class:UMon
uniqueTypes	hdf5_stats.cpp	/^        std::vector<hid_t> uniqueTypes;$/;"	m	class:HDF5BackendImpl	file:
unlikely	log.h	49;"	d
unlink	intrusive_list.h	/^    void unlink(InList<T>* lst) {$/;"	f	struct:InListNode
unlink_chunk	g_heap/dlmalloc.h.c	3727;"	d	file:
unlink_first_small_chunk	g_heap/dlmalloc.h.c	3548;"	d	file:
unlink_large_chunk	g_heap/dlmalloc.h.c	3650;"	d	file:
unlink_small_chunk	g_heap/dlmalloc.h.c	3528;"	d	file:
unlock	coherence_ctrls.h	/^        inline void unlock() {$/;"	f	class:MESIBottomCC
unlock	coherence_ctrls.h	/^        inline void unlock() {$/;"	f	class:MESITopCC
unlock	virt/port_virtualizer.h	/^        void unlock() { futex_unlock(&pvLock); }$/;"	f	class:PortVirtualizer
unmatchedFutexWakeups	scheduler.h	/^        volatile uint32_t unmatchedFutexWakeups;$/;"	m	class:Scheduler
uop	decoder.h	/^    DynUop uop[1];$/;"	m	struct:DynBbl
uopQueue	ooo_core.h	/^        CycleQueue<28> uopQueue;  \/\/ models issue queue $/;"	m	class:OOOCore
uops	decoder.h	/^    uint32_t uops;$/;"	m	struct:DynBbl
uops	ooo_core.h	/^        uint64_t instrs, uops, bbls, approxInstrs, mispredBranches;$/;"	m	class:OOOCore
uordblks	g_heap/dlmalloc.h.c	/^  MALLINFO_FIELD_TYPE uordblks; \/* total allocated space *\/$/;"	m	struct:mallinfo	file:
update	ideal_arrays.h	/^                void update(uint32_t id, const MemReq* req) {panic("!")}$/;"	f	class:IdealLRUArray::ProxyReplPolicy
update	ideal_arrays.h	/^        void update(uint32_t id, const MemReq* req) {$/;"	f	class:IdealLRUPartReplPolicy
update	part_repl_policies.h	/^        void update(uint32_t id, const MemReq* req) {$/;"	f	class:VantageReplPolicy
update	part_repl_policies.h	/^        void update(uint32_t id, const MemReq* req) {$/;"	f	class:WayPartReplPolicy
update	process_stats.cpp	/^void ProcessStats::update() {$/;"	f	class:ProcessStats
update	repl_policies.h	/^        void update(uint32_t id, const MemReq* req) {$/;"	f	class:LFUReplPolicy
update	repl_policies.h	/^        void update(uint32_t id, const MemReq* req) {$/;"	f	class:LRUReplPolicy
update	repl_policies.h	/^        void update(uint32_t id, const MemReq* req) {$/;"	f	class:NRUReplPolicy
update	repl_policies.h	/^        void update(uint32_t id, const MemReq* req) {$/;"	f	class:ProfViolReplPolicy
update	repl_policies.h	/^        void update(uint32_t id, const MemReq* req) {}$/;"	f	class:RandReplPolicy
updateCore	process_stats.cpp	/^void ProcessStats::updateCore(uint32_t cid, uint32_t p) {$/;"	f	class:ProcessStats
updateLatency	mem_ctrls.cpp	/^void MD1Memory::updateLatency() {$/;"	f	class:MD1Memory
updateLock	detailed_mem.h	/^        lock_t updateLock;$/;"	m	class:MemControllerBase
updateLock	mem_ctrls.h	/^        lock_t updateLock;$/;"	m	class:MD1Memory
updateStats	detailed_mem.cpp	/^void MemControllerBase::updateStats(void) {$/;"	f	class:MemControllerBase
use_lock	g_heap/dlmalloc.h.c	2601;"	d	file:
use_mmap	g_heap/dlmalloc.h.c	2605;"	d	file:
use_noncontiguous	g_heap/dlmalloc.h.c	2609;"	d	file:
usecToSysCycle	detailed_mem.h	/^        inline uint64_t usecToSysCycle(uint64_t usec)    { return usec*sysFreqKHz\/1000; }$/;"	f	class:MemControllerBase
used	ideal_arrays.h	/^            bool used; \/\/careful, true except when just evicted, even if invalid$/;"	m	struct:IdealLRUPartReplPolicy::Entry
used	phase_slab_alloc.h	/^            uint32_t used;$/;"	m	struct:PhaseSlabAlloc::Slab
usmblks	g_heap/dlmalloc.h.c	/^  MALLINFO_FIELD_TYPE usmblks;  \/* maximum total allocated space *\/$/;"	m	struct:mallinfo	file:
val	virt/timeout.cpp	/^    int val;$/;"	m	struct:FutexInfo	file:
valid	prefetcher.h	/^            std::bitset<64> valid;$/;"	m	struct:StreamPrefetcher::Entry
valid	repl_policies.h	/^            bool valid;$/;"	m	struct:LFUReplPolicy::Rank
value_type	g_std/stl_galloc.h	/^        typedef T value_type;$/;"	t	class:StlGlobAlloc
vdsoEnd	zsim.cpp	/^static uintptr_t vdsoEnd;$/;"	v	file:
vdsoEntryMap	zsim.cpp	/^static std::unordered_map<ADDRINT, VdsoFunc> vdsoEntryMap;$/;"	v	file:
vdsoPatchData	zsim.cpp	/^VdsoPatchData vdsoPatchData[MAX_THREADS];$/;"	v
vdsoStart	zsim.cpp	/^static uintptr_t vdsoStart;$/;"	v	file:
virtToReal	virt/port_virtualizer.h	/^        g_unordered_map<int, int> virtToReal;$/;"	m	class:PortVirtualizer
visitChildren	timing_event.h	/^        inline void visitChildren(F f) {$/;"	f	class:TimingEvent
vsyscallEnd	zsim.cpp	/^static uintptr_t vsyscallEnd;$/;"	v	file:
vsyscallStart	zsim.cpp	/^static uintptr_t vsyscallStart;$/;"	v	file:
vsyscallWarned	zsim.cpp	/^static bool vsyscallWarned = false;$/;"	v	file:
wait	zsim.cpp	/^        void wait() {$/;"	f	class:SyncEvent
waitEvents	scheduler.h	/^        Counter scheduleEvents, waitEvents, handoffEvents, sleepEvents;$/;"	m	class:Scheduler
waitForContext	scheduler.h	/^        void waitForContext(ThreadInfo* th) {$/;"	f	class:Scheduler
waitLock	contention_sim.h	/^        lock_t waitLock;$/;"	m	class:ContentionSim
waitUntilQueued	scheduler.cpp	/^void Scheduler::waitUntilQueued(ThreadInfo* th) {$/;"	f	class:Scheduler
wakeLock	contention_sim.h	/^            lock_t wakeLock; \/\/used to sleep\/wake up simulation thread$/;"	m	struct:ContentionSim::SimThreadData
wakeup	scheduler.h	/^        void wakeup(ThreadInfo* th, bool needsJoin) {$/;"	f	class:Scheduler
wakeupPhase	scheduler.h	/^            uint64_t wakeupPhase; \/\/if SLEEPING, when do we have to wake up?$/;"	m	struct:Scheduler::ThreadInfo
warn	log.h	85;"	d
watchdogThreadFunc	scheduler.cpp	/^void Scheduler::watchdogThreadFunc() {$/;"	f	class:Scheduler
wayPartIndex	part_repl_policies.h	/^        uint32_t* wayPartIndex; \/\/stores partition of each way$/;"	m	class:WayPartReplPolicy
waySize	part_repl_policies.h	/^        uint32_t waySize;$/;"	m	class:WayPartReplPolicy
ways	cache_arrays.h	/^        uint32_t ways;$/;"	m	class:ZArray
ways	part_repl_policies.h	/^        uint32_t ways;$/;"	m	class:WayPartReplPolicy
ways	timing_cache.h	/^        uint32_t tagLat, ways, cands;$/;"	m	class:TimingCache
win32_acquire_lock	g_heap/dlmalloc.h.c	/^static FORCEINLINE int win32_acquire_lock (MLOCK_T *sl) {$/;"	f	file:
win32_mlock_t	g_heap/dlmalloc.h.c	/^struct win32_mlock_t {$/;"	s	file:
win32_release_lock	g_heap/dlmalloc.h.c	/^static FORCEINLINE void win32_release_lock (MLOCK_T *sl) {$/;"	f	file:
win32_try_lock	g_heap/dlmalloc.h.c	/^static FORCEINLINE int win32_try_lock (MLOCK_T *sl) {$/;"	f	file:
win32direct_mmap	g_heap/dlmalloc.h.c	/^static FORCEINLINE void* win32direct_mmap(size_t size) {$/;"	f	file:
win32mmap	g_heap/dlmalloc.h.c	/^static FORCEINLINE void* win32mmap(size_t size) {$/;"	f	file:
win32munmap	g_heap/dlmalloc.h.c	/^static FORCEINLINE int win32munmap(void* ptr, size_t size) {$/;"	f	file:
wokenUp	scheduler.h	/^            uint32_t wokenUp;$/;"	m	struct:Scheduler::FutexJoinInfo
wrAddr	filter_cache.h	/^            volatile Address wrAddr;$/;"	m	struct:FilterCache::FilterEntry
wrDoneQueue	detailed_mem.h	/^        g_vector <MemSchedQueueElem> wrDoneQueue;$/;"	m	class:MemSchedulerDefault
wrQueue	ddr_mem.h	/^        RequestQueue<Request> rdQueue, wrQueue;$/;"	m	class:DDRMemory
wrQueue	detailed_mem.h	/^        g_vector <MemSchedQueueElem> wrQueue;$/;"	m	class:MemSchedulerDefault
wrQueueHighWatermark	detailed_mem.h	/^        uint32_t wrQueueHighWatermark;$/;"	m	class:MemSchedulerDefault
wrQueueLowWatermark	detailed_mem.h	/^        uint32_t wrQueueLowWatermark;$/;"	m	class:MemSchedulerDefault
wrQueueSize	detailed_mem.h	/^        uint32_t wrQueueSize;$/;"	m	class:MemSchedulerDefault
wrReqs	ddr_mem.h	/^            InList<Request> wrReqs;$/;"	m	struct:DDRMemory::Bank
write	ddr_mem.cpp	/^        bool write;$/;"	m	class:DDRMemoryAccEvent	file:
write	ddr_mem.h	/^            bool write;$/;"	m	struct:DDRMemory::Request
write	dramsim_mem_ctrl.cpp	/^        bool write;$/;"	m	class:DRAMSimAccEvent	file:
write	repl_policies.h	/^            uint64_t write;$/;"	m	struct:ProfViolReplPolicy::AccTimes
writeAndClose	config.cpp	/^void Config::writeAndClose(const char* outFile, bool strictCheck) {$/;"	f	class:Config
writeBurstCount	detailed_mem.h	/^        uint64_t writeBurstCount;$/;"	m	class:MemRankBase
writeDqPin	detailed_mem_params.h	/^        uint32_t writeDqPin;$/;"	m	class:MemParam
writeTermPin	detailed_mem_params.h	/^        uint32_t writeTermPin;$/;"	m	class:MemParam
writeVar	config.cpp	/^template<typename T> static void writeVar(libconfig::Config* cfg, const char* key, T val) {$/;"	f	file:
writeVar	config.cpp	/^template<typename T> static void writeVar(libconfig::Setting& setting, const char* key, T val) {$/;"	f	file:
x	cache_arrays.h	/^        ZWalkInfo* x;$/;"	m	struct:ZCands::iterator
x	cache_arrays.h	/^        uint32_t x;$/;"	m	struct:SetAssocCands::iterator
youngLines	repl_policies.h	/^        uint32_t youngLines;$/;"	m	class:NRUReplPolicy
zeroLoadLatency	mem_ctrls.h	/^        uint32_t zeroLoadLatency;$/;"	m	class:MD1Memory
zeroLoadLatency	weave_md1_mem.h	/^        const uint32_t zeroLoadLatency;$/;"	m	class:WeaveMD1Memory
zeroLoadLatency	weave_md1_mem.h	/^        uint32_t zeroLoadLatency;$/;"	m	class:WeaveSimpleMemory
zinfo	zsim.cpp	/^GlobSimInfo* zinfo;$/;"	v
zllStartCycle	ooo_core_recorder.cpp	/^        uint64_t zllStartCycle; \/\/minStartCycle - gapCycles, stable across readjustments of gapCycles$/;"	m	class:OOODispatchEvent	file:
zllStartCycle	ooo_core_recorder.cpp	/^        uint64_t zllStartCycle; \/\/minStartCycle - gapCycles, stable across readjustments of gapCycles$/;"	m	class:OOOIssueEvent	file:
zllStartCycle	ooo_core_recorder.cpp	/^        uint64_t zllStartCycle; \/\/minStartCycle - gapCycles, stable across readjustments of gapCycles$/;"	m	class:OOORespEvent	file:
~Barrier	barrier.h	/^        ~Barrier() {}$/;"	f	class:Barrier
~Config	config.cpp	/^Config::~Config() {$/;"	f	class:Config
~FakeLeaveInfo	scheduler.h	/^            ~FakeLeaveInfo() {$/;"	f	struct:Scheduler::FakeLeaveInfo
~GlobAlloc	galloc.h	/^        virtual ~GlobAlloc() {}$/;"	f	class:GlobAlloc
~HDF5BackendImpl	hdf5_stats.cpp	/^        ~HDF5BackendImpl() {}$/;"	f	class:HDF5BackendImpl
~HashFamily	hash.h	/^        virtual ~HashFamily() {}$/;"	f	class:HashFamily
~LFUReplPolicy	repl_policies.h	/^        ~LFUReplPolicy() {$/;"	f	class:LFUReplPolicy
~LRUReplPolicy	repl_policies.h	/^        ~LRUReplPolicy() {$/;"	f	class:LRUReplPolicy
~MemChannelBase	detailed_mem.cpp	/^MemChannelBase::~MemChannelBase(void) {$/;"	f	class:MemChannelBase
~MemControllerBase	detailed_mem.cpp	/^MemControllerBase::~MemControllerBase() {$/;"	f	class:MemControllerBase
~MemParam	detailed_mem_params.cpp	/^MemParam::~MemParam()$/;"	f	class:MemParam
~MemRankBase	detailed_mem.cpp	/^MemRankBase::~MemRankBase() {$/;"	f	class:MemRankBase
~MemSchedulerBase	detailed_mem.h	/^        virtual ~MemSchedulerBase() {}$/;"	f	class:MemSchedulerBase
~MemSchedulerDefault	detailed_mem.cpp	/^MemSchedulerDefault::~MemSchedulerDefault() {}$/;"	f	class:MemSchedulerDefault
~NRUReplPolicy	repl_policies.h	/^        ~NRUReplPolicy() {$/;"	f	class:NRUReplPolicy
~PartReplPolicy	part_repl_policies.h	/^        ~PartReplPolicy() { delete monitor; }$/;"	f	class:PartReplPolicy
~RandReplPolicy	repl_policies.h	/^        ~RandReplPolicy() {$/;"	f	class:RandReplPolicy
~Scheduler	scheduler.h	/^        ~Scheduler() {}$/;"	f	class:Scheduler
~Stat	stats.h	/^        virtual ~Stat() {}$/;"	f	class:Stat
~StatsBackend	stats.h	/^        virtual ~StatsBackend() {}$/;"	f	class:StatsBackend
~TreeLRUReplPolicy	repl_policies.h	/^        ~TreeLRUReplPolicy() {$/;"	f	class:TreeLRUReplPolicy
~UMonMonitor	monitor.cpp	/^UMonMonitor::~UMonMonitor() {$/;"	f	class:UMonMonitor
